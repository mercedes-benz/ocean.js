{"version":3,"file":"lib.modern.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/pools/ssContracts/SideStaking.ts","../src/pools/Router.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/models/Config.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { ContractConfig } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { GASLIMIT_DEFAULT, ZERO_ADDRESS } from './Constants'\n\nexport function setContractDefaults(\n  contract: Contract,\n  config: ContractConfig\n): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  config: ContractConfig\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport async function getFreOrderParams(\n  web3: Web3,\n  freParams: FreOrderParams\n): Promise<any> {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: await amountToUnits(\n      web3,\n      freParams.baseTokenAddress,\n      freParams.maxBaseTokenAmount,\n      freParams.baseTokenDecimals\n    ),\n    swapMarketFee: await amountToUnits(\n      web3,\n      freParams.baseTokenAddress,\n      freParams.swapMarketFee,\n      freParams.baseTokenDecimals\n    ),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\n\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n    return amountFormatted.toFixed(0)\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n\n/**\n * Estimates the gas used when a function would be executed on chain\n * @param {string} from account that calls the function\n * @param {Function} functionToEstimateGas function that we need to estimate the gas\n * @param {...any[]} args arguments of the function\n * @return {Promise<number>} gas cost of the function\n */\nexport async function estimateGas(\n  from: string,\n  functionToEstimateGas: Function,\n  ...args: any[]\n): Promise<any> {\n  let estimatedGas = GASLIMIT_DEFAULT\n  try {\n    estimatedGas = await functionToEstimateGas.apply(null, args).estimateGas(\n      {\n        from: from\n      },\n      (err, estGas) => (err ? GASLIMIT_DEFAULT : estGas)\n    )\n  } catch (e) {\n    LoggerInstance.error(`ERROR: Estimate gas failed!`, e)\n  }\n  return estimatedGas\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader.split('=')[1]\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n// eslint-disable-next-line import/no-named-default\nimport { default as CustomContractAddressess } from '../../address.json'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000',\n    providerUri: 'http://172.15.0.4:8030'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io/',\n    oceanTokenSymbol: 'OCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 81001,\n    network: 'supernetTestnet',\n    nodeUri: 'https://rpc-edgenet.polygon.technology',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://explorer-edgenet.polygon.technology/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    LoggerInstance.log('network : ', filterBy, network)\n    LoggerInstance.log('network configHelperNetworks : ', configHelperNetworks)\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n    LoggerInstance.log('network config : ', config)\n    LoggerInstance.log('network CustomContractAddressess : ', CustomContractAddressess)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(\n      config.network,\n      CustomContractAddressess\n    )\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  amountToUnits,\n  estimateGas,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { Config, ContractConfig } from '../models'\nimport BigNumber from 'bignumber.js'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  return estimateGas(account, tokenContract.methods.approve, spender, amount)\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<TransactionReceipt | string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  if (!force) {\n    const currentAllowance = await allowance(\n      web3,\n      tokenAddress,\n      account,\n      spender,\n      tokenDecimals,\n      config\n    )\n    if (new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowance\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, config)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function approveWei(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowanceWei(web3, tokenAddress, account, spender)\n    if (new BigNumber(currentAllowence).gt(new BigNumber(amount))) {\n      return currentAllowence\n    }\n  }\n  let result = null\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amount\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amount).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n/**\n * Estimate gas cost for transfer function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estTransfer(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  return estimateGas(account, tokenContract.methods.transfer, recipient, amount)\n}\n\n/**\n * Moves amount tokens from the caller’s account to recipient.\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount amount of ERC20 tokens (not as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function transfer(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n\n  try {\n    result = await tokenContract.methods.transfer(recipient, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(`ERROR: Failed to transfer tokens : ${e.message}`)\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowanceWei(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.allowance(account, spender).call()\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number,\n  config?: Config\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get decimals for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(web3: Web3, tokenAddress: string): Promise<number> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.decimals().call()\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(2)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance,\n  estimateGas,\n  ConfigHelper\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  private config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    poolAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(account, poolContract.methods.setSwapFee, fee)\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(account, pool.methods.setSwapFee, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getReserve(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getMarketFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getCommunityFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(address, poolContract.methods.collectOPC)\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(address, pool.methods.collectOPC)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(address, poolContract.methods.collectMarketFee)\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(address, pool.methods.collectMarketFee)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.updatePublishMarketFee,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await estimateGas(\n      address,\n      pool.methods.updatePublishMarketFee,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    return estimateGas(\n      address,\n      poolContract.methods.swapExactAmountIn,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        tokenAmountIn,\n        minAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const estGas = await estimateGas(\n      address,\n      pool.methods.swapExactAmountIn,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        tokenAmountIn,\n        minAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n\n    let result = null\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    return estimateGas(\n      address,\n      poolContract.methods.swapExactAmountOut,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        maxAmountIn,\n        tokenAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenOut)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const estGas = await estimateGas(\n      account,\n      pool.methods.swapExactAmountOut,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        maxAmountIn,\n        tokenAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.joinswapExternAmountIn,\n      tokenAmountIn,\n      minPoolAmountOut\n    )\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    tokenInDecimals?: number\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(\n      tokenIn,\n      tokenAmountIn,\n      tokenInDecimals\n    )\n    const estGas = await estimateGas(\n      account,\n      pool.methods.joinswapExternAmountIn,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.exitswapPoolAmountIn,\n      poolAmountIn,\n      minTokenAmountOut\n    )\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {number} poolDecimals optional number of decimals of the poool\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    poolDecimals?: number\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await this.amountToUnits(\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut,\n      poolDecimals\n    )\n    const estGas = await estimateGas(\n      account,\n      pool.methods.exitswapPoolAmountIn,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenOut)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await this.amountToUnits(\n      tokenOut,\n      tokenAmountOut,\n      tokenOutDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountIn,\n          tokenInDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountIn exact amount of tokenIn\n   * @param swapMarketFee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(\n      tokenIn,\n      tokenAmountIn,\n      tokenInDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountOut,\n          tokenOutDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   * @param {number} poolDecimals optional number of decimals of the poool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await this.amountToUnits(tokenIn, tokenAmountIn, tokenInDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await this.amountToUnits(\n      poolAddress,\n      poolAmountOut,\n      poolDecimals\n    )\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n        .call()\n\n      amount = await this.unitsToAmount(tokenIn, result, tokenInDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await this.amountToUnits(poolAddress, poolAmountIn, poolDecimals)\n        )\n        .call()\n      amount = await this.unitsToAmount(tokenOut, result, tokenOutDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await this.amountToUnits(tokenOut, tokenAmountOut, tokenOutDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_SWAP'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_JOIN'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_EXIT'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  setContractDefaults,\n  estimateGas,\n  ConfigHelper\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.activate,\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance)\n      )\n\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    return estimateGas(address, this.dispenserContract.methods.deactivate, dtAddress)\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.deactivate,\n        dtAddress\n      )\n\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.setAllowedSwapper,\n        dtAddress,\n        newAllowedSwapper\n      )\n\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    return estimateGas(address, this.dispenserContract.methods.ownerWithdraw, dtAddress)\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.ownerWithdraw,\n      dtAddress\n    )\n\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public fixedRateContract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    network?: string | number,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    this.fixedRateContract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.fixedRateContract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.buyDT,\n      datatokenAddress,\n      dtAmount,\n      maxBaseTokenAmount,\n      consumeMarketAddress,\n      consumeMarketFee\n    )\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.fixedRateContract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.sellDT,\n      datatokenAddress,\n      dtAmount,\n      maxBaseTokenAmount,\n      consumeMarketAddress,\n      consumeMarketFee\n    )\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.fixedRateContract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.fixedRateContract.methods\n      .getNumberOfExchanges()\n      .call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.setRate,\n      exchangeId,\n      await this.web3.utils.toWei(newRate)\n    )\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleExchangeState, exchangeId)\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleExchangeState,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleExchangeState(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleExchangeState, exchangeId)\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleExchangeState,\n      exchangeId\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleExchangeState(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.fixedRateContract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.fixedRateContract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.fixedRateContract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.fixedRateContract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const result = await this.fixedRateContract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.fixedRateContract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, result[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(\n      result.datatoken,\n      result.dtBalance,\n      +result.dtDecimals\n    )\n    result.btBalance = await this.unitsToAmount(\n      result.baseToken,\n      result.btBalance,\n      +result.btDecimals\n    )\n    result.dtSupply = await this.unitsToAmount(\n      result.datatoken,\n      result.dtSupply,\n      +result.dtDecimals\n    )\n    result.btSupply = await this.unitsToAmount(\n      result.baseToken,\n      result.btSupply,\n      +result.btDecimals\n    )\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.fixedRateContract.methods\n      .getFeesInfo(exchangeId)\n      .call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    result.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.fixedRateContract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.fixedRateContract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleMintState, exchangeId, true)\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.toggleMintState(exchangeId, false),\n      exchangeId,\n      false\n    )\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n    return estimateGas(account, fixedRate.methods.collectBT, exchangeId, amountWei)\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectBT(exchangeId, amountWei)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n    return estimateGas(account, fixedRate.methods.collectDT, exchangeId, amountWei)\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectDT(exchangeId, amountWei)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.collectMarketFee, exchangeId)\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectMarketFee,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectMarketFee(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.collectMarketFee, exchangeId)\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectOceanFee,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectOceanFee(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.fixedRateContract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.fixedRateContract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.updateMarketFee,\n      exchangeId,\n      newMarketFee\n    )\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  ConfigHelper,\n  estimateGas,\n  unitsToAmount,\n  setContractDefaults\n} from '../../utils'\nimport SideStakingTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json'\nimport { Config } from '../../models'\n\nexport class SideStaking {\n  public ssAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    ssAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (ssAbi) this.ssAbi = ssAbi\n    else this.ssAbi = SideStakingTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  private sideStakingContract(ssAddress: string) {\n    return setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get (total vesting amount + token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods\n        .getDatatokenCirculatingSupply(datatokenAddress)\n        .call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result.toString()\n  }\n\n  /**\n   * Get actual dts in circulation (vested token withdrawn from the contract +\n         token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCurrentCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    try {\n      const sideStaking = setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi, ssAddress),\n        this.config\n      )\n      let result = null\n      result = await sideStaking.methods\n        .getDatatokenCurrentCirculatingSupply(datatokenAddress)\n        .call()\n      return result.toString()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n  }\n\n  /**\n   * Get Publisher address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getPublisherAddress(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPublisherAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseToken(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Pool Address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getPoolAddress(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPoolAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get baseToken balance in the contract\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseTokenBalance(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get dt balance in the staking contract available for being added as liquidity\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getDatatokenBalance(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getDatatokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get block when vesting ends\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String} end block for vesting amount\n   */\n  async getvestingEndBlock(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingEndBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total amount vesting\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmount(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = new this.web3.eth.Contract(this.ssAbi, ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmount(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get last block publisher got some vested tokens\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingLastBlock(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingLastBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get how much has been taken from the vesting amount\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmountSoFar(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmountSoFar(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estGetVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    return estimateGas(account, sideStaking.methods.getVesting, datatokenAddress)\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async getVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await estimateGas(\n      account,\n      sideStaking.methods.getVesting,\n      datatokenAddress\n    )\n\n    try {\n      result = await sideStaking.methods.getVesting(datatokenAddress).send({\n        from: account,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    return estimateGas(\n      account,\n      sideStaking.methods.setPoolSwapFee,\n      datatokenAddress,\n      poolAddress,\n      swapFee\n    )\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async setPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await estimateGas(\n      account,\n      sideStaking.methods.setPoolSwapFee,\n      datatokenAddress,\n      poolAddress,\n      swapFee\n    )\n\n    try {\n      result = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in side staking contract\n   * @param {String} ssAddress side staking contract address\n   * @return {String}\n   */\n  async getRouter(ssAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { getFairGasPrice, setContractDefaults, ConfigHelper, estimateGas } from '../utils'\nimport { Operation } from '../@types/Router'\nimport { Config } from '../models/index.js'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router {\n  public routerAddress: string\n  public RouterAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public router: Contract\n\n  /**\n   * Instantiate Router.\n   * @param {String} routerAddress\n   * @param {AbiItem | AbiItem[]} Router\n   * @param {Web3} web3\n   */\n  constructor(\n    routerAddress: string,\n    web3: Web3,\n    network?: string | number,\n    RouterAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.routerAddress = routerAddress\n    this.RouterAbi = RouterAbi || (defaultRouter.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.router = setContractDefaults(\n      new this.web3.eth.Contract(this.RouterAbi, this.routerAddress),\n      this.config\n    )\n  }\n\n  /**\n   * Estimate gas cost for buyDTBatch method\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async estGasBuyDTBatch(address: string, operations: Operation[]): Promise<any> {\n    return estimateGas(address, this.router.methods.buyDTBatch, operations)\n  }\n\n  /**\n   * BuyDTBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async buyDTBatch(\n    address: string,\n    operations: Operation[]\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(address, this.router.methods.buyDTBatch, operations)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.buyDTBatch(operations).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.router.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a side staking contract.\n   * @return {Promise<boolean>} true if is a SS contract\n   */\n  public async isSideStaking(address: string): Promise<boolean> {\n    return await this.router.methods.isSSContract(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.router.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.router.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.router.methods.factory().call()\n  }\n\n  /** Check if an address is a pool template contract.\n   * @return {Promise<boolean>} true if is a Template\n   */\n  public async isPoolTemplate(address: string): Promise<boolean> {\n    return await this.router.methods.isPoolTemplate(address).call()\n  }\n\n  /**\n   * Estimate gas cost for addApprovedToken\n   * @param {String} address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addApprovedToken, tokenAddress)\n  }\n\n  /**\n   * Add a new token to oceanTokens list, pools with baseToken in this list have NO opf Fee\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addApprovedToken,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeApprovedToken\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeApprovedToken, tokenAddress)\n  }\n\n  /**\n   * Remove a token from oceanTokens list, pools without baseToken in this list have a opf Fee\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeApprovedToken,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addSSContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddSSContract(address: string, tokenAddress: string): Promise<any> {\n    return estimateGas(address, this.router.methods.addSSContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to ssContract list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addSSContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeSSContract method\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeSSContract, tokenAddress)\n  }\n\n  /**\n   * Removes a new contract from ssContract list\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to removed\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeSSContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addFixedRateContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addFixedRateContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addFixedRateContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeFixedRateContract, tokenAddress)\n  }\n\n  /**\n   * Removes a contract from fixedRate list\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeFixedRateContract,\n      tokenAddress\n    )\n\n    // Invoke removeFixedRateContract function of the contract\n    const trxReceipt = await this.router.methods\n      .removeFixedRateContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addDispenserContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addDispenserContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addDispenserContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeDispenserContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeDispenserContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removeDispenserContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.router.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.router.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Estimate gas cost for updateOPFFee method\n   * @param {String} address\n   * @param {String} newFee new OPF Fee\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasUpdateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.router.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async updateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addPoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addPoolTemplate, templateAddress)\n  }\n\n  /**\n   * Add a new template to poolTemplates mapping, after template is added,it can be used\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addPoolTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addPoolTemplate(templateAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removePoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemovePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removePoolTemplate, templateAddress)\n  }\n\n  /**\n   * Remove template from poolTemplates mapping, after template is removed,it can be used anymore\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removePoolTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removePoolTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  estimateGas,\n  ConfigHelper\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    nftAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addManager, manager)\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.addManager, manager)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(address, nftContract.methods.removeManager, manager)\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.removeManager, manager)\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(address, nftContract.methods.addToCreateERC20List, erc20Deployer)\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addToCreateERC20List,\n      erc20Deployer\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      erc20Deployer\n    )\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      erc20Deployer\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addToMetadataList, metadataUpdater)\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addTo725StoreList, storeUpdater)\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.removeFrom725StoreList, storeUpdater)\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.cleanPermissions)\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.cleanPermissions)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenId\n    )\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await estimateGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenId\n    )\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await estimateGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    return estimateGas(address, nftContract.methods.setTokenURI, '1', data)\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(address, nftContract.methods.setTokenURI, '1', data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param key Key of the data to be stored into 725Y standard\n   * @param value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const keyHash = this.web3.utils.keccak256(key)\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    // Call setData function of the contract\n    const trxReceipt = await nftContract.methods.setNewData(keyHash, valueHex).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const keyHash = this.web3.utils.keccak256(key)\n    const data = await nftContract.methods.getData(keyHash).call()\n    return data ? this.web3.utils.hexToAscii(data) : null\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  getFreOrderParams,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper,\n  allowance\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.mint,\n      toAddress || address,\n      this.web3.utils.toWei(amount)\n    )\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    return estimateGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        address,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    return estimateGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.addMinter, minter)\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await estimateGas(address, dtContract.methods.addMinter, minter)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    return estimateGas(address, dtContract.methods.removeMinter, minter)\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(address, dtContract.methods.removeMinter, minter)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.addPaymentManager, paymentManager)\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.removePaymentManager, paymentManager)\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.setPaymentCollector, paymentCollector)\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager = (await this.getDTPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.transfer, toAddress, amount)\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.transfer,\n        toAddress,\n        amount\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.startOrder,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for reuseOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasReuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.reuseOrder, orderTxId, providerFees)\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async reuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.reuseOrder,\n        orderTxId,\n        providerFees\n      )\n\n      const trxReceipt = await dtContract.methods\n        .reuseOrder(orderTxId, providerFees)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to call reuse order order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    return estimateGas(\n      address,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freParams\n    )\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const freContractParams = await getFreOrderParams(this.web3, freParams)\n\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.buyFromFreAndOrder,\n        orderParams,\n        freContractParams\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    return estimateGas(\n      address,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.buyFromDispenserAndOrder,\n        orderParams,\n        dispenserContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.setData, value)\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await estimateGas(address, dtContract.methods.setData, valueHex)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(valueHex).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.cleanPermissions)\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(address, dtContract.methods.cleanPermissions)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n        from: address\n      }),\n      this.config\n    )\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n\n  /**\n   * @dev estGasSetPublishingMarketFee\n   *      Estimating gas for publishMarketFeeAddress method\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async estGasSetPublishingMarketFee(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string\n  ): Promise<number> {\n    // Estimate gas cost for publishMarketFeeAddress method\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    return estimateGas(\n      address,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n  }\n\n  /**\n   * @dev setPublishingMarketFee\n   *      Only publishMarketFeeAddress can call it\n   *      This function allows to set the fee required by the publisherMarket\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async setPublishingMarketFee(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string\n  ) {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    const mktFeeAddress = (await dtContract.methods.getPublishingMarketFee().call())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await this.estGasSetPublishingMarketFee(\n      datatokenAddress,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount,\n      address\n    )\n    await dtContract.methods\n      .setPublishingMarketFee(\n        publishMarketFeeAddress,\n        publishMarketFeeToken,\n        publishMarketFeeAmount\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n  }\n\n  /**\n   * @dev getPublishingMarketFee\n   *      Get publishingMarket Fee\n   *      This function allows to get the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string,\n    address: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n\n    const publishingMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2]\n    }\n    return returnValues\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  setContractDefaults,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    network?: string | number,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    return estimateGas(\n      address,\n      this.factory721.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        ZERO_ADDRESS,\n        ZERO_ADDRESS,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.add721TokenTemplate,\n      templateAddress\n    )\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.add721TokenTemplate,\n      templateAddress\n    )\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.disable721TokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.disable721TokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.factory721.methods.addTokenTemplate, templateAddress)\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.addTokenTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.disableTokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.disableTokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    return estimateGas(address, this.factory721.methods.startMultipleTokenOrder, orders)\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.startMultipleTokenOrder,\n      orders\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithPool,\n      nftCreateData,\n      ercCreateData,\n      poolData\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithPool,\n      nftCreateData,\n      ercCreateData,\n      poolData\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    console.log('createNftErc20WithFixedRate estGas + 1', estGas + 1)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class ContractConfig {\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  public transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  public transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  public transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  public gasFeeMultiplier: number\n}\n\nexport class Config extends ContractConfig {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n}\n\nexport default Config\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData } from '../utils'\nimport {\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport fetch from 'cross-fetch'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @param {boolean} checksum if true, will return checksum of files content\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @param {boolean} checksum if true, will return checksum of files content\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    headers?: any,\n    checksum: boolean = false\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url', checksum, headers }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Initialize a compute request.\n   * @param {ComputeAsset} assets\n   * @param {ComputeAlgorithmber} algorithm\n   * @param {string} computeEnv\n   * @param {number} validUntil\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {string} accountId\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm: algorithm,\n      compute: {\n        env: computeEnv,\n        validUntil: validUntil\n      },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute start failed: ', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n"],"names":["LogLevel","Logger","constructor","logLevel","Error","this","setLevel","bypass","args","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","ZERO_ADDRESS","GASLIMIT_DEFAULT","setContractDefaults","contract","config","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getFairGasPrice","web3","x","BigNumber","eth","getGasPrice","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","toString","getErcCreationParams","ercParams","templateIndex","strings","addresses","minter","paymentCollector","mpFeeAddress","feeToken","uints","Web3","utils","toWei","cap","feeAmount","bytess","getFreOrderParams","freParams","exchangeContract","exchangeId","maxBaseTokenAmount","amountToUnits","baseTokenAddress","baseTokenDecimals","swapMarketFee","marketFeeAddress","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","owner","marketFeeCollector","datatokenDecimals","fixedRate","marketFee","getPoolCreationParams","poolParams","ssContract","baseTokenSender","publisherAddress","poolTemplateAddress","ssParams","rate","vestingAmount","vestedBlocks","initialBaseTokenLiquidity","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","unitsToAmount","token","amount","tokenDecimals","tokenContract","Contract","decimals","methods","call","amountFormatted","div","exponentiatedBy","EXPONENTIAL_AT","e","message","times","toFixed","estimateGas","from","functionToEstimateGas","estimatedGas","apply","err","estGas","fetchData","url","opts","result","fetch","ok","method","text","downloadFileBrowser","fileName","headers","get","split","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","response","a","document","createElement","href","setAttribute","body","appendChild","click","remove","revokeObjectURL","send","downloadFile","index","filename","match","pop","data","arrayBuffer","getData","postData","payload","async","postWithHeaders","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","FixedPrice","Dispenser","Staking","poolTemplate","ERC721Factory","OPFCommunityFeeCollector","Ocean","erc721FactoryAddress","sideStakingAddress","opfCommunityFeeCollector","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","CustomContractAddressess","generateDid","erc721Address","toChecksumAddress","sha256","getHash","signHash","address","signedMessage","sign","substr","r","slice","s","v","estApprove","account","tokenAddress","spender","contractInstance","approve","force","currentAllowance","allowance","Decimal","greaterThanOrEqualTo","gas","gasPrice","approveWei","currentAllowence","allowanceWei","gt","estTransfer","recipient","transfer","trxReceipt","balance","balanceOf","sleep","ms","Promise","resolve","setTimeout","calcMaxExactOut","calcMaxExactIn","getMaxSwapExactOut","poolInstance","poolAddress","getReserve","getMaxSwapExactIn","getMaxAddLiquidity","getMaxRemoveLiquidity","Aquarius","aquariusURL","did","signal","path","json","status","txid","tries","ddo","event","valid","jsonResponse","JSON","stringify","hash","proof","validatorAddress","publicKey","errors","statusText","query","MaxUint256","Pool","poolAbi","PoolTemplate","abi","fromWei","fee","defaultErc20Abi","setSwapFee","pool","getNumTokens","totalSupply","getCurrentTokens","getFinalTokens","getController","getBaseTokenAddress","getDatatokenAddress","getMarketFee","_publishMarketCollector","isBound","getBalance","isFinalized","getSwapFee","weight","getNormalizedWeight","getDenormalizedWeight","getTotalDenormalizedWeight","publishMarketFees","getCurrentOPCFees","communityFees","collectOPC","collectMarketFee","getMarketFeeCollector","newPublishMarketAddress","newPublishMarketSwapFee","updatePublishMarketFee","tokenInOutMarket","amountsInOutMaxFee","poolContract","tokenAmountIn","tokenIn","tokenInDecimals","minAmountOut","tokenOut","tokenOutDecimals","maxPrice","getBaseToken","swapExactAmountIn","maxSwap","greaterThan","maxAmountIn","tokenAmountOut","swapExactAmountOut","minPoolAmountOut","joinswapExternAmountIn","amountInFormatted","poolAmountIn","minTokenAmountOut","exitswapPoolAmountIn","poolDecimals","calcSingleOutGivenPoolIn","minTokenOutFormatted","decimalsTokenIn","decimalsTokenOut","tokenInContract","tokenOutContract","decimalsDiff","price","getSpotPrice","amountOutFormatted","getAmountInExactOut","tokenAmount","liquidityProviderSwapFeeAmount","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","getAmountOutExactIn","calcPoolOutSingleIn","poolAmountOut","calcSingleInPoolOut","calcSingleOutPoolIn","calcPoolInSingleOut","getSwapEventSignature","eventdata","encodeEventSignature","getJoinEventSignature","getExitEventSignature","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","maxTokens","maxBalance","logger","dtAddress","allowedSwapper","create","activate","deactivate","newAllowedSwapper","setAllowedSwapper","destination","dispense","ownerWithdraw","datatoken","active","String","isMinter","FixedRateCreateProgressStep","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","baseToken","generateExchangeId","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","exchange","getExchange","consumeMarketFeeFormatted","dtAmountFormatted","dtDecimals","maxBtFormatted","btDecimals","sellDT","minBaseTokenAmount","minBtFormatted","getNumberOfExchanges","newRate","setRate","toggleExchangeState","weiRate","getRate","dtSupply","getDTSupply","btSupply","getBTSupply","getAllowedSwapper","fixedRateExchange","calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","calcBaseOutGivenInDT","dtBalance","btBalance","getFeesInfo","opcFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","toggleMintState","fixedrate","amountWei","collectBT","collectDT","collectOceanFee","opcCollector","router","exchangeOwner","newMarketFee","updateMarketFee","newMarketFeeCollector","updateMarketFeeCollector","SideStaking","SideStakingTemplate","sideStakingContract","ssAddress","sideStaking","getDatatokenCirculatingSupply","getDatatokenCurrentCirculatingSupply","getPublisherAddress","getPoolAddress","getBaseTokenBalance","getDatatokenBalance","getvestingEndBlock","getvestingAmount","getvestingLastBlock","getvestingAmountSoFar","getVesting","swapFee","setPoolSwapFee","Router","routerAddress","RouterAbi","defaultRouter","operations","buyDTBatch","isApprovedToken","isSSContract","isFixedRateContract","routerOwner","factory","isPoolTemplate","addApprovedToken","getOwner","removeApprovedToken","addSSContract","removeSSContract","addFixedRateContract","removeFixedRateContract","addDispenserContract","removeDispenserContract","getOPCFee","swapOceanFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","templateAddress","addPoolTemplate","removePoolTemplate","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","nftAddress","createERC20","getNftPermissions","deployERC20","nftContract","events","TokenCreated","returnValues","manager","addManager","getNftOwner","removeManager","erc20Deployer","addToCreateERC20List","removeFromCreateERC20List","metadataUpdater","addToMetadataList","removeFromMetadataList","updateMetadata","esGasRemoveMetadataUpdater","storeUpdater","addTo725StoreList","removeFrom725StoreList","store","cleanPermissions","nftOwner","nftReceiver","tokenId","transferFrom","tokenIdentifier","safeTransferFrom","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetaDataState","setTokenURI","key","value","keyHash","keccak256","valueHex","asciiToHex","setNewData","ownerOf","getPermissions","getMetaData","isERC20Deployer","hexToAscii","id","tokenURI","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","dtContract","toAddress","mint","fixedRateParams","createFixedRate","dispenserParams","createDispenser","getDTPermissions","capAvailble","getCap","gte","addMinter","removeMinter","paymentManager","addPaymentManager","removePaymentManager","setPaymentCollector","isPaymentManager","getNFTAddress","isNftOwner","nftPermissions","getPaymentCollector","weiAmount","transferWei","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","publishMarketFee","getPublishingMarketFee","tokens","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","push","getCurrentAllownceTokens","_this","all","orderTxId","reuseOrder","orderParams","buyFromFreAndOrder","freContractParams","buyFromDispenserAndOrder","setData","permissions","getERC721Address","publishMarketFeeAddress","publishMarketFeeToken","publishMarketFeeAmount","setPublishingMarketFee","estGasSetPublishingMarketFee","publishingMarketFee","NftFactory","factory721","defaultFactory721Abi","nftData","deployERC721Contract","transferable","getCurrentNFTTemplateCount","getNFTTemplate","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTemplateCount","getTokenTemplate","erc20List","erc721List","add721TokenTemplate","disable721TokenTemplate","reactivate721TokenTemplate","addTokenTemplate","disableTokenTemplate","getCurrentTokenTemplateCount","reactivateTokenTemplate","orders","startMultipleTokenOrder","nftCreateData","ercCreateData","createNftWithErc20","poolData","createNftWithErc20WithPool","fixedData","createNftWithErc20WithFixedRate","createNftWithErc20WithDispenser","ContractConfig","Config","providerAddress","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","noZeroX","input","zeroOutput","output","regexp","conversorName","inputMatch","zeroXTransformer","Provider","endpoints","getEndpointURL","servicesEndpoints","serviceName","providerEndpoint","serviceEndpoints","i","urlPath","consumerAddress","providerEndpoints","getEndpoints","getServiceEndpoints","nonce","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","serviceId","withChecksum","checksum","files","results","_this$getEndpointURL","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","assets","algorithm","providerData","datasets","compute","transferTxId","downloadUrl","Date","now","consumeUrl","signProviderRequest","dataset","additionalDatasets","computeStartUrl","signatureMessage","documentId","signature","Object","environment","jobId","computeStopUrl","getNonce","computeStatusUrl","computeResultUrl","resultUrl","computeDeleteUrl","params","ProviderInstance"],"mappings":"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"}