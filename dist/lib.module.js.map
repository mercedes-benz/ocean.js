{"version":3,"file":"lib.module.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/pools/ssContracts/SideStaking.ts","../src/pools/Router.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/models/Config.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { ContractConfig } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { GASLIMIT_DEFAULT, ZERO_ADDRESS } from './Constants'\n\nexport function setContractDefaults(\n  contract: Contract,\n  config: ContractConfig\n): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  config: ContractConfig\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport async function getFreOrderParams(\n  web3: Web3,\n  freParams: FreOrderParams\n): Promise<any> {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: await amountToUnits(\n      web3,\n      freParams.baseTokenAddress,\n      freParams.maxBaseTokenAmount,\n      freParams.baseTokenDecimals\n    ),\n    swapMarketFee: await amountToUnits(\n      web3,\n      freParams.baseTokenAddress,\n      freParams.swapMarketFee,\n      freParams.baseTokenDecimals\n    ),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\n\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n    return amountFormatted.toFixed(0)\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n\n/**\n * Estimates the gas used when a function would be executed on chain\n * @param {string} from account that calls the function\n * @param {Function} functionToEstimateGas function that we need to estimate the gas\n * @param {...any[]} args arguments of the function\n * @return {Promise<number>} gas cost of the function\n */\nexport async function estimateGas(\n  from: string,\n  functionToEstimateGas: Function,\n  ...args: any[]\n): Promise<any> {\n  let estimatedGas = GASLIMIT_DEFAULT\n  try {\n    estimatedGas = await functionToEstimateGas.apply(null, args).estimateGas(\n      {\n        from: from\n      },\n      (err, estGas) => (err ? GASLIMIT_DEFAULT : estGas)\n    )\n  } catch (e) {\n    LoggerInstance.error(`ERROR: Estimate gas failed!`, e)\n  }\n  return estimatedGas\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader.split('=')[1]\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n// eslint-disable-next-line import/no-named-default\nimport { default as CustomContractAddressess } from '../../address.json'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000',\n    providerUri: 'http://172.15.0.4:8030'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io/',\n    oceanTokenSymbol: 'OCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 81001,\n    network: 'polygonedge',\n    nodeUri: 'https://rpc-edgenet.polygon.technology',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://explorer-edgenet.polygon.technology/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n    LoggerInstance.log('oceanjs network: ', network)\n    LoggerInstance.log('oceanjs customAddresses: ', customAddresses)\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        LoggerInstance.log(\n          'oceanjs customAddresses polyognedge: ',\n          customAddresses[network]\n        )\n        LoggerInstance.log(\n          'oceanjs customAddresses attr polyognedge: ',\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        )\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    LoggerInstance.log('network : ', filterBy, network)\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n    LoggerInstance.log('network config : ', config)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(\n      config.network,\n      CustomContractAddressess\n    )\n    config = { ...config, ...contractAddressesConfig }\n    LoggerInstance.log('oceanjs contractAddressesConfig : ', contractAddressesConfig)\n    LoggerInstance.log('oceanjs final config : ', config)\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  amountToUnits,\n  estimateGas,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { Config, ContractConfig } from '../models'\nimport BigNumber from 'bignumber.js'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  return estimateGas(account, tokenContract.methods.approve, spender, amount)\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<TransactionReceipt | string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  if (!force) {\n    const currentAllowance = await allowance(\n      web3,\n      tokenAddress,\n      account,\n      spender,\n      tokenDecimals,\n      config\n    )\n    if (new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowance\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, config)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function approveWei(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowanceWei(web3, tokenAddress, account, spender)\n    if (new BigNumber(currentAllowence).gt(new BigNumber(amount))) {\n      return currentAllowence\n    }\n  }\n  let result = null\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amount\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amount).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n/**\n * Estimate gas cost for transfer function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estTransfer(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  return estimateGas(account, tokenContract.methods.transfer, recipient, amount)\n}\n\n/**\n * Moves amount tokens from the caller’s account to recipient.\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount amount of ERC20 tokens (not as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function transfer(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string\n): Promise<TransactionReceipt | string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await estimateGas(\n    account,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n\n  try {\n    result = await tokenContract.methods.transfer(recipient, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, null)\n    })\n  } catch (e) {\n    LoggerInstance.error(`ERROR: Failed to transfer tokens : ${e.message}`)\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowanceWei(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.allowance(account, spender).call()\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number,\n  config?: Config\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get decimals for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(web3: Web3, tokenAddress: string): Promise<number> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.decimals().call()\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(2)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance,\n  estimateGas,\n  ConfigHelper\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  private config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    poolAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(account, poolContract.methods.setSwapFee, fee)\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(account, pool.methods.setSwapFee, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getReserve(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getMarketFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getCommunityFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(address, poolContract.methods.collectOPC)\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(address, pool.methods.collectOPC)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(address, poolContract.methods.collectMarketFee)\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await estimateGas(address, pool.methods.collectMarketFee)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.updatePublishMarketFee,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await estimateGas(\n      address,\n      pool.methods.updatePublishMarketFee,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    return estimateGas(\n      address,\n      poolContract.methods.swapExactAmountIn,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        tokenAmountIn,\n        minAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const estGas = await estimateGas(\n      address,\n      pool.methods.swapExactAmountIn,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        tokenAmountIn,\n        minAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n\n    let result = null\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    return estimateGas(\n      address,\n      poolContract.methods.swapExactAmountOut,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        maxAmountIn,\n        tokenAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenOut)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const estGas = await estimateGas(\n      account,\n      pool.methods.swapExactAmountOut,\n      [\n        tokenInOutMarket.tokenIn,\n        tokenInOutMarket.tokenOut,\n        tokenInOutMarket.marketFeeAddress\n      ],\n      [\n        maxAmountIn,\n        tokenAmountOut,\n        maxPrice,\n        this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n      ]\n    )\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.joinswapExternAmountIn,\n      tokenAmountIn,\n      minPoolAmountOut\n    )\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    tokenInDecimals?: number\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(\n      tokenIn,\n      tokenAmountIn,\n      tokenInDecimals\n    )\n    const estGas = await estimateGas(\n      account,\n      pool.methods.joinswapExternAmountIn,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      poolContract.methods.exitswapPoolAmountIn,\n      poolAmountIn,\n      minTokenAmountOut\n    )\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {number} poolDecimals optional number of decimals of the poool\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    poolDecimals?: number\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await this.amountToUnits(\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut,\n      poolDecimals\n    )\n    const estGas = await estimateGas(\n      account,\n      pool.methods.exitswapPoolAmountIn,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenOut)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await this.amountToUnits(\n      tokenOut,\n      tokenAmountOut,\n      tokenOutDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountIn,\n          tokenInDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountIn exact amount of tokenIn\n   * @param swapMarketFee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(\n      tokenIn,\n      tokenAmountIn,\n      tokenInDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountOut,\n          tokenOutDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   * @param {number} poolDecimals optional number of decimals of the poool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await this.amountToUnits(tokenIn, tokenAmountIn, tokenInDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await this.amountToUnits(\n      poolAddress,\n      poolAmountOut,\n      poolDecimals\n    )\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n        .call()\n\n      amount = await this.unitsToAmount(tokenIn, result, tokenInDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await this.amountToUnits(poolAddress, poolAmountIn, poolDecimals)\n        )\n        .call()\n      amount = await this.unitsToAmount(tokenOut, result, tokenOutDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await this.amountToUnits(tokenOut, tokenAmountOut, tokenOutDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_SWAP'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_JOIN'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(\n      ({ name, type }) => type === 'event' && name === 'LOG_EXIT'\n    )\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  setContractDefaults,\n  estimateGas,\n  ConfigHelper\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.activate,\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance)\n      )\n\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    return estimateGas(address, this.dispenserContract.methods.deactivate, dtAddress)\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.deactivate,\n        dtAddress\n      )\n\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await estimateGas(\n        address,\n        this.dispenserContract.methods.setAllowedSwapper,\n        dtAddress,\n        newAllowedSwapper\n      )\n\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.dispenserContract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    return estimateGas(address, this.dispenserContract.methods.ownerWithdraw, dtAddress)\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.dispenserContract.methods.ownerWithdraw,\n      dtAddress\n    )\n\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public fixedRateContract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    network?: string | number,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    this.fixedRateContract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.fixedRateContract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.buyDT,\n      datatokenAddress,\n      dtAmount,\n      maxBaseTokenAmount,\n      consumeMarketAddress,\n      consumeMarketFee\n    )\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.fixedRateContract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.sellDT,\n      datatokenAddress,\n      dtAmount,\n      maxBaseTokenAmount,\n      consumeMarketAddress,\n      consumeMarketFee\n    )\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.fixedRateContract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.fixedRateContract.methods\n      .getNumberOfExchanges()\n      .call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.setRate,\n      exchangeId,\n      await this.web3.utils.toWei(newRate)\n    )\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleExchangeState, exchangeId)\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleExchangeState,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleExchangeState(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleExchangeState, exchangeId)\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleExchangeState,\n      exchangeId\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleExchangeState(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.fixedRateContract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.fixedRateContract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.fixedRateContract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.fixedRateContract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const result = await this.fixedRateContract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.fixedRateContract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, result[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(\n      result.datatoken,\n      result.dtBalance,\n      +result.dtDecimals\n    )\n    result.btBalance = await this.unitsToAmount(\n      result.baseToken,\n      result.btBalance,\n      +result.btDecimals\n    )\n    result.dtSupply = await this.unitsToAmount(\n      result.datatoken,\n      result.dtSupply,\n      +result.dtDecimals\n    )\n    result.btSupply = await this.unitsToAmount(\n      result.baseToken,\n      result.btSupply,\n      +result.btDecimals\n    )\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.fixedRateContract.methods\n      .getFeesInfo(exchangeId)\n      .call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    result.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.fixedRateContract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.fixedRateContract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.toggleMintState, exchangeId, true)\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.toggleMintState(exchangeId, false),\n      exchangeId,\n      false\n    )\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n    return estimateGas(account, fixedRate.methods.collectBT, exchangeId, amountWei)\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectBT(exchangeId, amountWei)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n    return estimateGas(account, fixedRate.methods.collectDT, exchangeId, amountWei)\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.fixedRateContract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectDT(exchangeId, amountWei)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.collectMarketFee, exchangeId)\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectMarketFee,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectMarketFee(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(account, fixedRate.methods.collectMarketFee, exchangeId)\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.collectOceanFee,\n      exchangeId\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .collectOceanFee(exchangeId)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.fixedRateContract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.fixedRateContract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.updateMarketFee,\n      exchangeId,\n      newMarketFee\n    )\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n\n    return estimateGas(\n      account,\n      fixedRate.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(\n      address,\n      this.fixedRateContract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.fixedRateContract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  ConfigHelper,\n  estimateGas,\n  unitsToAmount,\n  setContractDefaults\n} from '../../utils'\nimport SideStakingTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json'\nimport { Config } from '../../models'\n\nexport class SideStaking {\n  public ssAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    ssAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (ssAbi) this.ssAbi = ssAbi\n    else this.ssAbi = SideStakingTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  private sideStakingContract(ssAddress: string) {\n    return setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get (total vesting amount + token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods\n        .getDatatokenCirculatingSupply(datatokenAddress)\n        .call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result.toString()\n  }\n\n  /**\n   * Get actual dts in circulation (vested token withdrawn from the contract +\n         token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCurrentCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    try {\n      const sideStaking = setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi, ssAddress),\n        this.config\n      )\n      let result = null\n      result = await sideStaking.methods\n        .getDatatokenCurrentCirculatingSupply(datatokenAddress)\n        .call()\n      return result.toString()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n  }\n\n  /**\n   * Get Publisher address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getPublisherAddress(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPublisherAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseToken(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Pool Address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getPoolAddress(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPoolAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get baseToken balance in the contract\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseTokenBalance(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get dt balance in the staking contract available for being added as liquidity\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getDatatokenBalance(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getDatatokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get block when vesting ends\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String} end block for vesting amount\n   */\n  async getvestingEndBlock(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingEndBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total amount vesting\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmount(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = new this.web3.eth.Contract(this.ssAbi, ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmount(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get last block publisher got some vested tokens\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingLastBlock(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingLastBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get how much has been taken from the vesting amount\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmountSoFar(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmountSoFar(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estGetVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    return estimateGas(account, sideStaking.methods.getVesting, datatokenAddress)\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async getVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await estimateGas(\n      account,\n      sideStaking.methods.getVesting,\n      datatokenAddress\n    )\n\n    try {\n      result = await sideStaking.methods.getVesting(datatokenAddress).send({\n        from: account,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    return estimateGas(\n      account,\n      sideStaking.methods.setPoolSwapFee,\n      datatokenAddress,\n      poolAddress,\n      swapFee\n    )\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async setPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await estimateGas(\n      account,\n      sideStaking.methods.setPoolSwapFee,\n      datatokenAddress,\n      poolAddress,\n      swapFee\n    )\n\n    try {\n      result = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in side staking contract\n   * @param {String} ssAddress side staking contract address\n   * @return {String}\n   */\n  async getRouter(ssAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { getFairGasPrice, setContractDefaults, ConfigHelper, estimateGas } from '../utils'\nimport { Operation } from '../@types/Router'\nimport { Config } from '../models/index.js'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router {\n  public routerAddress: string\n  public RouterAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public router: Contract\n\n  /**\n   * Instantiate Router.\n   * @param {String} routerAddress\n   * @param {AbiItem | AbiItem[]} Router\n   * @param {Web3} web3\n   */\n  constructor(\n    routerAddress: string,\n    web3: Web3,\n    network?: string | number,\n    RouterAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.routerAddress = routerAddress\n    this.RouterAbi = RouterAbi || (defaultRouter.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.router = setContractDefaults(\n      new this.web3.eth.Contract(this.RouterAbi, this.routerAddress),\n      this.config\n    )\n  }\n\n  /**\n   * Estimate gas cost for buyDTBatch method\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async estGasBuyDTBatch(address: string, operations: Operation[]): Promise<any> {\n    return estimateGas(address, this.router.methods.buyDTBatch, operations)\n  }\n\n  /**\n   * BuyDTBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async buyDTBatch(\n    address: string,\n    operations: Operation[]\n  ): Promise<TransactionReceipt> {\n    const estGas = await estimateGas(address, this.router.methods.buyDTBatch, operations)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.buyDTBatch(operations).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.router.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a side staking contract.\n   * @return {Promise<boolean>} true if is a SS contract\n   */\n  public async isSideStaking(address: string): Promise<boolean> {\n    return await this.router.methods.isSSContract(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.router.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.router.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.router.methods.factory().call()\n  }\n\n  /** Check if an address is a pool template contract.\n   * @return {Promise<boolean>} true if is a Template\n   */\n  public async isPoolTemplate(address: string): Promise<boolean> {\n    return await this.router.methods.isPoolTemplate(address).call()\n  }\n\n  /**\n   * Estimate gas cost for addApprovedToken\n   * @param {String} address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addApprovedToken, tokenAddress)\n  }\n\n  /**\n   * Add a new token to oceanTokens list, pools with baseToken in this list have NO opf Fee\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addApprovedToken,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeApprovedToken\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeApprovedToken, tokenAddress)\n  }\n\n  /**\n   * Remove a token from oceanTokens list, pools without baseToken in this list have a opf Fee\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeApprovedToken,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addSSContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddSSContract(address: string, tokenAddress: string): Promise<any> {\n    return estimateGas(address, this.router.methods.addSSContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to ssContract list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addSSContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeSSContract method\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeSSContract, tokenAddress)\n  }\n\n  /**\n   * Removes a new contract from ssContract list\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to removed\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeSSContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addFixedRateContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addFixedRateContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addFixedRateContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeFixedRateContract, tokenAddress)\n  }\n\n  /**\n   * Removes a contract from fixedRate list\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeFixedRateContract,\n      tokenAddress\n    )\n\n    // Invoke removeFixedRateContract function of the contract\n    const trxReceipt = await this.router.methods\n      .removeFixedRateContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addDispenserContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addDispenserContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addDispenserContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removeDispenserContract, tokenAddress)\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removeDispenserContract,\n      tokenAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removeDispenserContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.router.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.router.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Estimate gas cost for updateOPFFee method\n   * @param {String} address\n   * @param {String} newFee new OPF Fee\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasUpdateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.router.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async updateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addPoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.addPoolTemplate, templateAddress)\n  }\n\n  /**\n   * Add a new template to poolTemplates mapping, after template is added,it can be used\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.addPoolTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addPoolTemplate(templateAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removePoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemovePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.router.methods.removePoolTemplate, templateAddress)\n  }\n\n  /**\n   * Remove template from poolTemplates mapping, after template is removed,it can be used anymore\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.router.methods.removePoolTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removePoolTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  estimateGas,\n  ConfigHelper\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    nftAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addManager, manager)\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.addManager, manager)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(address, nftContract.methods.removeManager, manager)\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.removeManager, manager)\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    return estimateGas(address, nftContract.methods.addToCreateERC20List, erc20Deployer)\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addToCreateERC20List,\n      erc20Deployer\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      erc20Deployer\n    )\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      erc20Deployer\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addToMetadataList, metadataUpdater)\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.addTo725StoreList, storeUpdater)\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.removeFrom725StoreList, storeUpdater)\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(address, nftContract.methods.cleanPermissions)\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await estimateGas(address, nftContract.methods.cleanPermissions)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenId\n    )\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await estimateGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenId\n    )\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await estimateGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    return estimateGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    return estimateGas(address, nftContract.methods.setTokenURI, '1', data)\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(address, nftContract.methods.setTokenURI, '1', data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param key Key of the data to be stored into 725Y standard\n   * @param value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const keyHash = this.web3.utils.keccak256(key)\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await estimateGas(\n      address,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    // Call setData function of the contract\n    const trxReceipt = await nftContract.methods.setNewData(keyHash, valueHex).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const keyHash = this.web3.utils.keccak256(key)\n    const data = await nftContract.methods.getData(keyHash).call()\n    return data ? this.web3.utils.hexToAscii(data) : null\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  getFreOrderParams,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper,\n  allowance\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.mint,\n      toAddress || address,\n      this.web3.utils.toWei(amount)\n    )\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    return estimateGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        address,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    return estimateGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.addMinter, minter)\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await estimateGas(address, dtContract.methods.addMinter, minter)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    return estimateGas(address, dtContract.methods.removeMinter, minter)\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(address, dtContract.methods.removeMinter, minter)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.addPaymentManager, paymentManager)\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.removePaymentManager, paymentManager)\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.setPaymentCollector, paymentCollector)\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager = (await this.getDTPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.transfer, toAddress, amount)\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.transfer,\n        toAddress,\n        amount\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(\n      address,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.startOrder,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for reuseOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasReuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.reuseOrder, orderTxId, providerFees)\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async reuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.reuseOrder,\n        orderTxId,\n        providerFees\n      )\n\n      const trxReceipt = await dtContract.methods\n        .reuseOrder(orderTxId, providerFees)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to call reuse order order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    return estimateGas(\n      address,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freParams\n    )\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const freContractParams = await getFreOrderParams(this.web3, freParams)\n\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.buyFromFreAndOrder,\n        orderParams,\n        freContractParams\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    return estimateGas(\n      address,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await estimateGas(\n        address,\n        dtContract.methods.buyFromDispenserAndOrder,\n        orderParams,\n        dispenserContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.setData, value)\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await estimateGas(address, dtContract.methods.setData, valueHex)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(valueHex).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    return estimateGas(address, dtContract.methods.cleanPermissions)\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await estimateGas(address, dtContract.methods.cleanPermissions)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n        from: address\n      }),\n      this.config\n    )\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n\n  /**\n   * @dev estGasSetPublishingMarketFee\n   *      Estimating gas for publishMarketFeeAddress method\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async estGasSetPublishingMarketFee(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string\n  ): Promise<number> {\n    // Estimate gas cost for publishMarketFeeAddress method\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    return estimateGas(\n      address,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n  }\n\n  /**\n   * @dev setPublishingMarketFee\n   *      Only publishMarketFeeAddress can call it\n   *      This function allows to set the fee required by the publisherMarket\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async setPublishingMarketFee(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string\n  ) {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n    const mktFeeAddress = (await dtContract.methods.getPublishingMarketFee().call())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await this.estGasSetPublishingMarketFee(\n      datatokenAddress,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount,\n      address\n    )\n    await dtContract.methods\n      .setPublishingMarketFee(\n        publishMarketFeeAddress,\n        publishMarketFeeToken,\n        publishMarketFeeAmount\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n  }\n\n  /**\n   * @dev getPublishingMarketFee\n   *      Get publishingMarket Fee\n   *      This function allows to get the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string,\n    address: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n      from: address\n    })\n\n    const publishingMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2]\n    }\n    return returnValues\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  setContractDefaults,\n  estimateGas,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    network?: string | number,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    return estimateGas(\n      address,\n      this.factory721.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        ZERO_ADDRESS,\n        ZERO_ADDRESS,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.add721TokenTemplate,\n      templateAddress\n    )\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.add721TokenTemplate,\n      templateAddress\n    )\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.disable721TokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.disable721TokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    return estimateGas(address, this.factory721.methods.addTokenTemplate, templateAddress)\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.addTokenTemplate,\n      templateAddress\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.disableTokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.disableTokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    return estimateGas(\n      address,\n      this.factory721.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    return estimateGas(address, this.factory721.methods.startMultipleTokenOrder, orders)\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.startMultipleTokenOrder,\n      orders\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithPool,\n      nftCreateData,\n      ercCreateData,\n      poolData\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithPool,\n      nftCreateData,\n      ercCreateData,\n      poolData\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    console.log('createNftErc20WithFixedRate estGas + 1', estGas + 1)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    return estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await estimateGas(\n      address,\n      this.factory721.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class ContractConfig {\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  public transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  public transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  public transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  public gasFeeMultiplier: number\n}\n\nexport class Config extends ContractConfig {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n}\n\nexport default Config\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData } from '../utils'\nimport {\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport fetch from 'cross-fetch'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @param {boolean} checksum if true, will return checksum of files content\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @param {boolean} checksum if true, will return checksum of files content\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    headers?: any,\n    checksum: boolean = false\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url', checksum, headers }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Initialize a compute request.\n   * @param {ComputeAsset} assets\n   * @param {ComputeAlgorithmber} algorithm\n   * @param {string} computeEnv\n   * @param {number} validUntil\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {string} accountId\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm: algorithm,\n      compute: {\n        env: computeEnv,\n        validUntil: validUntil\n      },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute start failed: ', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n"],"names":["LogLevel","Logger","logLevel","Error","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","ZERO_ADDRESS","GASLIMIT_DEFAULT","estimateGas","from","functionToEstimateGas","estimatedGas","apply","err","estGas","e","amountToUnits","web3","token","amount","tokenDecimals","decimals","BigNumber","config","EXPONENTIAL_AT","times","exponentiatedBy","toFixed","tokenContract","eth","Contract","methods","call","message","unitsToAmount","amountFormatted","div","toString","getPoolCreationParams","poolParams","ssContract","baseTokenAddress","baseTokenSender","publisherAddress","marketFeeCollector","poolTemplateAddress","vestedBlocks","Web3","utils","toWei","vestingAmount","baseTokenDecimals","rate","initialBaseTokenLiquidity","addresses","ssParams","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","getFreOrderParams","freParams","exchangeId","exchangeContract","maxBaseTokenAmount","swapMarketFee","marketFeeAddress","getFairGasPrice","getGasPrice","x","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getErcCreationParams","ercParams","templateIndex","strings","minter","paymentCollector","mpFeeAddress","feeToken","uints","cap","feeAmount","bytess","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","owner","datatokenDecimals","fixedRate","marketFee","postData","url","payload","postWithHeaders","headers","fetch","method","body","getData","downloadFile","index","response","ok","filename","get","match","split","pop","arrayBuffer","data","downloadFileBrowser","headResponse","fileName","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","a","document","createElement","href","setAttribute","appendChild","click","remove","revokeObjectURL","send","fetchData","opts","result","text","_error2","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","FixedPrice","Dispenser","Staking","poolTemplate","ERC721Factory","OPFCommunityFeeCollector","Ocean","erc721FactoryAddress","sideStakingAddress","opfCommunityFeeCollector","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","contractAddressesConfig","CustomContractAddressess","generateDid","erc721Address","toChecksumAddress","sha256","getHash","signHash","address","sign","signedMessage","r","substr","slice","s","v","tokenAddress","balance","account","balanceOf","trxReceipt","allowanceWei","spender","allowance","transfer","recipient","_tokenContract$method6","gas","gasPrice","estTransfer","contractInstance","approveWei","force","approve","_tokenContract$method4","currentAllowence","gt","_tokenContract$method2","currentAllowance","Decimal","greaterThanOrEqualTo","estApprove","sleep","ms","Promise","resolve","setTimeout","getMaxRemoveLiquidity","poolInstance","poolAddress","getReserve","calcMaxExactIn","getMaxAddLiquidity","getMaxSwapExactIn","getMaxSwapExactOut","calcMaxExactOut","bind","pact","_settle","Aquarius","aquariusURL","did","signal","path","json","status","waitForAqua","txid","tries","_this4","ddo","event","validate","jsonResponse","valid","_this6","JSON","stringify","hash","proof","validatorAddress","publicKey","errors","getAssetMetadata","statusText","querySearch","query","recover","then","MaxUint256","Pool","poolAbi","PoolTemplate","abi","sharesBalance","fromWei","estSetSwapFee","fee","poolContract","defaultErc20Abi","setSwapFee","pool","_this10","_pool$methods$setSwap2","getNumTokens","_this12","getPoolSharesTotalSupply","_this14","totalSupply","getCurrentTokens","_this16","getFinalTokens","_this18","getController","_this20","getBaseToken","_this22","getBaseTokenAddress","getDatatoken","_this24","getDatatokenAddress","getMarketFee","_this26","getMarketFeeCollector","_this28","_publishMarketCollector","isBound","_this30","_this32","getBalance","isFinalized","_this34","getSwapFee","_this36","getNormalizedWeight","_this38","weight","getDenormalizedWeight","_this40","getTotalDenormalizedWeight","_this42","getMarketFees","_this44","publishMarketFees","getCurrentMarketFees","_this46","getCurrentOPCFees","_this48","getCommunityFees","_this50","communityFees","estCollectOPC","_this52","collectOPC","_this54","_pool$methods$collect2","estCollectMarketFee","_this56","collectMarketFee","_this58","_this57$getMarketFeeC","_pool$methods$collect4","estUpdatePublishMarketFee","newPublishMarketAddress","newPublishMarketSwapFee","_this60","updatePublishMarketFee","_this62","_this61$getMarketFeeC","_pool$methods$updateP2","estSwapExactAmountIn","tokenInOutMarket","amountsInOutMaxFee","_this64","tokenIn","tokenAmountIn","tokenInDecimals","tokenOut","minAmountOut","tokenOutDecimals","maxPrice","_amountsInOutMaxFee$m","swapExactAmountIn","_this66","maxSwap","greaterThan","_pool$methods$swapExa2","estSwapExactAmountOut","_this68","maxAmountIn","tokenAmountOut","swapExactAmountOut","_this70","_amountsInOutMaxFee$m4","_pool$methods$swapExa4","estJoinswapExternAmountIn","minPoolAmountOut","_this72","joinswapExternAmountIn","_this74","amountInFormatted","_pool$methods$joinswa2","estExitswapPoolAmountIn","poolAmountIn","minTokenAmountOut","_this76","exitswapPoolAmountIn","poolDecimals","_this78","calcSingleOutGivenPoolIn","minTokenOutFormatted","_pool$methods$exitswa2","getSpotPrice","decimalsDiff","decimalsTokenIn","decimalsTokenOut","price","_this80","tokenOutContract","tokenInContract","getAmountInExactOut","_this82","amountOutFormatted","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","tokenAmount","liquidityProviderSwapFeeAmount","getAmountOutExactIn","_this84","calcPoolOutGivenSingleIn","_this86","_pool$methods","calcPoolOutSingleIn","_calcPoolOutSingleIn","calcSingleInGivenPoolOut","poolAmountOut","_this88","calcSingleInPoolOut","_this90","_pool$methods2","calcSingleOutPoolIn","_calcSingleOutPoolIn","calcPoolInGivenSingleOut","_this92","_pool$methods3","calcPoolInSingleOut","_calcPoolInSingleOut","getSwapEventSignature","eventdata","encodeEventSignature","getJoinEventSignature","getExitEventSignature","FixedRateCreateProgressStep","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","_this2","maxTokens","maxBalance","_exit2","logger","estGasCreate","dtAddress","allowedSwapper","create","_this5$dispenserContr","estGasActivate","_this8","activate","_this9$dispenserContr","estGasDeactivate","deactivate","_this13$dispenserCont","estGasSetAllowedSwapper","newAllowedSwapper","setAllowedSwapper","_this17$dispenserCont","estGasDispense","destination","dispense","_this21$dispenserCont","estGasOwnerWithdraw","ownerWithdraw","_this25$dispenserCont","isDispensable","datatoken","active","String","isMinter","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","generateExchangeId","baseToken","estBuyDT","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","getExchange","exchange","consumeMarketFeeFormatted","dtDecimals","dtAmountFormatted","btDecimals","maxBtFormatted","_this9$fixedRateContr","estSellDT","sellDT","minBaseTokenAmount","minBtFormatted","_this13$fixedRateCont","getNumberOfExchanges","estSetRate","newRate","setRate","_this19$fixedRateCont","estSetAllowedSwapper","_this23$fixedRateCont","estActivate","toggleExchangeState","_this27$fixedRateCont","estDeactivate","_this31$fixedRateCont","getRate","weiRate","getDTSupply","dtSupply","getBTSupply","btSupply","getAllowedSwapper","calcBaseInGivenOutDT","fixedRateExchange","_this41$fixedRateCont","_calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","getAmountBTOut","_this43$fixedRateCont","calcBaseOutGivenInDT","_calcBaseOutGivenInDT","dtBalance","btBalance","getFeesInfo","opcFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","estActivateMint","toggleMintState","activateMint","_this55$fixedRateCont","estDeactivateMint","deactivateMint","_this59$fixedRateCont","estCollectBT","fixedrate","amountWei","collectBT","_this63$fixedRateCont","estCollectDT","collectDT","_this67$fixedRateCont","_this71$fixedRateCont","estCollectOceanFee","collectOceanFee","_this75$fixedRateCont","getOPCCollector","opcCollector","getRouter","router","getExchangeOwner","_this81$getExchange","exchangeOwner","estUpdateMarketFee","newMarketFee","updateMarketFee","_this85$fixedRateCont","estUpdateMarketFeeCollector","newMarketFeeCollector","updateMarketFeeCollector","_this89$fixedRateCont","SideStaking","SideStakingTemplate","sideStakingContract","ssAddress","getDatatokenCirculatingSupply","sideStaking","getDatatokenCurrentCirculatingSupply","getPublisherAddress","getPoolAddress","getBaseTokenBalance","getDatatokenBalance","getvestingEndBlock","getvestingAmount","getvestingLastBlock","getvestingAmountSoFar","estGetVesting","getVesting","_sideStaking$methods$13","estSetPoolSwapFee","swapFee","setPoolSwapFee","_sideStaking$methods$15","Router","routerAddress","RouterAbi","defaultRouter","estGasBuyDTBatch","operations","buyDTBatch","_this3$router$methods","isApprovedToken","isSideStaking","isSSContract","isFixedPrice","isFixedRateContract","getOwner","routerOwner","getNFTFactory","factory","isPoolTemplate","estGasAddApprovedToken","addApprovedToken","_this19$getOwner","_this19$router$method","estGasRemoveApprovedToken","removeApprovedToken","_this23$getOwner","_this23$router$method","estGasAddSSContract","addSSContract","_this27$getOwner","_this27$router$method","estGasRemoveSSContract","removeSSContract","_this31$getOwner","_this31$router$method","estGasAddFixedRateContract","addFixedRateContract","_this35$getOwner","_this35$router$method","estGasRemoveFixedRateContract","removeFixedRateContract","_this39$getOwner","_this39$router$method","estGasAddDispenserContract","addDispenserContract","_this43$getOwner","_this43$router$method","estGasRemoveDispenserContract","removeDispenserContract","_this47$getOwner","_this47$router$method","getOPCFee","getCurrentOPCFee","swapOceanFee","estGasUpdateOPCFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","_this55$getOwner","_this55$router$method","estGasAddPoolTemplate","templateAddress","addPoolTemplate","_this59$getOwner","_this59$router$method","estGasRemovePoolTemplate","removePoolTemplate","_this63$getOwner","_this63$router$method","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","estGasCreateErc20","nftAddress","nftContract","createERC20","createErc20","getNftPermissions","_this3$getNftPermissi","deployERC20","_nftContract$methods$","events","TokenCreated","returnValues","estGasAddManager","manager","addManager","getNftOwner","_this7$getNftOwner","_nftContract$methods$2","estGasRemoveManager","removeManager","_this11$getNftOwner","_nftContract$methods$3","estGasAddErc20Deployer","erc20Deployer","addToCreateERC20List","addErc20Deployer","_this15$getNftPermiss","_nftContract$methods$4","estGasRemoveErc20Deployer","removeFromCreateERC20List","removeErc20Deployer","_temp","_this19$getNftPermiss2","_nftContract$methods$5","_this19$getNftPermiss","estGasAddMetadataUpdater","metadataUpdater","addToMetadataList","addMetadataUpdater","_this23$getNftPermiss","_nftContract$methods$6","esGasRemoveMetadataUpdater","removeFromMetadataList","removeMetadataUpdater","_temp3","_this27$getNftPermiss2","updateMetadata","_nftContract$methods$7","_this27$getNftPermiss","estGasAddStoreUpdater","storeUpdater","addTo725StoreList","addStoreUpdater","_this31$getNftPermiss","_nftContract$methods$8","estGasRemoveStoreUpdater","removeFrom725StoreList","removeStoreUpdater","_temp5","_this35$getNftPermiss2","store","_nftContract$methods$9","_this35$getNftPermiss","estGasCleanPermissions","cleanPermissions","_this39$getNftOwner","_nftContract$methods$10","estGasTransferNft","nftOwner","nftReceiver","tokenId","transferFrom","transferNft","_this43$getNftOwner","tokenIdentifier","_nftContract$methods$11","estGasSafeTransferNft","safeTransferFrom","safeTransferNft","_this47$getNftOwner","_nftContract$methods$12","estGasSetMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","setMetadata","_this51$getNftPermiss","_nftContract$methods$13","estGasSetMetadataAndTokenURI","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataAndTokenURI","_this55$getNftPermiss","_nftContract$methods$14","estGasSetMetadataState","setMetaDataState","setMetadataState","_this59$getNftPermiss","_nftContract$methods$15","estSetTokenURI","setTokenURI","_nftContract$methods$16","setData","key","value","_this65$getNftPermiss","keyHash","keccak256","valueHex","asciiToHex","setNewData","_nftContract$methods$17","ownerOf","getPermissions","getMetadata","getMetaData","isErc20Deployer","isERC20Deployer","hexToAscii","getTokenURI","id","tokenURI","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","estGasApprove","dtContract","_dtContract$methods$a","estGasMint","toAddress","mint","estGasCreateFixedRate","fixedRateParams","createFixedRate","_dtContract$methods$c","estGasCreateDispenser","dispenserParams","createDispenser","_dtContract$methods$c2","getDTPermissions","_this15$getDTPermissi","getCap","capAvailble","gte","_dtContract$methods$m","estGasAddMinter","addMinter","_this19$isERC20Deploy","_dtContract$methods$a2","estGasRemoveMinter","removeMinter","_this23$isERC20Deploy","_dtContract$methods$r","estGasAddPaymentManager","paymentManager","addPaymentManager","_this27$isERC20Deploy","_dtContract$methods$a3","estGasRemovePaymentManager","removePaymentManager","_this31$isERC20Deploy","_dtContract$methods$r2","estGasSetPaymentCollector","setPaymentCollector","nftPermissions","isPaymentManager","isNftOwner","_dtContract$methods$s","_this35$nft$getNftOwn","_this35$getDTPermissi","getNFTAddress","getPaymentCollector","weiAmount","transferWei","estGasTransfer","_dtContract$methods$t","estGasStartOrder","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","getPublishingMarketFee","publishMarketFee","_dtContract$methods$s2","tokens","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","push","getCurrentAllownceTokens","all","estGasReuseOrder","orderTxId","reuseOrder","_dtContract$methods$r3","estGasBuyFromFreAndOrder","orderParams","buyFromFreAndOrder","freContractParams","_dtContract$methods$b","estGasBuyFromDispenserAndOrder","buyFromDispenserAndOrder","_dtContract$methods$b2","estGasSetData","_dtContract$methods$s3","_this67$nft2","_this67$nft$getNftOwn","_dtContract$methods$c3","permissions","getDecimals","getERC721Address","estGasSetPublishingMarketFee","publishMarketFeeAddress","publishMarketFeeToken","publishMarketFeeAmount","setPublishingMarketFee","_dtContract$methods$g","_dtContract$methods$s4","publishingMarketFee","NftFactory","factory721","defaultFactory721Abi","estGasCreateNFT","nftData","deployERC721Contract","transferable","createNFT","getCurrentNFTTemplateCount","_nftData$templateInde2","getNFTTemplate","_this3$getNFTTemplate","_this3$factory721$met","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTokenTemplateCount","getCurrentTemplateCount","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","estGasAddNFTTemplate","add721TokenTemplate","addNFTTemplate","_this25$getOwner","_this25$factory721$me","estGasDisableNFTTemplate","disable721TokenTemplate","disableNFTTemplate","_this29$getOwner","_this29$factory721$me","estGasReactivateNFTTemplate","reactivate721TokenTemplate","reactivateNFTTemplate","_this33$getOwner","_this33$factory721$me","estGasAddTokenTemplate","addTokenTemplate","_this37$getOwner","_this37$factory721$me","estGasDisableTokenTemplate","disableTokenTemplate","_this41$getOwner","_this41$getTokenTempl","_this41$factory721$me","estGasReactivateTokenTemplate","reactivateTokenTemplate","_this45$getOwner","_this45$getTokenTempl","_this45$factory721$me","estGasStartMultipleTokenOrder","orders","startMultipleTokenOrder","_this49$factory721$me","estGasCreateNftWithErc20","nftCreateData","ercCreateData","createNftWithErc20","_this53$factory721$me","estGasCreateNftErc20WithPool","poolData","createNftWithErc20WithPool","createNftErc20WithPool","_this57$factory721$me","estGasCreateNftErc20WithFixedRate","fixedData","createNftWithErc20WithFixedRate","createNftErc20WithFixedRate","_this61$factory721$me","estGasCreateNftErc20WithDispenser","createNftWithErc20WithDispenser","createNftErc20WithDispenser","_this65$factory721$me","ContractConfig","Config","providerAddress","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","noZeroX","input","zeroOutput","regexp","conversorName","output","inputMatch","zeroXTransformer","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","i","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","signProviderRequest","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","encrypt","checkDidFiles","serviceId","withChecksum","args","checksum","files","results","checkFileUrl","getComputeEnvironments","_this10$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","initializeCompute","assets","algorithm","providerData","datasets","compute","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","additionalDatasets","computeStartUrl","signatureMessage","documentId","Object","environment","params","computeStop","jobId","computeStopUrl","computeStatus","computeStatusUrl","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","isValidProvider","ProviderInstance"],"mappings":"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"}