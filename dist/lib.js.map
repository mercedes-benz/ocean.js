{"version":3,"file":"lib.js","sources":["../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/minAbi.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/FetchHelper.ts","../src/utils/ConfigHelper.ts","../src/utils/TokenUtils.ts","../src/utils/General.ts","../src/utils/PoolHelpers.ts","../src/aquarius/Aquarius.ts","../src/pools/balancer/Pool.ts","../src/pools/dispenser/Dispenser.ts","../src/pools/fixedRate/FixedRateExchange.ts","../src/pools/ssContracts/SideStaking.ts","../src/pools/Router.ts","../src/tokens/NFT.ts","../src/tokens/Datatoken.ts","../src/factories/NFTFactory.ts","../src/models/Config.ts","../src/utils/ConversionTypeHelper.ts","../src/provider/Provider.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\nexport default LoggerInstance\n","import wordListDefault from '../data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { generateDtName } from './DatatokenName'\nimport {\n  Erc20CreateParams,\n  FreCreationParams,\n  FreOrderParams,\n  PoolCreationParams\n} from '../@types'\nimport { ContractConfig } from '../models'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { ZERO_ADDRESS } from './Constants'\n\nexport function setContractDefaults(\n  contract: Contract,\n  config: ContractConfig\n): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  config: ContractConfig\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (config && config.gasFeeMultiplier)\n    return x\n      .multipliedBy(config.gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport function getErcCreationParams(ercParams: Erc20CreateParams): any {\n  let name: string, symbol: string\n  // Generate name & symbol if not present\n  if (!ercParams.name || !ercParams.symbol) {\n    ;({ name, symbol } = generateDtName())\n  }\n  return {\n    templateIndex: ercParams.templateIndex,\n    strings: [ercParams.name || name, ercParams.symbol || symbol],\n    addresses: [\n      ercParams.minter,\n      ercParams.paymentCollector,\n      ercParams.mpFeeAddress,\n      ercParams.feeToken\n    ],\n    uints: [Web3.utils.toWei(ercParams.cap), Web3.utils.toWei(ercParams.feeAmount)],\n    bytess: []\n  }\n}\n\nexport function getFreOrderParams(freParams: FreOrderParams): any {\n  return {\n    exchangeContract: freParams.exchangeContract,\n    exchangeId: freParams.exchangeId,\n    maxBaseTokenAmount: Web3.utils.toWei(freParams.maxBaseTokenAmount),\n    swapMarketFee: Web3.utils.toWei(freParams.swapMarketFee),\n    marketFeeAddress: freParams.marketFeeAddress\n  }\n}\n\nexport function getFreCreationParams(freParams: FreCreationParams): any {\n  if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n  const withMint = freParams.withMint ? 1 : 0\n\n  return {\n    fixedPriceAddress: freParams.fixedRateAddress,\n    addresses: [\n      freParams.baseTokenAddress,\n      freParams.owner,\n      freParams.marketFeeCollector,\n      freParams.allowedConsumer\n    ],\n    uints: [\n      freParams.baseTokenDecimals,\n      freParams.datatokenDecimals,\n      Web3.utils.toWei(freParams.fixedRate),\n      Web3.utils.toWei(freParams.marketFee),\n      withMint\n    ]\n  }\n}\n\nexport async function getPoolCreationParams(\n  web3: Web3,\n  poolParams: PoolCreationParams\n): Promise<any> {\n  return {\n    addresses: [\n      poolParams.ssContract,\n      poolParams.baseTokenAddress,\n      poolParams.baseTokenSender,\n      poolParams.publisherAddress,\n      poolParams.marketFeeCollector,\n      poolParams.poolTemplateAddress\n    ],\n    ssParams: [\n      Web3.utils.toWei(poolParams.rate),\n      poolParams.baseTokenDecimals,\n      Web3.utils.toWei(poolParams.vestingAmount),\n      poolParams.vestedBlocks,\n      await amountToUnits(\n        web3,\n        poolParams.baseTokenAddress,\n        poolParams.initialBaseTokenLiquidity\n      )\n    ],\n    swapFees: [\n      Web3.utils.toWei(poolParams.swapFeeLiquidityProvider),\n      Web3.utils.toWei(poolParams.swapFeeMarketRunner)\n    ]\n  }\n}\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n\n    const amountFormatted = new BigNumber(amount).div(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${e.message}`)\n  }\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  try {\n    const tokenContract = new web3.eth.Contract(minAbi, token)\n    let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n    if (decimals === '0') {\n      decimals = 18\n    }\n    BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n    const amountFormatted = new BigNumber(amount).times(\n      new BigNumber(10).exponentiatedBy(decimals)\n    )\n\n    return amountFormatted.toString()\n  } catch (e) {\n    LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${e.message}`)\n  }\n}\n","import fetch from 'cross-fetch'\nimport LoggerInstance from './Logger'\nimport { DownloadResponse } from '../@types/DownloadResponse'\n\nexport async function fetchData(url: string, opts: RequestInit): Promise<Response> {\n  const result = await fetch(url, opts)\n  if (!result.ok) {\n    LoggerInstance.error(`Error requesting [${opts.method}] ${url}`)\n    LoggerInstance.error(`Response message: \\n${await result.text()}`)\n    throw result\n  }\n  return result\n}\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const anchor = document.createElement('a')\n  anchor.download = ''\n  anchor.href = url\n  anchor.click()\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n\nexport async function getData(url: string): Promise<Response> {\n  return fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n\nasync function postWithHeaders(\n  url: string,\n  payload: BodyInit,\n  headers: any\n): Promise<Response> {\n  if (payload != null) {\n    return fetch(url, {\n      method: 'POST',\n      body: payload,\n      headers\n    })\n  } else {\n    return fetch(url, {\n      method: 'POST'\n    })\n  }\n}\n\nexport async function postData(url: string, payload: BodyInit): Promise<Response> {\n  const headers = {\n    'Content-type': 'application/json'\n  }\n  return postWithHeaders(url, payload, headers)\n}\n","import Config from '../models/Config'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport LoggerInstance from './Logger'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  poolTemplateAddress: null,\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000',\n    providerUri: 'http://172.15.0.4:8030'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 3,\n    network: 'ropsten',\n    nodeUri: 'https://ropsten.infura.io/v3',\n    providerUri: 'https://v4.provider.ropsten.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.ropsten.oceanprotocol.com',\n    explorerUri: 'https://ropsten.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 4,\n    network: 'rinkeby',\n    nodeUri: 'https://rinkeby.infura.io/v3',\n    providerUri: 'https://v4.provider.rinkeby.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.rinkeby.oceanprotocol.com',\n    explorerUri: 'https://rinkeby.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      try {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          ERC721Factory,\n          OPFCommunityFeeCollector,\n          Ocean,\n          chainId,\n          startBlock\n        } = customAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      } catch (e) {\n        // console.error(`ERROR: Could not load local contract address file: ${e.message}`)\n        // return null\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          Staking,\n          poolTemplate,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          erc721FactoryAddress: ERC721Factory,\n          sideStakingAddress: Staking,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          poolTemplateAddress: poolTemplate,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId: chainId,\n          startBlock: startBlock,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import Decimal from 'decimal.js'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from './ContractUtils'\nimport { minAbi } from './minAbi'\nimport LoggerInstance from './Logger'\nimport { TransactionReceipt } from 'web3-core'\nimport Web3 from 'web3'\nimport { GASLIMIT_DEFAULT } from '.'\nimport { Config, ContractConfig } from '../models'\n\n/**\n * Estimate gas cost for approval function\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount\n * @param {String} force\n * @param {Contract} contractInstance optional contract instance\n * @return {Promise<number>}\n */\nexport async function estApprove(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  contractInstance?: Contract\n): Promise<number> {\n  const tokenContract = contractInstance || new web3.eth.Contract(minAbi, tokenAddress)\n\n  const gasLimitDefault = GASLIMIT_DEFAULT\n  let estGas\n  try {\n    estGas = await tokenContract.methods\n      .approve(spender, amount)\n      .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n  } catch (e) {\n    estGas = gasLimitDefault\n    LoggerInstance.error('estimate gas failed for approve!', e)\n  }\n  return estGas\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount  (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function approve(\n  web3: Web3,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<TransactionReceipt | string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  if (!force) {\n    const currentAllowance = await allowance(\n      web3,\n      tokenAddress,\n      account,\n      spender,\n      tokenDecimals,\n      config\n    )\n    if (new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(amount))) {\n      return currentAllowance\n    }\n  }\n  let result = null\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await estApprove(\n    web3,\n    account,\n    tokenAddress,\n    spender,\n    amountFormatted,\n    tokenContract\n  )\n\n  try {\n    result = await tokenContract.methods.approve(spender, amountFormatted).send({\n      from: account,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(web3, config)\n    })\n  } catch (e) {\n    LoggerInstance.error(\n      `ERRPR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number,\n  config?: ContractConfig\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get balance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {Config} config  configuration that provide values for web3 transaction gasFeeMultiplier, transactionBlockTimeout, transactionConfirmationBlocks, transactionPollingTimeout\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number,\n  config?: Config\n): Promise<string> {\n  const tokenContract = setContractDefaults(\n    new web3.eth.Contract(minAbi, tokenAddress),\n    config\n  )\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import Decimal from 'decimal.js'\nimport { Pool } from '..'\n\nexport function calcMaxExactOut(balance: string): Decimal {\n  return new Decimal(balance).div(3.01)\n}\n\nexport function calcMaxExactIn(balance: string): Decimal {\n  return new Decimal(balance).div(2.01)\n}\nexport async function getMaxSwapExactOut(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactOut(reserve)\n}\n\nexport async function getMaxSwapExactIn(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxAddLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n\nexport async function getMaxRemoveLiquidity(\n  poolInstance: Pool,\n  poolAddress: string,\n  tokenAddress: string\n): Promise<Decimal> {\n  const reserve = await poolInstance.getReserve(poolAddress, tokenAddress)\n\n  return calcMaxExactIn(reserve)\n}\n","import { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types/'\nimport fetch from 'cross-fetch'\nexport class Aquarius {\n  public aquariusURL\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n}\n\nexport default Aquarius\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount,\n  amountToUnits,\n  LoggerInstance,\n  ConfigHelper\n} from '../../utils'\nimport BigNumber from 'bignumber.js'\nimport PoolTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json'\nimport defaultErc20Abi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport {\n  CurrentFees,\n  TokenInOutMarket,\n  AmountsInMaxFee,\n  AmountsOutMaxFee,\n  PoolPriceAndFees\n} from '../../@types'\nimport { Config } from '../../models'\nimport {\n  getMaxAddLiquidity,\n  getMaxRemoveLiquidity,\n  getMaxSwapExactIn,\n  getMaxSwapExactOut\n} from '../../utils/PoolHelpers'\nimport Decimal from 'decimal.js'\nconst MaxUint256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\n\n/**\n * Provides an interface to Ocean friendly fork from Balancer BPool\n */\nexport class Pool {\n  public poolAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  private config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    poolAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (poolAbi) this.poolAbi = poolAbi\n    else this.poolAbi = PoolTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get user shares of pool tokens\n   * @param {String} account\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async sharesBalance(account: string, poolAddress: string): Promise<string> {\n    let result = null\n    try {\n      const token = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const balance = await token.methods.balanceOf(account).call()\n      result = this.web3.utils.fromWei(balance)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get shares of pool : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for setSwapFee\n   * @param {String} account\n   * @param {String} tokenAddress\n   * @param {String} spender\n   * @param {String} amount\n   * @param {String} force\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .setSwapFee(fee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Allows controller to change the swapFee\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} fee swap fee (1e17 = 10 % , 1e16 = 1% , 1e15 = 0.1%, 1e14 = 0.01%)\n   */\n  async setSwapFee(\n    account: string,\n    poolAddress: string,\n    fee: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress, {\n        from: account\n      }),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estSetSwapFee(account, poolAddress, fee)\n\n    try {\n      result = await pool.methods.setSwapFee(this.web3.utils.toWei(fee)).send({\n        from: account,\n        gas: estGas,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to set pool swap fee: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns number of tokens bounded to pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getNumTokens(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getNumTokens().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get number of tokens: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total supply of pool shares\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getPoolSharesTotalSupply(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    try {\n      const result = await pool.methods.totalSupply().call()\n      amount = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total supply of pool shares: ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get tokens composing this poo\n   * Returns tokens bounded to pool, before the pool is finalizedl\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getCurrentTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getCurrentTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get tokens composing this pool: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get the final tokens composing this pool\n   * Returns tokens bounded to pool, after the pool was finalized\n   * @param {String} poolAddress\n   * @return {String[]}\n   */\n  async getFinalTokens(poolAddress: string): Promise<string[]> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getFinalTokens().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get the final tokens composing this pool ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Returns the current controller address (ssBot)\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getController(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getController().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool controller address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current baseToken address of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getBaseToken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getBaseTokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get baseToken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current datatoken address\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getDatatoken(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getDatatokenAddress().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get datatoken address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get getMarketFee\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.getMarketFee().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get getMarketFee: ${e.message}`)\n    }\n    return this.web3.utils.fromWei(result).toString()\n  }\n\n  /**\n   * Get marketFeeCollector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getMarketFeeCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._publishMarketCollector().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get marketFeeCollector address: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   * Get OPC Collector of this pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getOPCCollector(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods._opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get if a token is bounded to a pool\n   *  Returns true if token is bound\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @return {Boolean}\n   */\n  async isBound(poolAddress: string, token: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isBound(token).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to check whether a token \\\n      bounded to a pool. ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Returns the current token reserve amount\n   * @param {String} poolAddress\n   * @param {String} token  Address of the token to be checked\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getReserve(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    let amount = null\n    try {\n      const pool = setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi, poolAddress),\n        this.config\n      )\n      const result = await pool.methods.getBalance(token).call()\n      amount = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get how many tokens \\\n      are in the pool: ${e.message}`)\n    }\n    return amount.toString()\n  }\n\n  /**\n   * Get if a pool is finalized\n   * Returns true if pool is finalized\n   * @param {String} poolAddress\n   * @return {Boolean}\n   */\n  async isFinalized(poolAddress: string): Promise<boolean> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    try {\n      result = await pool.methods.isFinalized().call()\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to check whether pool is finalized: ${e.message}`\n      )\n    }\n    return result\n  }\n\n  /**\n   *  Returns the current Liquidity Providers swap fee\n   * @param {String} poolAddress\n   * @return {String} Swap fee. To get the percentage value, substract by 100. E.g. `0.1` represents a 10% swap fee.\n   */\n  async getSwapFee(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let fee = null\n    try {\n      const result = await pool.methods.getSwapFee().call()\n      fee = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get pool fee: ${e.message}`)\n    }\n    return fee\n  }\n\n  /**\n   * Returns normalized weight of a token.\n   * The combined normalized weights of all tokens will sum up to 1.\n   * (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getNormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getNormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get normalized weight of a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   *  Returns denormalized weight of a token\n   * @param {String} poolAddress\n   * @param {String} token token to be checked\n   * @return {String}\n   */\n  async getDenormalizedWeight(poolAddress: string, token: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getDenormalizedWeight(token).call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get denormalized weight of a token in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * getTotalDenormalizedWeight\n   * Returns total denormalized weught of the pool\n   * @param {String} poolAddress\n   * @return {String}\n   */\n  async getTotalDenormalizedWeight(poolAddress: string): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.getTotalDenormalizedWeight().call()\n      weight = this.web3.utils.fromWei(result)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get total denormalized weight in pool ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Returns the current fee of publishingMarket\n   * Get Market Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getMarketFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.publishMarketFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get market fees for a token: ${e.message}`)\n    }\n    return weight\n  }\n\n  /**\n   * Get Community  Get the current amount of fees which can be withdrawned by the Market\n   * @return {CurrentFees}\n   */\n  async getCurrentMarketFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get getCurrentOPFFees  Get the current amount of fees which can be withdrawned by OPF\n   * @return {CurrentFees}\n   */\n  async getCurrentOPCFees(poolAddress: string): Promise<CurrentFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    try {\n      const currentMarketFees = await pool.methods.getCurrentOPCFees().call()\n      return currentMarketFees\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n  }\n\n  /**\n   * Get Community Fees available to be collected for a specific token\n   * @param {String} poolAddress\n   * @param {String} token token we want to check fees\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getCommunityFees(\n    poolAddress: string,\n    token: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let weight = null\n    try {\n      const result = await pool.methods.communityFees(token).call()\n      weight = await this.unitsToAmount(token, result, tokenDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to get community fees for a token: ${e.message}`\n      )\n    }\n    return weight\n  }\n\n  /**\n   * Estimate gas cost for collectOPF\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOPC(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectOPC()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect opf fee - can be called by anyone\n   * @param {String} address\n   * @param {String} poolAddress\n   * @return {TransactionReceipt}\n   */\n  async collectOPC(address: string, poolAddress: string): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectOPC(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectOPC().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for collectMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    address: string,\n    poolAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .collectMarketFee()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * collectOPF - collect market fees - can be called by the publishMarketCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} to address that will receive fees\n   * @return {TransactionReceipt}\n   */\n  async collectMarketFee(\n    address: string,\n    poolAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const estGas = await this.estCollectMarketFee(address, poolAddress)\n\n    try {\n      result = await pool.methods.collectMarketFee().send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updatePublishMarketFee\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market address\n   * @param {String} newPublishMarketSwapFee new market swap fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .updatePublishMarketFee(newPublishMarketAddress, newPublishMarketSwapFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * updatePublishMarketFee - sets a new  newPublishMarketAddress and new newPublishMarketSwapFee- can be called only by the marketFeeCollector\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} newPublishMarketAddress new market fee collector address\n   * @param {String} newPublishMarketSwapFee fee recieved by the publisher market when a dt is swaped from a pool, percent\n   * @return {TransactionReceipt}\n   */\n  async updatePublishMarketFee(\n    address: string,\n    poolAddress: string,\n    newPublishMarketAddress: string,\n    newPublishMarketSwapFee: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getMarketFeeCollector(poolAddress)) !== address) {\n      throw new Error(`Caller is not MarketFeeCollector`)\n    }\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const estGas = await this.estUpdatePublishMarketFee(\n      address,\n      poolAddress,\n      newPublishMarketAddress,\n      this.web3.utils.toWei(newPublishMarketSwapFee)\n    )\n    try {\n      result = await pool.methods\n        .updatePublishMarketFee(\n          newPublishMarketAddress,\n          this.web3.utils.toWei(newPublishMarketSwapFee)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to updatePublishMarketFee : ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps an exact amount of tokensIn to get a mimum amount of tokenOut\n   * Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool,\n   * in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.\n   * Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool,\n   * and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call.\n   * (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket object contianing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsInMaxFee} amountsInOutMaxFee object contianing tokenAmountIn, minAmountOut, maxPrice, consumeMarketSwapFee\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsInMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenInOutMarket.tokenIn)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountIn(\n      address,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const tokenAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.tokenAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const minAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.minAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    let result = null\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountIn(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            tokenAmountIn,\n            minAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount in : ${e.message}`)\n    }\n\n    return result\n  }\n\n  /**\n   * Estimate gas cost for swapExactAmountOut\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSwapExactAmountOut(\n    address: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? await this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Swaps a maximum  maxAmountIn of tokensIn to get an exact amount of tokenOut\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {TokenInOutMarket} tokenInOutMarket Object containing addresses like tokenIn, tokenOut, consumeMarketFeeAddress\n   * @param {AmountsOutMaxFee} amountsInOutMaxFee Object containging maxAmountIn,tokenAmountOut,maxPrice, consumeMarketSwapFee]\n   * @return {TransactionReceipt}\n   */\n  async swapExactAmountOut(\n    account: string,\n    poolAddress: string,\n    tokenInOutMarket: TokenInOutMarket,\n    amountsInOutMaxFee: AmountsOutMaxFee\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenInOutMarket.tokenOut)\n    if (new Decimal(amountsInOutMaxFee.tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const estGas = await this.estSwapExactAmountOut(\n      account,\n      poolAddress,\n      tokenInOutMarket,\n      amountsInOutMaxFee\n    )\n\n    const maxAmountIn = await this.amountToUnits(\n      tokenInOutMarket.tokenIn,\n      amountsInOutMaxFee.maxAmountIn,\n      tokenInOutMarket.tokenInDecimals\n    )\n\n    const tokenAmountOut = await this.amountToUnits(\n      tokenInOutMarket.tokenOut,\n      amountsInOutMaxFee.tokenAmountOut,\n      tokenInOutMarket.tokenOutDecimals\n    )\n\n    const maxPrice = amountsInOutMaxFee.maxPrice\n      ? this.amountToUnits(\n          await this.getBaseToken(poolAddress),\n          amountsInOutMaxFee.maxPrice\n        )\n      : MaxUint256\n\n    try {\n      result = await pool.methods\n        .swapExactAmountOut(\n          [\n            tokenInOutMarket.tokenIn,\n            tokenInOutMarket.tokenOut,\n            tokenInOutMarket.marketFeeAddress\n          ],\n          [\n            maxAmountIn,\n            tokenAmountOut,\n            maxPrice,\n            this.web3.utils.toWei(amountsInOutMaxFee.swapMarketFee)\n          ]\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to swap exact amount out: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for joinswapExternAmountIn\n   * @param {String} address\n   * @param {String} poolAddress\n   * @param {String} tokenIn\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estJoinswapExternAmountIn(\n    address: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .joinswapExternAmountIn(tokenAmountIn, minPoolAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side add liquidity to the pool,\n   * expecting a minPoolAmountOut of shares for spending tokenAmountIn basetokens.\n   * Pay tokenAmountIn of baseToken to join the pool, getting poolAmountOut of the pool shares.\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} tokenAmountIn exact number of base tokens to spend\n   * @param {String} minPoolAmountOut minimum of pool shares expectex\n   * @return {TransactionReceipt}\n   */\n  async joinswapExternAmountIn(\n    account: string,\n    poolAddress: string,\n    tokenAmountIn: string,\n    minPoolAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenIn = await this.getBaseToken(poolAddress)\n    const maxSwap = await getMaxAddLiquidity(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(tokenIn, tokenAmountIn)\n    const estGas = await this.estJoinswapExternAmountIn(\n      account,\n      poolAddress,\n      amountInFormatted,\n      this.web3.utils.toWei(minPoolAmountOut)\n    )\n\n    try {\n      result = await pool.methods\n        .joinswapExternAmountIn(\n          amountInFormatted,\n          this.web3.utils.toWei(minPoolAmountOut)\n        )\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay tokens in order to \\\n      join the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for exitswapPoolAmountIn\n   * @param {String} address\n   *  @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estExitswapPoolAmountIn(\n    address: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const poolContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.poolAbi as AbiItem[], poolAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await poolContract.methods\n        .exitswapPoolAmountIn(poolAmountIn, minTokenAmountOut)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Single side remove liquidity from the pool,\n   * expecting a minAmountOut of basetokens for spending poolAmountIn pool shares\n   * Pay poolAmountIn pool shares into the pool, getting minTokenAmountOut of the baseToken\n   * @param {String} account\n   * @param {String} poolAddress\n   * @param {String} poolAmountIn exact number of pool shares to spend\n   * @param {String} minTokenAmountOut minimum amount of basetokens expected\n   * @return {TransactionReceipt}\n   */\n  async exitswapPoolAmountIn(\n    account: string,\n    poolAddress: string,\n    poolAmountIn: string,\n    minTokenAmountOut: string\n  ): Promise<TransactionReceipt> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let result = null\n    const tokenOut = await this.getBaseToken(poolAddress)\n\n    const tokenAmountOut = await this.calcSingleOutGivenPoolIn(\n      poolAddress,\n      tokenOut,\n      poolAmountIn\n    )\n\n    const maxSwap = await getMaxRemoveLiquidity(this, poolAddress, tokenOut)\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const minTokenOutFormatted = await this.amountToUnits(\n      await this.getBaseToken(poolAddress),\n      minTokenAmountOut\n    )\n    const estGas = await this.estExitswapPoolAmountIn(\n      account,\n      poolAddress,\n      this.web3.utils.toWei(poolAmountIn),\n      minTokenOutFormatted\n    )\n\n    try {\n      result = await pool.methods\n        .exitswapPoolAmountIn(this.web3.utils.toWei(poolAmountIn), minTokenOutFormatted)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to pay pool shares into the pool: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Return the spot price of swapping tokenIn to tokenOut\n   * @param {String} poolAddress\n   * @param {String} tokenIn in token\n   * @param {String} tokenOut out token\n   * @param {String} swapMarketFe consume market swap fee\n   * @return {String}\n   */\n  async getSpotPrice(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    swapMarketFee: string\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let decimalsTokenIn = 18\n    let decimalsTokenOut = 18\n\n    const tokenInContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenIn),\n      this.config\n    )\n    const tokenOutContract = setContractDefaults(\n      new this.web3.eth.Contract(defaultErc20Abi.abi as AbiItem[], tokenOut),\n      this.config\n    )\n    try {\n      decimalsTokenIn = await tokenInContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n    try {\n      decimalsTokenOut = await tokenOutContract.methods.decimals().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${e.message}`)\n    }\n\n    let price = null\n    try {\n      price = await pool.methods\n        .getSpotPrice(tokenIn, tokenOut, this.web3.utils.toWei(swapMarketFee))\n        .call()\n      price = new BigNumber(price.toString())\n    } catch (e) {\n      LoggerInstance.error(\n        'ERROR: Failed to get spot price of swapping tokenIn to tokenOut'\n      )\n    }\n\n    let decimalsDiff\n    if (decimalsTokenIn > decimalsTokenOut) {\n      decimalsDiff = decimalsTokenIn - decimalsTokenOut\n      price = new BigNumber(price / 10 ** decimalsDiff)\n      price = price / 10 ** decimalsTokenOut\n    } else {\n      decimalsDiff = decimalsTokenOut - decimalsTokenIn\n      price = new BigNumber(price * 10 ** (2 * decimalsDiff))\n      price = price / 10 ** decimalsTokenOut\n    }\n\n    return price.toString()\n  }\n\n  /**\n   * How many tokensIn do you need in order to get exact tokenAmountOut.\n   * Returns: tokenAmountIn, swapFee, opcFee , consumeMarketSwapFee, publishMarketSwapFee\n   * Returns: tokenAmountIn, LPFee, opcFee , publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountOut exact amount of tokenOut\n   * @param swapMarketFee consume market swap fee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountInExactOut(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactOut(this, poolAddress, tokenOut)\n\n    if (new Decimal(tokenAmountOut).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountOut is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountOutFormatted = await this.amountToUnits(\n      tokenOut,\n      tokenAmountOut,\n      tokenOutDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountInExactOut(\n          tokenIn,\n          tokenOut,\n          amountOutFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountIn,\n          tokenOutDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcInGivenOut ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   *  How many tokensOut you will get for a exact tokenAmountIn\n   *  Returns: tokenAmountOut, LPFee, opcFee ,  publishMarketSwapFee, consumeMarketSwapFee\n   * @param tokenIn token to be swaped\n   * @param tokenOut token to get\n   * @param tokenAmountIn exact amount of tokenIn\n   * @param swapMarketFee\n   * @param {number} tokenInDecimals optional number of decimals of the token to be swaped\n   * @param {number} tokenOutDecimals optional number of decimals of the token to get\n   */\n  public async getAmountOutExactIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenOut: string,\n    tokenAmountIn: string,\n    swapMarketFee: string,\n    tokenInDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<PoolPriceAndFees> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n\n    const maxSwap = await getMaxSwapExactIn(this, poolAddress, tokenIn)\n    if (new Decimal(tokenAmountIn).greaterThan(maxSwap)) {\n      throw new Error(`tokenAmountIn is greater than ${maxSwap.toString()}`)\n    }\n\n    const amountInFormatted = await this.amountToUnits(\n      tokenIn,\n      tokenAmountIn,\n      tokenInDecimals\n    )\n\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .getAmountOutExactIn(\n          tokenIn,\n          tokenOut,\n          amountInFormatted,\n          this.web3.utils.toWei(swapMarketFee)\n        )\n        .call()\n\n      amount = {\n        tokenAmount: await this.unitsToAmount(\n          tokenOut,\n          result.tokenAmountOut,\n          tokenOutDecimals\n        ),\n        liquidityProviderSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.lpFeeAmount,\n          tokenInDecimals\n        ),\n        oceanFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.oceanFeeAmount,\n          tokenInDecimals\n        ),\n        publishMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.publishMarketSwapFeeAmount,\n          tokenInDecimals\n        ),\n        consumeMarketSwapFeeAmount: await this.unitsToAmount(\n          tokenIn,\n          result.consumeMarketSwapFeeAmount,\n          tokenInDecimals\n        )\n      }\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calcOutGivenIn ${e.message}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares obtain by staking exact tokenAmountIn tokens\n   * @param tokenIn tokenIn\n   * @param tokenAmountIn exact number of tokens staked\n   * @param {number} poolDecimals optional number of decimals of the poool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcPoolOutGivenSingleIn(\n    poolAddress: string,\n    tokenIn: string,\n    tokenAmountIn: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolOutSingleIn(\n          tokenIn,\n          await this.amountToUnits(tokenIn, tokenAmountIn, tokenInDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolOutGivenSingleIn : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of tokens to be staked to the pool in order to get an exact number of poolshares\n   * @param tokenIn tokenIn\n   * @param poolAmountOut expected amount of pool shares\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenInDecimals optional number of decimals of the token\n   */\n  public async calcSingleInGivenPoolOut(\n    poolAddress: string,\n    tokenIn: string,\n    poolAmountOut: string,\n    poolDecimals?: number,\n    tokenInDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n    const amountFormatted = await this.amountToUnits(\n      poolAddress,\n      poolAmountOut,\n      poolDecimals\n    )\n    try {\n      const result = await pool.methods\n        .calcSingleInPoolOut(tokenIn, amountFormatted)\n        .call()\n\n      amount = await this.unitsToAmount(tokenIn, result, tokenInDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate SingleInGivenPoolOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Returns expected amount of tokenOut for removing exact poolAmountIn pool shares from the pool\n   * @param tokenOut tokenOut\n   * @param poolAmountIn amount of shares spent\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcSingleOutGivenPoolIn(\n    poolAddress: string,\n    tokenOut: string,\n    poolAmountIn: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcSingleOutPoolIn(\n          tokenOut,\n          await this.amountToUnits(poolAddress, poolAmountIn, poolDecimals)\n        )\n        .call()\n      amount = await this.unitsToAmount(tokenOut, result, tokenOutDecimals)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${e}`)\n    }\n    return amount\n  }\n\n  /**\n   * Returns number of poolshares needed to withdraw exact tokenAmountOut tokens\n   * @param tokenOut tokenOut\n   * @param tokenAmountOut expected amount of tokensOut\n   * @param {number} poolDecimals optional number of decimals of the pool\n   * @param {number} tokenOutDecimals optional number of decimals of the token\n   */\n  public async calcPoolInGivenSingleOut(\n    poolAddress: string,\n    tokenOut: string,\n    tokenAmountOut: string,\n    poolDecimals?: number,\n    tokenOutDecimals?: number\n  ): Promise<string> {\n    const pool = setContractDefaults(\n      new this.web3.eth.Contract(this.poolAbi, poolAddress),\n      this.config\n    )\n    let amount = null\n\n    try {\n      const result = await pool.methods\n        .calcPoolInSingleOut(\n          tokenOut,\n          await this.amountToUnits(tokenOut, tokenAmountOut, tokenOutDecimals)\n        )\n        .call()\n\n      amount = await this.unitsToAmount(poolAddress, result, poolDecimals)\n    } catch (e) {\n      LoggerInstance.error(\n        `ERROR: Failed to calculate PoolInGivenSingleOut : ${e.message}`\n      )\n    }\n    return amount\n  }\n\n  /**\n   * Get LOG_SWAP encoded topic\n   * @return {String}\n   */\n  public getSwapEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_SWAP' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_JOIN encoded topic\n   * @return {String}\n   */\n  public getJoinEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_JOIN' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n\n  /**\n   * Get LOG_EXIT encoded topic\n   * @return {String}\n   */\n  public getExitEventSignature(): string {\n    const abi = this.poolAbi as AbiItem[]\n    const eventdata = abi.find(function (o) {\n      if (o.name === 'LOG_EXIT' && o.type === 'event') return o\n    })\n    const topic = this.web3.eth.abi.encodeEventSignature(eventdata as any)\n    return topic\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Contract } from 'web3-eth-contract'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport defaultDispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport {\n  LoggerInstance as logger,\n  getFairGasPrice,\n  setContractDefaults,\n  ConfigHelper\n} from '../../utils/'\nimport { Datatoken } from '../../tokens'\nimport { Config } from '../../models/index.js'\n\nexport interface DispenserToken {\n  active: boolean\n  owner: string\n  maxTokens: string\n  maxBalance: string\n  balance: string\n  isMinter: boolean\n  allowedSwapper: string\n}\n\nexport class Dispenser {\n  public GASLIMIT_DEFAULT = 1000000\n  public web3: Web3 = null\n  public dispenserAddress: string\n  public config: Config\n  public dispenserAbi: AbiItem | AbiItem[]\n  public dispenserContract: Contract\n\n  /**\n   * Instantiate Dispenser\n   * @param {any} web3\n   * @param {String} dispenserAddress\n   * @param {any} dispenserABI\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    dispenserAddress: string = null,\n    dispenserAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.dispenserAddress = dispenserAddress\n    this.dispenserAbi = dispenserAbi || (defaultDispenserAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    if (web3)\n      this.dispenserContract = setContractDefaults(\n        new this.web3.eth.Contract(this.dispenserAbi, this.dispenserAddress),\n        this.config\n      )\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    try {\n      const result: DispenserToken = await this.dispenserContract.methods\n        .status(dtAdress)\n        .call()\n      result.maxTokens = this.web3.utils.fromWei(result.maxTokens)\n      result.maxBalance = this.web3.utils.fromWei(result.maxBalance)\n      result.balance = this.web3.utils.fromWei(result.balance)\n      return result\n    } catch (e) {\n      logger.warn(`No dispenser available for datatoken: ${dtAdress}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas cost for create method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  if !=0, only this address can request DTs\n   * @return {Promise<any>}\n   */\n  public async estGasCreate(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.dispenserContract.methods\n        .create(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance),\n          address,\n          allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async create(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreate(\n      dtAddress,\n      address,\n      maxTokens,\n      maxBalance,\n      allowedSwapper\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await this.dispenserContract.methods\n      .create(\n        dtAddress,\n        this.web3.utils.toWei(maxTokens),\n        this.web3.utils.toWei(maxBalance),\n        address,\n        allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for activate method\n   * @param {String} dtAddress\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasActivate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async activate(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasActivate(dtAddress, maxTokens, maxBalance, address)\n      const trxReceipt = await this.dispenserContract.methods\n        .activate(\n          dtAddress,\n          this.web3.utils.toWei(maxTokens),\n          this.web3.utils.toWei(maxBalance)\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for deactivate method\n   * @param {String} dtAddress\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<any>}\n   */\n  public async estGasDeactivate(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .deactivate(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async deactivate(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasDeactivate(dtAddress, address)\n      const trxReceipt = await this.dispenserContract.methods.deactivate(dtAddress).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for setAllowedSwapper method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasSetAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async setAllowedSwapper(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    try {\n      const estGas = await this.estGasSetAllowedSwapper(\n        dtAddress,\n        address,\n        newAllowedSwapper\n      )\n      const trxReceipt = await this.dispenserContract.methods\n        .setAllowedSwapper(dtAddress, newAllowedSwapper)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to activate dispenser: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for dispense method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasDispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async dispense(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasDispense(dtAddress, address, amount, destination)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .dispense(dtAddress, this.web3.utils.toWei(amount), destination)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to dispense tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Estimate gas for ownerWithdraw method\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<any>}\n   */\n  public async estGasOwnerWithdraw(dtAddress: string, address: string): Promise<any> {\n    let estGas\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    try {\n      estGas = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<TransactionReceipt>} TransactionReceipt\n   */\n  public async ownerWithdraw(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasOwnerWithdraw(dtAddress, address)\n    try {\n      const trxReceipt = await this.dispenserContract.methods\n        .ownerWithdraw(dtAddress)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      logger.error(`ERROR: Failed to withdraw tokens: ${e.message}`)\n    }\n    return null\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import defaultFixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils/types'\nimport Web3 from 'web3'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  amountToUnits,\n  unitsToAmount,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../../utils'\nimport { Config } from '../../models/index.js'\nimport { PriceAndFees } from '../..'\n\nexport interface FixedPriceExchange {\n  active: boolean\n  exchangeOwner: string\n  datatoken: string\n  baseToken: string\n  fixedRate: string\n  dtDecimals: string\n  btDecimals: string\n  dtBalance: string\n  btBalance: string\n  dtSupply: string\n  btSupply: string\n  withMint: boolean\n  allowedSwapper: string\n  exchangeId?: string\n}\n\nexport interface FeesInfo {\n  opcFee: string\n  marketFee: string\n  marketFeeCollector: string\n  marketFeeAvailable: string\n  oceanFeeAvailable: string\n  exchangeId: string\n}\nexport interface FixedPriceSwap {\n  exchangeId: string\n  caller: string\n  baseTokenAmount: string\n  datatokenAmount: string\n}\n\n/* eslint-disable no-unused-vars */\nexport enum FixedRateCreateProgressStep {\n  CreatingExchange,\n  ApprovingDatatoken\n}\n/* eslint-enable no-unused-vars */\n\nexport class FixedRateExchange {\n  public GASLIMIT_DEFAULT = 1000000\n  /** Ocean related functions */\n  public oceanAddress: string = null\n  public fixedRateAddress: string\n  public fixedRateExchangeAbi: AbiItem | AbiItem[]\n  public fixedRateContract: Contract\n  public web3: Web3\n  public contract: Contract = null\n\n  public config: Config\n  public ssAbi: AbiItem | AbiItem[]\n\n  /**\n   * Instantiate FixedRateExchange\n   * @param {any} web3\n   * @param {any} fixedRateExchangeAbi\n   */\n  constructor(\n    web3: Web3,\n    fixedRateAddress: string,\n    network?: string | number,\n    fixedRateExchangeAbi: AbiItem | AbiItem[] = null,\n    oceanAddress: string = null,\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.fixedRateExchangeAbi =\n      fixedRateExchangeAbi || (defaultFixedRateExchangeAbi.abi as AbiItem[])\n    this.oceanAddress = oceanAddress\n    this.fixedRateAddress = fixedRateAddress\n    this.contract = setContractDefaults(\n      new this.web3.eth.Contract(this.fixedRateExchangeAbi, this.fixedRateAddress),\n      this.config\n    )\n  }\n\n  async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Estimate gas cost for buyDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to buy\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee fee recieved by the consume market when a dt is bought from a fixed rate exchange, percent\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estBuyDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .buyDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async buyDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .buyDT(\n          exchangeId,\n          dtAmountFormatted,\n          maxBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Estimate gas cost for sellDT\n   * @param {String} account\n   * @param {String} dtAmount datatoken amount we want to sell\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSellDT(\n    account: string,\n    datatokenAddress: string,\n    dtAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string,\n    consumeMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .sellDT(\n          datatokenAddress,\n          dtAmount,\n          maxBaseTokenAmount,\n          consumeMarketAddress,\n          consumeMarketFee\n        )\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async sellDT(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0'\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await amountToUnits(\n      this.web3,\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await amountToUnits(\n      this.web3,\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await this.estBuyDT(\n      address,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    try {\n      const trxReceipt = await this.contract.methods\n        .sellDT(\n          exchangeId,\n          dtAmountFormatted,\n          minBtFormatted,\n          consumeMarketAddress,\n          consumeMarketFeeFormatted\n        )\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to sell datatokens: ${e.message}`)\n      return null\n    }\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetRate(\n    account: string,\n    exchangeId: string,\n    newRate: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, await this.web3.utils.toWei(newRate))\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setRate(\n    address: string,\n    exchangeId: string,\n    newRate: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(address, exchangeId, newRate)\n    const trxReceipt = await this.contract.methods\n      .setRate(exchangeId, this.web3.utils.toWei(newRate))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setRate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper new allowed swapper address\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetAllowedSwapper(\n    account: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .setRate(exchangeId, newAllowedSwapper)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setAllowedSwapper(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetAllowedSwapper(address, exchangeId, newAllowedSwapper)\n    const trxReceipt = await this.contract.methods\n      .setAllowedSwapper(exchangeId, newAllowedSwapper)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n\n    const estGas = await this.estActivate(address, exchangeId)\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivate(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleExchangeState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivate(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods.toggleExchangeState(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDTSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBTSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenOutDT - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenOutDT(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await unitsToAmount(\n        this.web3,\n        fixedRateExchange.baseToken,\n        result.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBTOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const result = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, result[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    result.dtDecimals = result.dtDecimals.toString()\n    result.btDecimals = result.btDecimals.toString()\n    result.dtBalance = await this.unitsToAmount(\n      result.datatoken,\n      result.dtBalance,\n      +result.dtDecimals\n    )\n    result.btBalance = await this.unitsToAmount(\n      result.baseToken,\n      result.btBalance,\n      +result.btDecimals\n    )\n    result.dtSupply = await this.unitsToAmount(\n      result.datatoken,\n      result.dtSupply,\n      +result.dtDecimals\n    )\n    result.btSupply = await this.unitsToAmount(\n      result.baseToken,\n      result.btSupply,\n      +result.btDecimals\n    )\n    result.fixedRate = this.web3.utils.fromWei(result.fixedRate)\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    result.opcFee = this.web3.utils.fromWei(result.opcFee.toString())\n    result.marketFee = this.web3.utils.fromWei(result.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    result.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    result.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      result.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    result.exchangeId = exchangeId\n    return result\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const result = await this.contract.methods.isActive(exchangeId).call()\n    return result\n  }\n\n  /**\n   * Estimate gas cost for activate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estActivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId, true)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async activateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await this.estActivateMint(address, exchangeId)\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, true)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for deactivate\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estDeactivateMint(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .toggleMintState(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async deactivateMint(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await this.estDeactivate(address, exchangeId)\n\n    const trxReceipt = await this.contract.methods\n      .toggleMintState(exchangeId, false)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectBT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectBT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n    try {\n      estGas = await fixedRate.methods\n        .collectBT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectBT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectBT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n    const trxReceipt = await this.contract.methods.collectBT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecDT\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectDT(\n    account: string,\n    exchangeId: string,\n    amount: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n    try {\n      estGas = await fixedRate.methods\n        .collectDT(exchangeId, amountWei)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to erc20.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectDT(\n    address: string,\n    exchangeId: string,\n    amount: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectDT(address, exchangeId, amount)\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n    const trxReceipt = await this.contract.methods.collectDT(exchangeId, amountWei).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collecMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectMarketFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectMarketFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectMarketFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectMarketFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for collectOceanFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estCollectOceanFee(\n    account: string,\n    exchangeId: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .collectMarketFee(exchangeId)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async collectOceanFee(\n    address: string,\n    exchangeId: string\n  ): Promise<TransactionReceipt> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.estCollectOceanFee(address, exchangeId)\n    const trxReceipt = await this.contract.methods.collectOceanFee(exchangeId).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.opcCollector().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPC Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  async getRouter(): Promise<string> {\n    let result = null\n    try {\n      result = await this.contract.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    let result = null\n    try {\n      result = await (await this.getExchange(exchangeId)).exchangeOwner\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get OPF Collector address: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFee\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFee(\n    account: string,\n    exchangeId: string,\n    newMarketFee: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFee(exchangeId, newMarketFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFee(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estSetRate(\n      address,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFee(exchangeId, this.web3.utils.toWei(newMarketFee))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for updateMarketFeeCollector\n   * @param {String} account\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estUpdateMarketFeeCollector(\n    account: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const fixedRate = contractInstance || this.fixedRateContract\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await fixedRate.methods\n        .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async updateMarketFeeCollector(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estUpdateMarketFeeCollector(\n      address,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    const trxReceipt = await this.contract.methods\n      .updateMarketFeeCollector(exchangeId, newMarketFeeCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils/types'\nimport { TransactionReceipt } from 'web3-core'\nimport { Contract } from 'web3-eth-contract'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  ConfigHelper,\n  unitsToAmount,\n  setContractDefaults\n} from '../../utils'\nimport SideStakingTemplate from '@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json'\nimport { Config } from '../../models'\n\nexport class SideStaking {\n  public ssAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public GASLIMIT_DEFAULT = 1000000\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    ssAbi: AbiItem | AbiItem[] = null,\n    config?: Config\n  ) {\n    if (ssAbi) this.ssAbi = ssAbi\n    else this.ssAbi = SideStakingTemplate.abi as AbiItem[]\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  private sideStakingContract(ssAddress: string) {\n    return setContractDefaults(\n      new this.web3.eth.Contract(this.ssAbi, ssAddress),\n      this.config\n    )\n  }\n\n  async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Get (total vesting amount + token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods\n        .getDatatokenCirculatingSupply(datatokenAddress)\n        .call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result.toString()\n  }\n\n  /**\n   * Get actual dts in circulation (vested token withdrawn from the contract +\n         token released from the contract when adding liquidity)\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getDatatokenCurrentCirculatingSupply(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    try {\n      const sideStaking = setContractDefaults(\n        new this.web3.eth.Contract(this.ssAbi, ssAddress),\n        this.config\n      )\n      let result = null\n      result = await sideStaking.methods\n        .getDatatokenCurrentCirculatingSupply(datatokenAddress)\n        .call()\n      return result.toString()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n  }\n\n  /**\n   * Get Publisher address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatoken address\n   * @return {String}\n   */\n  async getPublisherAddress(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPublisherAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseToken(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get Pool Address\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getPoolAddress(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getPoolAddress(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get baseToken balance in the contract\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getBaseTokenBalance(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getBaseTokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get dt balance in the staking contract available for being added as liquidity\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getDatatokenBalance(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getDatatokenBalance(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get block when vesting ends\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String} end block for vesting amount\n   */\n  async getvestingEndBlock(ssAddress: string, datatokenAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingEndBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get total amount vesting\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmount(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = new this.web3.eth.Contract(this.ssAbi, ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmount(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Get last block publisher got some vested tokens\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {String}\n   */\n  async getvestingLastBlock(\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingLastBlock(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    return result\n  }\n\n  /**\n   * Get how much has been taken from the vesting amount\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {number} tokenDecimals optional number of decimals of the token\n   * @return {String}\n   */\n  async getvestingAmountSoFar(\n    ssAddress: string,\n    datatokenAddress: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.getvestingAmountSoFar(datatokenAddress).call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get: ${e.message}`)\n    }\n    result = await this.unitsToAmount(datatokenAddress, result, tokenDecimals)\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estGetVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await sideStaking.methods\n        .getVesting(datatokenAddress)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async getVesting(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await this.estGetVesting(\n      account,\n      ssAddress,\n      datatokenAddress,\n      sideStaking\n    )\n    try {\n      result = await sideStaking.methods.getVesting(datatokenAddress).send({\n        from: account,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Estimate gas cost for getVesting\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<number>}\n   */\n  public async estSetPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number,\n    contractInstance?: Contract\n  ): Promise<number> {\n    const sideStaking = contractInstance || this.sideStakingContract(ssAddress)\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .estimateGas({ from: account }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Send vested tokens available to the publisher address, can be called by anyone\n   *\n   * @param {String} account\n   * @param {String} ssAddress side staking contract address\n   * @param {String} datatokenAddress datatokenAddress\n   * @return {TransactionReceipt}\n   */\n  async setPoolSwapFee(\n    account: string,\n    ssAddress: string,\n    datatokenAddress: string,\n    poolAddress: string,\n    swapFee: number\n  ): Promise<TransactionReceipt> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n\n    const estGas = await this.estSetPoolSwapFee(\n      account,\n      ssAddress,\n      datatokenAddress,\n      poolAddress,\n      swapFee,\n      sideStaking\n    )\n    try {\n      result = await sideStaking.methods\n        .setPoolSwapFee(datatokenAddress, poolAddress, swapFee)\n        .send({\n          from: account,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n    } catch (e) {\n      LoggerInstance.error('ERROR: Failed to join swap pool amount out')\n    }\n    return result\n  }\n\n  /**\n   * Get Router address set in side staking contract\n   * @param {String} ssAddress side staking contract address\n   * @return {String}\n   */\n  async getRouter(ssAddress: string): Promise<string> {\n    const sideStaking = this.sideStakingContract(ssAddress)\n    let result = null\n    try {\n      result = await sideStaking.methods.router().call()\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to get Router address: ${e.message}`)\n    }\n    return result\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { getFairGasPrice, setContractDefaults, ConfigHelper } from '../utils'\nimport { Operation } from '../@types/Router'\nimport { Config } from '../models/index.js'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router {\n  public GASLIMIT_DEFAULT = 1000000\n  public routerAddress: string\n  public RouterAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public router: Contract\n\n  /**\n   * Instantiate Router.\n   * @param {String} routerAddress\n   * @param {AbiItem | AbiItem[]} Router\n   * @param {Web3} web3\n   */\n  constructor(\n    routerAddress: string,\n    web3: Web3,\n    network?: string | number,\n    RouterAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.routerAddress = routerAddress\n    this.RouterAbi = RouterAbi || (defaultRouter.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.router = setContractDefaults(\n      new this.web3.eth.Contract(this.RouterAbi, this.routerAddress),\n      this.config\n    )\n  }\n\n  /**\n   * Estimate gas cost for buyDTBatch method\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async estGasBuyDTBatch(address: string, operations: Operation[]): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .buyDTBatch(operations)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * BuyDTBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<TransactionReceipt>} Transaction receipt\n   */\n  public async buyDTBatch(\n    address: string,\n    operations: Operation[]\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasBuyDTBatch(address, operations)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.buyDTBatch(operations).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.router.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a side staking contract.\n   * @return {Promise<boolean>} true if is a SS contract\n   */\n  public async isSideStaking(address: string): Promise<boolean> {\n    return await this.router.methods.isSSContract(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.router.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.router.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.router.methods.factory().call()\n  }\n\n  /** Check if an address is a pool template contract.\n   * @return {Promise<boolean>} true if is a Template\n   */\n  public async isPoolTemplate(address: string): Promise<boolean> {\n    return await this.router.methods.isPoolTemplate(address).call()\n  }\n\n  /**\n   * Estimate gas cost for addApprovedToken\n   * @param {String} address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ) {\n    const routerContract = contractInstance || this.router\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await routerContract.methods\n        .addApprovedToken(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new token to oceanTokens list, pools with baseToken in this list have NO opf Fee\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddApprovedToken(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeApprovedToken\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address we want to add\n   * @param {Contract} routerContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveApprovedToken(\n    address: string,\n    tokenAddress: string,\n    contractInstance?: Contract\n  ) {\n    const routerContract = contractInstance || this.router\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await routerContract.methods\n        .removeApprovedToken(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove a token from oceanTokens list, pools without baseToken in this list have a opf Fee\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeApprovedToken(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveApprovedToken(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeApprovedToken(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addSSContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddSSContract(address: string, tokenAddress: string): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addSSContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to ssContract list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddSSContract(address, tokenAddress)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeSSContract method\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeSSContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Removes a new contract from ssContract list\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to removed\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeSSContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveSSContract(address, tokenAddress)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.removeSSContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addFixedRateContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddFixedRateContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addFixedRateContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addFixedRateContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeFixedRateContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Removes a contract from fixedRate list\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeFixedRateContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveFixedRateContract(address, tokenAddress)\n\n    // Invoke removeFixedRateContract function of the contract\n    const trxReceipt = await this.router.methods\n      .removeFixedRateContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addDispenserContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddDispenserContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addDispenserContract(tokenAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addDispenserContract method\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemoveDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removeDispenserContract(tokenAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to dispenser list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removeDispenserContract(\n    address: string,\n    tokenAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemoveDispenserContract(address, tokenAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removeDispenserContract(tokenAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.router.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.router.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Estimate gas cost for updateOPFFee method\n   * @param {String} address\n   * @param {String} newFee new OPF Fee\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasUpdateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new contract to fixedRate list, after is added, can be used when deploying a new pool\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async updateOPCFee(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasUpdateOPCFee(\n      address,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .updateOPCFee(newSwapOceanFee, newSwapNonOceanFee, newConsumeFee, newProviderFee)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addPoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .addPoolTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new template to poolTemplates mapping, after template is added,it can be used\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addPoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasAddPoolTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods.addPoolTemplate(templateAddress).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removePoolTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasRemovePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.router.methods\n        .removePoolTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove template from poolTemplates mapping, after template is removed,it can be used anymore\n   * @param {String} address\n   * @param {String} templateAddress template address to remove\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async removePoolTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.estGasRemovePoolTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.router.methods\n      .removePoolTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport defaultNftAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  setContractDefaults,\n  ConfigHelper\n} from '../utils'\nimport { Contract } from 'web3-eth-contract'\nimport { MetadataProof } from '../../src/@types'\nimport { Config } from '../models/index.js'\nimport { MetadataAndTokenURI } from '../@types'\n\n/**\n * ERC721 ROLES\n */\ninterface Roles {\n  manager: boolean\n  deployERC20: boolean\n  updateMetadata: boolean\n  store: boolean\n}\n\nexport class Nft {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public nftAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public startBlock: number\n  public config: Config\n\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    nftAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.nftAbi = nftAbi || (defaultNftAbi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n  }\n\n  /**\n   *  Estimate gas cost for createERC20 token creation\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .createERC20(\n          templateIndex,\n          [name, symbol],\n          [minter, paymentCollector, mpFeeAddress, feeToken],\n          [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n          []\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new ERC20 datatoken - only user with ERC20Deployer permission can succeed\n   * @param {String} nftAddress ERC721 addreess\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the ERC20\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 datatoken address\n   */\n  public async createErc20(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number\n  ): Promise<string> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCreateErc20(\n      nftAddress,\n      address,\n      minter,\n      paymentCollector,\n      mpFeeAddress,\n      feeToken,\n      feeAmount,\n      cap,\n      name,\n      symbol,\n      templateIndex,\n      nftContract\n    )\n\n    // Call createERC20 token function of the contract\n    const trxReceipt = await nftContract.methods\n      .createERC20(\n        templateIndex,\n        [name, symbol],\n        [minter, paymentCollector, mpFeeAddress, feeToken],\n        [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n        []\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.TokenCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /**\n   * Estimate gas cost for add manager call\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasAddManager(nftAddress, address, manager, nftContract)\n\n    // Invoke addManager function of the contract\n    const trxReceipt = await nftContract.methods.addManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeManager method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveManager(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    contractInstance?: Contract\n  ) {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeManager(manager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeManager(nftAddress: string, address: string, manager: string) {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasRemoveManager(\n      nftAddress,\n      address,\n      manager,\n      nftContract\n    )\n\n    // Invoke removeManager function of the contract\n    const trxReceipt = await nftContract.methods.removeManager(manager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for addToCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToCreateERC20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer User adress which is going to have erc20Deployer permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await this.estGasAddErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Invoke addToCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .addToCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromCreateERC20List method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromCreateErc20List(erc20Deployer)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove ERC20Deployer permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} erc20Deployer Address of the user to be revoked ERC20Deployer Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeErc20Deployer(\n    nftAddress: string,\n    address: string,\n    erc20Deployer: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === erc20Deployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor ERC20Deployer`)\n    }\n    const estGas = await this.estGasRemoveErc20Deployer(\n      nftAddress,\n      address,\n      erc20Deployer,\n      nftContract\n    )\n\n    // Call removeFromCreateERC20List function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromCreateERC20List(erc20Deployer)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addToMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addToMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call addToMetadataList function of the contract\n    const trxReceipt = await nftContract.methods.addToMetadataList(metadataUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for removeFromMetadataList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async esGasRemoveMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFromMetadataList(metadataUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeMetadataUpdater(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await this.esGasRemoveMetadataUpdater(\n      nftAddress,\n      address,\n      metadataUpdater,\n      nftContract\n    )\n\n    // Call removeFromMetadataList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFromMetadataList(metadataUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTo725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .addTo725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async addStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await this.estGasAddStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call addTo725StoreList function of the contract\n    const trxReceipt = await nftContract.methods.addTo725StoreList(storeUpdater).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for removeFrom725StoreList method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .removeFrom725StoreList(storeUpdater)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removeStoreUpdater(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await this.estGasRemoveStoreUpdater(\n      nftAddress,\n      address,\n      storeUpdater,\n      nftContract\n    )\n\n    // Call removeFrom725StoreList function of the contract\n    const trxReceipt = await nftContract.methods\n      .removeFrom725StoreList(storeUpdater)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   *  Estimate gas cost for cleanPermissions method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    nftAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to remove all ROLES at erc721 level: Managers, ERC20Deployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at erc20 level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n\n  public async cleanPermissions(\n    nftAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await this.estGasCleanPermissions(nftAddress, address, nftContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await nftContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for transfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .transferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async transferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .transferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for safeTransfer NFT method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSafeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .safeTransferFrom(nftOwner, nftReceiver, tokenId)\n        .estimateGas({ from: nftOwner }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async safeTransferNft(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await this.estGasSafeTransferNft(\n      nftAddress,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier,\n      nftContract\n    )\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods\n      .safeTransferFrom(nftOwner, nftReceiver, tokenIdentifier)\n      .send({\n        from: nftOwner,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  // TODO: Finish this description\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {Number} metadataState User which will receive the NFT, will also be set as Manager\n   * @param {String} metadataDecryptorUrl\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadata(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    if (!metadataProofs) metadataProofs = []\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaData(\n          metadataState,\n          metadataDecryptorUrl,\n          metadataDecryptorAddress,\n          flags,\n          data,\n          metadataHash,\n          metadataProofs\n        )\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      LoggerInstance.error('estGasSetMetadata error: ', e.message)\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on erc721 and erc20 level.\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadata(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[]\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadata(\n      nftAddress,\n      address,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs,\n      nftContract\n    )\n    const trxReceipt = await nftContract.methods\n      .setMetaData(\n        metadataState,\n        metadataDecryptorUrl,\n        metadataDecryptorAddress,\n        flags,\n        data,\n        metadataHash,\n        metadataProofs\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadata  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} metadataUpdater metadataUpdater address\n   * @param {MetaDataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataAndTokenURI(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await this.estGasSetMetadataAndTokenURI(\n      nftAddress,\n      metadataUpdater,\n      metadataAndTokenURI,\n      nftContract\n    )\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const trxReceipt = await nftContract.methods\n      .setMetaDataAndTokenURI(sanitizedMetadataAndTokenURI)\n      .send({\n        from: metadataUpdater,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for setMetadataState  method\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {Number} metadataState new metadata state\n   * @param {Contract} nftContract optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetMetadataState(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataState: number,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const nftContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.nftAbi, nftAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setMetaDataState(metadataState)\n        .estimateGas({ from: metadataUpdater }, (err, estGas) =>\n          err ? gasLimitDefault : estGas\n        )\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setMetadataState(\n    nftAddress: string,\n    address: string,\n    metadataState: number\n  ): Promise<TransactionReceipt> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await this.estGasSetMetadataState(nftAddress, address, metadataState)\n\n    // Call transferFrom function of the contract\n    const trxReceipt = await nftContract.methods.setMetaDataState(metadataState).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for setTokenURI method\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estSetTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await nftContract.methods\n        .setTokenURI('1', data)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async setTokenURI(\n    nftAddress: string,\n    address: string,\n    data: string\n  ): Promise<any> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n\n    const estGas = await this.estSetTokenURI(nftAddress, address, data)\n    const trxReceipt = await nftContract.methods.setTokenURI('1', data).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n    return trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<Roles> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress erc721 contract adress\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users ERC20Deployer role\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async isErc20Deployer(nftAddress: string, address: string): Promise<boolean> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const isERC20Deployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.getData(key).call()\n    return data\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress erc721 contract adress\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = setContractDefaults(\n      new this.web3.eth.Contract(this.nftAbi, nftAddress),\n      this.config\n    )\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport { Contract } from 'web3-eth-contract'\nimport Decimal from 'decimal.js'\nimport defaultDatatokensAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport defaultDatatokensEnterpriseAbi from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  setContractDefaults,\n  getFreOrderParams,\n  ZERO_ADDRESS,\n  ConfigHelper,\n  allowance\n} from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../models/index.js'\n\n/**\n * ERC20 ROLES\n */\ninterface Roles {\n  minter: boolean\n  paymentManager: boolean\n}\n\nexport interface OrderParams {\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface DispenserParams {\n  maxTokens: string\n  maxBalance: string\n  withMint?: boolean // true if we want to allow the dispenser to be a minter\n  allowedSwapper?: string // only account that can ask tokens. set address(0) if not required\n}\n\nexport class Datatoken {\n  public GASLIMIT_DEFAULT = 1000000\n  public factoryAddress: string\n  public factoryABI: AbiItem | AbiItem[]\n  public datatokensAbi: AbiItem | AbiItem[]\n  public datatokensEnterpriseAbi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public nft: Nft\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    datatokensAbi?: AbiItem | AbiItem[],\n    datatokensEnterpriseAbi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.web3 = web3\n    this.datatokensAbi = datatokensAbi || (defaultDatatokensAbi.abi as AbiItem[])\n    this.datatokensEnterpriseAbi =\n      datatokensEnterpriseAbi || (defaultDatatokensEnterpriseAbi.abi as AbiItem[])\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasApprove(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for mint method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .approve(spender, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async approve(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasApprove(\n      dtAddress,\n      spender,\n      amount,\n      address,\n      dtContract\n    )\n\n    // Call mint contract method\n    const trxReceipt = await dtContract.methods\n      .approve(spender, this.web3.utils.toWei(amount))\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for mint method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasMint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Estimate gas cost for createFixedRate method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createFixedRate(\n          fixedRateParams.fixedRateAddress,\n          [\n            fixedRateParams.baseTokenAddress,\n            address,\n            fixedRateParams.marketFeeCollector,\n            fixedRateParams.allowedConsumer\n          ],\n          [\n            fixedRateParams.baseTokenDecimals,\n            fixedRateParams.datatokenDecimals,\n            fixedRateParams.fixedRate,\n            fixedRateParams.marketFee,\n            withMint\n          ]\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createFixedRate(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateFixedRate(\n      dtAddress,\n      address,\n      fixedRateParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createFixedRate(\n        fixedRateParams.fixedRateAddress,\n        [\n          fixedRateParams.baseTokenAddress,\n          fixedRateParams.owner,\n          fixedRateParams.marketFeeCollector,\n          fixedRateParams.allowedConsumer\n        ],\n        [\n          fixedRateParams.baseTokenDecimals,\n          fixedRateParams.datatokenDecimals,\n          fixedRateParams.fixedRate,\n          fixedRateParams.marketFee,\n          withMint\n        ]\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createDispenser method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCreateDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .createDispenser(\n          dispenserAddress,\n          dispenserParams.maxTokens,\n          dispenserParams.maxBalance,\n          dispenserParams.withMint,\n          dispenserParams.allowedSwapper\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async createDispenser(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    const estGas = await this.estGasCreateDispenser(\n      dtAddress,\n      address,\n      dispenserAddress,\n      dispenserParams,\n      dtContract\n    )\n\n    // Call createFixedRate contract method\n    const trxReceipt = await dtContract.methods\n      .createDispenser(\n        dispenserAddress,\n        dispenserParams.maxTokens,\n        dispenserParams.maxBalance,\n        dispenserParams.withMint,\n        dispenserParams.allowedSwapper\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n    return trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async mint(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.getDTPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await this.estGasMint(\n        dtAddress,\n        address,\n        amount,\n        toAddress,\n        dtContract\n      )\n\n      // Call mint contract method\n      const trxReceipt = await dtContract.methods\n        .mint(toAddress || address, this.web3.utils.toWei(amount))\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Estimate gas cost for addMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas cost for addMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add Minter for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await this.estGasAddMinter(dtAddress, address, minter, dtContract)\n\n    // Call addMinter function of the contract\n    const trxReceipt = await dtContract.methods.addMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removeMinter method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemoveMinter(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // should check ERC20Deployer role using erc721 level ..\n\n    // Estimate gas for removeMinter method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removeMinter(minter)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter(\n    dtAddress: string,\n    address: string,\n    minter: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemoveMinter(dtAddress, address, minter, dtContract)\n\n    // Call dtContract function of the contract\n    const trxReceipt = await dtContract.methods.removeMinter(minter).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for addPaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasAddPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for addFeeManager method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .addPaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async addPaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasAddPaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call addPaymentManager function of the contract\n    const trxReceipt = await dtContract.methods.addPaymentManager(paymentManager).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for removePaymentManager method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasRemovePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .removePaymentManager(paymentManager)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 datatoken\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async removePaymentManager(\n    dtAddress: string,\n    address: string,\n    paymentManager: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if ((await this.isERC20Deployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not ERC20Deployer`)\n    }\n\n    const estGas = await this.estGasRemovePaymentManager(\n      dtAddress,\n      address,\n      paymentManager,\n      dtContract\n    )\n\n    // Call removeFeeManager function of the contract\n    const trxReceipt = await dtContract.methods\n      .removePaymentManager(paymentManager)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas for setPaymentCollector method\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setPaymentCollector(paymentCollector)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<TransactionReceipt>} trxReceipt\n   */\n  public async setPaymentCollector(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isPaymentManager = (await this.getDTPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isErc20Deployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isErc20Deployer) {\n      throw new Error(`Caller is not Fee Manager, owner or erc20 Deployer`)\n    }\n\n    const estGas = await this.estGasSetPaymentCollector(\n      dtAddress,\n      address,\n      paymentCollector,\n      dtContract\n    )\n\n    // Call setFeeCollector method of the contract\n    const trxReceipt = await dtContract.methods\n      .setPaymentCollector(paymentCollector)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Estimate gas for transfer method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasTransfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .transfer(toAddress, amount)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async transferWei(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasTransfer(\n        dtAddress,\n        toAddress,\n        amount,\n        address,\n        dtContract\n      )\n      // Call transfer function of the contract\n      const trxReceipt = await dtContract.methods.transfer(toAddress, amount).send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to transfer tokens: ${e.message}`)\n      throw new Error(`Failed Failed to transfer tokens: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for startOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasStartOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async startOrder(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const publishMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const tokens = [\n      {\n        token: providerFees.providerFeeToken,\n        feeAmount: providerFees.providerFeeAmount\n      },\n      {\n        token: consumeMarketFee.consumeMarketFeeToken,\n        feeAmount: parseFloat(consumeMarketFee.consumeMarketFeeAmount)\n      },\n      {\n        token: publishMarketFee[1],\n        feeAmount: parseFloat(publishMarketFee[2])\n      }\n    ]\n\n    const uniqueTokens = []\n    tokens.map((address) => {\n      if (uniqueTokens.length > 0) {\n        uniqueTokens.map((uAddress) => {\n          if (uAddress.token === address.token) {\n            uAddress.feeAmount += address.feeAmount\n          } else {\n            uniqueTokens.push({\n              token: address.token,\n              feeAmount: address.feeAmount\n            })\n          }\n        })\n      } else {\n        uniqueTokens.push({\n          token: address.token,\n          feeAmount: address.feeAmount\n        })\n      }\n    })\n\n    const getCurrentAllownceTokens = uniqueTokens.map(async (token) => {\n      if (token.token === ZERO_ADDRESS || token.feeAmount === 0) return token\n      const currentAllowance = await allowance(this.web3, token.token, address, consumer)\n      if (\n        new Decimal(currentAllowance).greaterThanOrEqualTo(new Decimal(token.feeAmount))\n      ) {\n        LoggerInstance.error(`ERROR: Failed checking allowance: ${token.token}`)\n        throw new Error(`allowance (${currentAllowance}) is too low`)\n      } else {\n        token.currentAllowance = currentAllowance\n        return token\n      }\n    })\n\n    try {\n      const allownceTokens = await Promise.all(getCurrentAllownceTokens)\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed checking allowance : ${e}`)\n      throw new Error(`Failed checking allowance: ${e}`)\n    }\n\n    try {\n      const estGas = await this.estGasStartOrder(\n        dtAddress,\n        address,\n        consumer,\n        serviceIndex,\n        providerFees,\n        consumeMarketFee,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .startOrder(consumer, serviceIndex, providerFees, consumeMarketFee)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to start order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for reuseOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasReuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    // Estimate gas for reuseOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .reuseOrder(orderTxId, providerFees)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<TransactionReceipt>} string\n   */\n  public async reuseOrder(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasReuseOrder(\n        dtAddress,\n        address,\n        orderTxId,\n        providerFees,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .reuseOrder(orderTxId, providerFees)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to call reuse order order : ${e.message}`)\n      throw new Error(`Failed to start order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromFreAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const freContractParams = getFreOrderParams(freParams)\n\n      const estGas = await this.estGasBuyFromFreAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        freContractParams,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromFreAndOrder(orderParams, freContractParams)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas cost for buyFromFreAndOrder method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasBuyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress)\n\n    // Estimate gas for startOrder method\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async buyFromDispenserAndOrder(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string\n  ): Promise<TransactionReceipt> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensEnterpriseAbi, dtAddress),\n      this.config\n    )\n    try {\n      const estGas = await this.estGasBuyFromDispenserAndOrder(\n        dtAddress,\n        address,\n        orderParams,\n        dispenserContract,\n        dtContract\n      )\n\n      const trxReceipt = await dtContract.methods\n        .buyFromDispenserAndOrder(orderParams, dispenserContract)\n        .send({\n          from: address,\n          gas: estGas + 1,\n          gasPrice: await getFairGasPrice(this.web3, this.config)\n        })\n      return trxReceipt\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to buy DT From Fre And Order : ${e.message}`)\n      throw new Error(`Failed to buy DT From Fre And Order: ${e.message}`)\n    }\n  }\n\n  /** Estimate gas for setData method\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasSetData(\n    dtAddress: string,\n    address: string,\n    value: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .setData(value)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async setData(\n    dtAddress: string,\n    address: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if (!(await this.isERC20Deployer(dtAddress, address))) {\n      throw new Error(`User is not ERC20 Deployer`)\n    }\n\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasSetData(dtAddress, address, value, dtContract)\n\n    // Call setData function of the contract\n    const trxReceipt = await dtContract.methods.setData(value).send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas for cleanPermissions method\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async estGasCleanPermissions(\n    dtAddress: string,\n    address: string,\n    contractInstance?: Contract\n  ): Promise<any> {\n    const dtContract =\n      contractInstance ||\n      setContractDefaults(\n        new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n        this.config\n      )\n\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await dtContract.methods\n        .cleanPermissions()\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Clean erc20level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<TransactionReceipt>} transactionId\n   */\n  public async cleanPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n\n    const estGas = await this.estGasCleanPermissions(dtAddress, address, dtContract)\n\n    // Call cleanPermissions function of the contract\n    const trxReceipt = await dtContract.methods.cleanPermissions().send({\n      from: address,\n      gas: estGas + 1,\n      gasPrice: await getFairGasPrice(this.web3, this.config)\n    })\n\n    return trxReceipt\n  }\n\n  /** Returns ERC20 user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<Roles>}\n   */\n  public async getDTPermissions(dtAddress: string, address: string): Promise<Roles> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isERC20Deployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, dtAddress),\n      this.config\n    )\n    const isERC20Deployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isERC20Deployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = setContractDefaults(\n      new this.web3.eth.Contract(this.datatokensAbi, datatokenAddress, {\n        from: address\n      }),\n      this.config\n    )\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n}\n","import { Contract } from 'web3-eth-contract'\nimport Web3 from 'web3'\nimport { TransactionReceipt } from 'web3-core'\nimport { AbiItem } from 'web3-utils'\nimport defaultFactory721Abi from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  LoggerInstance,\n  getFairGasPrice,\n  generateDtName,\n  getFreCreationParams,\n  getErcCreationParams,\n  getPoolCreationParams,\n  setContractDefaults,\n  ZERO_ADDRESS,\n  ConfigHelper\n} from '../utils'\nimport { Config } from '../models/index.js'\nimport {\n  ProviderFees,\n  FreCreationParams,\n  Erc20CreateParams,\n  PoolCreationParams,\n  DispenserCreationParams,\n  ConsumeMarketFee\n} from '../@types/index.js'\n\ninterface Template {\n  templateAddress: string\n  isActive: boolean\n}\n\nexport interface TokenOrder {\n  tokenAddress: string\n  consumer: string\n  serviceIndex: number\n  _providerFee: ProviderFees\n  _consumeMarketFee: ConsumeMarketFee\n}\n\nexport interface NftCreateData {\n  name: string\n  symbol: string\n  templateIndex: number\n  tokenURI: string\n  transferable: boolean\n  owner: string\n}\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory {\n  public GASLIMIT_DEFAULT = 1000000\n  public factory721Address: string\n  public factory721Abi: AbiItem | AbiItem[]\n  public web3: Web3\n  public config: Config\n  public factory721: Contract\n\n  /**\n   * Instantiate Datatokens.\n   * @param {String} factory721Address\n   * @param {AbiItem | AbiItem[]} factory721ABI\n   * @param {Web3} web3\n   */\n  constructor(\n    factory721Address: string,\n    web3: Web3,\n    network?: string | number,\n    factory721Abi?: AbiItem | AbiItem[],\n    config?: Config\n  ) {\n    this.factory721Address = factory721Address\n    this.factory721Abi = factory721Abi || (defaultFactory721Abi.abi as AbiItem[])\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.factory721 = setContractDefaults(\n      new this.web3.eth.Contract(this.factory721Abi, this.factory721Address),\n      this.config\n    )\n  }\n\n  /**\n   * Get estimated gas cost for deployERC721Contract value\n   * @param {String} address\n   * @param {String} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async estGasCreateNFT(address: string, nftData: NftCreateData): Promise<string> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .deployERC721Contract(\n          nftData.name,\n          nftData.symbol,\n          nftData.templateIndex,\n          ZERO_ADDRESS,\n          ZERO_ADDRESS,\n          nftData.tokenURI,\n          nftData.transferable,\n          nftData.owner\n        )\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT(address: string, nftData: NftCreateData): Promise<string> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await this.estGasCreateNFT(address, nftData)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .deployERC721Contract(\n        nftData.name,\n        nftData.symbol,\n        nftData.templateIndex,\n        ZERO_ADDRESS,\n        ZERO_ADDRESS,\n        nftData.tokenURI,\n        nftData.transferable,\n        nftData.owner\n      )\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    let tokenAddress = null\n    try {\n      tokenAddress = trxReceipt.events.NFTCreated.returnValues[0]\n    } catch (e) {\n      LoggerInstance.error(`ERROR: Failed to create datatoken : ${e.message}`)\n    }\n    return tokenAddress\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentNFTCount().call()\n    return trxReceipt\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const trxReceipt = await this.factory721.methods.getCurrentTokenCount().call()\n    return trxReceipt\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const trxReceipt = await this.factory721.methods.owner().call()\n    return trxReceipt\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of ERC20 Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.factory721.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.factory721.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken(erc20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.factory721.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if ERC20 is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.factory721.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.factory721.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Estimate gas cost for add721TokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .add721TokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addNFTTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await this.estGasAddNFTTemplate(address, templateAddress)\n\n    // Invoke add721TokenTemplate function of the contract\n    const trxReceipt = await this.factory721.methods\n      .add721TokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disable721TokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disable721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await this.estGasDisableNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disable721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivate721TokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateNFTTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await this.estGasReactivateNFTTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivate721TokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for addTokenTemplate method\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async estGasAddTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .addTokenTemplate(templateAddress)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n\n    return estGas\n  }\n\n  /**\n   * Add a new erc721 token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<TransactionReceipt>}\n   */\n  public async addTokenTemplate(\n    address: string,\n    templateAddress: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await this.estGasAddTokenTemplate(address, templateAddress)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .addTokenTemplate(templateAddress)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for disableTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasDisableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .disableTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async disableTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await this.estGasDisableTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .disableTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for reactivateTokenTemplate method\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async estGasReactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .reactivateTokenTemplate(templateIndex)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<TransactionReceipt>} current token template count\n   */\n  public async reactivateTokenTemplate(\n    address: string,\n    templateIndex: number\n  ): Promise<TransactionReceipt> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await this.estGasReactivateTokenTemplate(address, templateIndex)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .reactivateTokenTemplate(templateIndex)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for startMultipleTokenOrder method\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasStartMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      estGas = await this.factory721.methods\n        .startMultipleTokenOrder(orders)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ erc20 contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - erc20 datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async startMultipleTokenOrder(\n    address: string,\n    orders: TokenOrder[]\n  ): Promise<TransactionReceipt> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await this.estGasStartMultipleTokenOrder(address, orders)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .startMultipleTokenOrder(orders)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftWithErc20 method\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async estGasCreateNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<any> {\n    // Get estimated gas value\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20(nftCreateData, ercCreateData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftWithErc20\n   *      Creates a new NFT, then a ERC20,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for erc20 creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n\n  public async createNftWithErc20(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    const estGas = await this.estGasCreateNftWithErc20(address, nftCreateData, ercParams)\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20(nftCreateData, ercCreateData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /**\n   * Estimate gas cost for createNftErc20WithPool method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n    try {\n      const ercCreateData = getErcCreationParams(ercParams)\n      const poolData = await getPoolCreationParams(this.web3, poolParams)\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithPool\n   *      Creates a new NFT, then a ERC20, then a Pool, all in one call\n   *      Use this carefully, because if Pool creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param poolParams input data for Pool Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithPool(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    poolParams: PoolCreationParams\n  ): Promise<TransactionReceipt> {\n    const estGas = await this.estGasCreateNftErc20WithPool(\n      address,\n      nftCreateData,\n      ercParams,\n      poolParams\n    )\n    const ercCreateData = getErcCreationParams(ercParams)\n    const poolData = await getPoolCreationParams(this.web3, poolParams)\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithPool(nftCreateData, ercCreateData, poolData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = await getFreCreationParams(freParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithFixedRate\n   *      Creates a new NFT, then a ERC20, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithFixedRate(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    freParams: FreCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n    const fixedData = getFreCreationParams(freParams)\n\n    const estGas = await this.estGasCreateNftErc20WithFixedRate(\n      address,\n      nftCreateData,\n      ercParams,\n      freParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithFixedRate(nftCreateData, ercCreateData, fixedData)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n\n  /** Estimate gas cost for createNftErc20WithFixedRate method\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   * @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async estGasCreateNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<any> {\n    const gasLimitDefault = this.GASLIMIT_DEFAULT\n    let estGas\n\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    try {\n      estGas = await this.factory721.methods\n        .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n        .estimateGas({ from: address }, (err, estGas) => (err ? gasLimitDefault : estGas))\n    } catch (e) {\n      estGas = gasLimitDefault\n      LoggerInstance.error('Failed to estimate gas for createNftErc20WithDispenser', e)\n    }\n    return estGas\n  }\n\n  /**\n   * @dev createNftErc20WithDispenser\n   *      Creates a new NFT, then a ERC20, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param ercParams input data for ERC20 Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftErc20WithDispenser(\n    address: string,\n    nftCreateData: NftCreateData,\n    ercParams: Erc20CreateParams,\n    dispenserParams: DispenserCreationParams\n  ): Promise<TransactionReceipt> {\n    const ercCreateData = getErcCreationParams(ercParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await this.estGasCreateNftErc20WithDispenser(\n      address,\n      nftCreateData,\n      ercParams,\n      dispenserParams\n    )\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await this.factory721.methods\n      .createNftWithErc20WithDispenser(nftCreateData, ercCreateData, dispenserParams)\n      .send({\n        from: address,\n        gas: estGas + 1,\n        gasPrice: await getFairGasPrice(this.web3, this.config)\n      })\n\n    return trxReceipt\n  }\n}\n","import { LogLevel } from '../utils/Logger'\nimport { AbiItem } from 'web3-utils/types'\n\nexport class ContractConfig {\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  public transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  public transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  public transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  public gasFeeMultiplier: number\n}\n\nexport class Config extends ContractConfig {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public erc721FactoryAddress?: string\n\n  /**\n   * Factory ABI\n   * @type {string}\n   */\n  public erc721FFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool Template address\n   * @type {string}\n   */\n  public poolTemplateAddress?: string\n\n  /**\n   * Pool Factory ABI\n   * @type {string}\n   */\n  public poolFactoryABI?: AbiItem | AbiItem[]\n\n  /**\n   * Pool ABI\n   * @type {string}\n   */\n  public poolABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, rinkeby, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n}\n\nexport default Config\n","import { LoggerInstance } from './Logger'\n\nexport const zeroX = (input: string): string => zeroXTransformer(input, true)\nexport const noZeroX = (input: string): string => zeroXTransformer(input, false)\nexport function zeroXTransformer(input = '', zeroOutput: boolean): string {\n  const { valid, output } = inputMatch(input, /^(?:0x)*([a-f0-9]+)$/i, 'zeroXTransformer')\n  return (zeroOutput && valid ? '0x' : '') + output\n}\n\n// Shared functions\nfunction inputMatch(\n  input: string,\n  regexp: RegExp,\n  conversorName: string\n): { valid: boolean; output: string } {\n  if (typeof input !== 'string') {\n    LoggerInstance.debug('Not input string:')\n    LoggerInstance.debug(input)\n    throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n  }\n  const match = input.match(regexp)\n  if (!match) {\n    LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n    return { valid: false, output: input }\n  }\n  return { valid: true, output: match[1] }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance, getData } from '../utils'\nimport {\n  FileMetadata,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize\n} from '../@types/'\nimport { noZeroX } from '../utils/ConversionTypeHelper'\nimport fetch from 'cross-fetch'\nexport interface HttpCallback {\n  (httpMethod: string, url: string, body: string, header: any): Promise<any>\n}\n\nexport interface ServiceEndpoint {\n  serviceName: string\n  method: string\n  urlPath: string\n}\nexport interface UserCustomParameters {\n  [key: string]: any\n}\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      return null\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {\n          'Content-Type': 'application/octet-stream'\n        },\n        signal: signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did: did, serviceId: serviceId }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileMetadata[]>} urlDetails\n   */\n  public async checkFileUrl(\n    url: string,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<FileMetadata[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { url: url, type: 'url' }\n    const files: FileMetadata[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: FileMetadata[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      return null\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e.message)\n      return null\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute start failed: ', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      return null\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    console.log('computeResult providerEndpoints: ', providerEndpoints)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    console.log('computeResult serviceEndpoints: ', serviceEndpoints)\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n}\n\nexport const ProviderInstance = new Provider()\nexport default ProviderInstance\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\nimport LoggerInstance from './Logger'\n\nexport function generateDid(erc721Address: string, chainId: number): string {\n  erc721Address = Web3.utils.toChecksumAddress(erc721Address)\n  const checksum = sha256(erc721Address + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  try {\n    return sha256(data).toString()\n  } catch (e) {\n    LoggerInstance.error('getHash error: ', e.message)\n  }\n}\n","import Web3 from 'web3'\nimport { LoggerInstance } from './Logger'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n"],"names":["LogLevel","Logger","logLevel","Error","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","log","Log","warn","Warn","error","verb","level","console","LoggerInstance","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","minAbi","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","ZERO_ADDRESS","amountToUnits","web3","token","amount","tokenDecimals","decimals","BigNumber","config","EXPONENTIAL_AT","times","exponentiatedBy","toString","tokenContract","eth","Contract","methods","call","e","message","unitsToAmount","amountFormatted","div","getPoolCreationParams","poolParams","ssContract","baseTokenAddress","baseTokenSender","publisherAddress","marketFeeCollector","poolTemplateAddress","vestedBlocks","Web3","utils","toWei","vestingAmount","baseTokenDecimals","rate","initialBaseTokenLiquidity","addresses","ssParams","swapFees","swapFeeLiquidityProvider","swapFeeMarketRunner","getFairGasPrice","getGasPrice","x","gasFeeMultiplier","multipliedBy","integerValue","ROUND_DOWN","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","getErcCreationParams","ercParams","templateIndex","strings","minter","paymentCollector","mpFeeAddress","feeToken","uints","cap","feeAmount","bytess","getFreOrderParams","freParams","exchangeContract","exchangeId","maxBaseTokenAmount","swapMarketFee","marketFeeAddress","getFreCreationParams","allowedConsumer","withMint","fixedPriceAddress","fixedRateAddress","owner","datatokenDecimals","fixedRate","marketFee","postData","getData","url","fetch","method","headers","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","erc721FactoryAddress","ERC721Factory","sideStakingAddress","Staking","opfCommunityFeeCollector","OPFCommunityFeeCollector","poolTemplate","FixedPrice","Dispenser","Ocean","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","balance","allowance","tokenAddress","account","spender","trxReceipt","estApprove","contractInstance","estGas","gasLimitDefault","approve","estimateGas","from","err","sleep","ms","Promise","resolve","setTimeout","getMaxRemoveLiquidity","poolInstance","poolAddress","getReserve","calcMaxExactIn","getMaxAddLiquidity","getMaxSwapExactIn","getMaxSwapExactOut","calcMaxExactOut","Decimal","bind","pact","_settle","result","Aquarius","aquariusURL","did","signal","path","response","ok","json","status","waitForAqua","txid","tries","_this4","ddo","event","validate","jsonResponse","valid","_this6","body","JSON","stringify","hash","proof","validatorAddress","publicKey","r","s","v","errors","recover","MaxUint256","Pool","poolAbi","GASLIMIT_DEFAULT","PoolTemplate","abi","sharesBalance","balanceOf","fromWei","estSetSwapFee","fee","poolContract","defaultErc20Abi","_this8","setSwapFee","pool","_this10","_pool$methods$setSwap2","send","gas","gasPrice","getNumTokens","_this12","getPoolSharesTotalSupply","_this14","totalSupply","getCurrentTokens","_this16","getFinalTokens","_this18","getController","_this20","getBaseToken","_this22","getBaseTokenAddress","getDatatoken","_this24","getDatatokenAddress","getMarketFee","_this26","getMarketFeeCollector","_this28","_publishMarketCollector","getOPCCollector","_this30","_opcCollector","isBound","_this32","_this34","getBalance","isFinalized","_this36","getSwapFee","_this38","getNormalizedWeight","_this40","weight","getDenormalizedWeight","_this42","getTotalDenormalizedWeight","_this44","getMarketFees","_this46","publishMarketFees","getCurrentMarketFees","_this48","getCurrentOPCFees","_this50","getCommunityFees","_this52","communityFees","estCollectOPC","address","_this54","collectOPC","_this56","_pool$methods$collect2","estCollectMarketFee","_this58","collectMarketFee","_this60","_this59$getMarketFeeC","_pool$methods$collect4","estUpdatePublishMarketFee","newPublishMarketAddress","newPublishMarketSwapFee","_this62","updatePublishMarketFee","_this64","_this63$getMarketFeeC","_pool$methods$updateP2","estSwapExactAmountIn","tokenInOutMarket","amountsInOutMaxFee","_this66","tokenIn","tokenAmountIn","tokenInDecimals","tokenOut","minAmountOut","tokenOutDecimals","maxPrice","_amountsInOutMaxFee$m","swapExactAmountIn","_this68","maxSwap","greaterThan","_pool$methods$swapExa2","estSwapExactAmountOut","_this70","maxAmountIn","tokenAmountOut","swapExactAmountOut","_this72","_amountsInOutMaxFee$m4","_pool$methods$swapExa4","estJoinswapExternAmountIn","minPoolAmountOut","_this74","joinswapExternAmountIn","_this76","amountInFormatted","_pool$methods$joinswa2","estExitswapPoolAmountIn","poolAmountIn","minTokenAmountOut","_this78","exitswapPoolAmountIn","_this80","calcSingleOutGivenPoolIn","minTokenOutFormatted","_pool$methods$exitswa2","getSpotPrice","decimalsDiff","decimalsTokenIn","decimalsTokenOut","price","_this82","tokenOutContract","tokenInContract","getAmountInExactOut","_this84","amountOutFormatted","lpFeeAmount","oceanFeeAmount","publishMarketSwapFeeAmount","consumeMarketSwapFeeAmount","tokenAmount","liquidityProviderSwapFeeAmount","getAmountOutExactIn","_this86","calcPoolOutGivenSingleIn","poolDecimals","_this88","_pool$methods","calcPoolOutSingleIn","_calcPoolOutSingleIn","calcSingleInGivenPoolOut","poolAmountOut","_this90","calcSingleInPoolOut","_this92","_pool$methods2","calcSingleOutPoolIn","_calcSingleOutPoolIn","calcPoolInGivenSingleOut","_this94","_pool$methods3","calcPoolInSingleOut","_calcPoolInSingleOut","getSwapEventSignature","eventdata","o","encodeEventSignature","getJoinEventSignature","getExitEventSignature","FixedRateCreateProgressStep","dispenserAbi","dispenserContract","defaultDispenserAbi","dtAdress","_this2","maxTokens","maxBalance","_exit2","logger","estGasCreate","dtAddress","allowedSwapper","create","_this5$dispenserContr","estGasActivate","activate","_this9$dispenserContr","estGasDeactivate","deactivate","_this13$dispenserCont","estGasSetAllowedSwapper","newAllowedSwapper","setAllowedSwapper","_this17$dispenserCont","estGasDispense","destination","dispense","_this21$dispenserCont","estGasOwnerWithdraw","ownerWithdraw","_this25$dispenserCont","isDispensable","datatoken","active","greaterThanOrEqualTo","String","isMinter","FixedRateExchange","fixedRateExchangeAbi","oceanAddress","fixedRateContract","ssAbi","defaultFixedRateExchangeAbi","generateExchangeId","baseToken","estBuyDT","datatokenAddress","dtAmount","consumeMarketAddress","consumeMarketFee","buyDT","datatokenAmount","getExchange","exchange","consumeMarketFeeFormatted","dtDecimals","dtAmountFormatted","btDecimals","maxBtFormatted","_this9$contract$metho","estSellDT","sellDT","minBaseTokenAmount","minBtFormatted","_this13$contract$meth","getNumberOfExchanges","estSetRate","newRate","_fixedRate$methods","setRate","_setRate","_this19$contract$meth","estSetAllowedSwapper","_this23$contract$meth","estActivate","toggleExchangeState","_this27$contract$meth","estDeactivate","_this31$contract$meth","getRate","weiRate","getDTSupply","dtSupply","getBTSupply","btSupply","getAllowedSwapper","calcBaseInGivenOutDT","fixedRateExchange","_this41$contract$meth","_calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","consumeMarketFeeAmount","getAmountBTOut","_this43$contract$meth","calcBaseOutGivenInDT","_calcBaseOutGivenInDT","dtBalance","btBalance","getFeesInfo","opcFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","estActivateMint","toggleMintState","activateMint","_this55$contract$meth","estDeactivateMint","deactivateMint","_this59$contract$meth","estCollectBT","fixedrate","amountWei","collectBT","_this63$contract$meth","estCollectDT","collectDT","_this67$contract$meth","_this71$contract$meth","estCollectOceanFee","collectOceanFee","_this75$contract$meth","opcCollector","getRouter","router","getExchangeOwner","_this81$getExchange","exchangeOwner","estUpdateMarketFee","newMarketFee","updateMarketFee","_this85$contract$meth","estUpdateMarketFeeCollector","newMarketFeeCollector","updateMarketFeeCollector","_this89$contract$meth","SideStaking","SideStakingTemplate","sideStakingContract","ssAddress","getDatatokenCirculatingSupply","sideStaking","getDatatokenCurrentCirculatingSupply","getPublisherAddress","getPoolAddress","getBaseTokenBalance","getDatatokenBalance","getvestingEndBlock","getvestingAmount","getvestingLastBlock","getvestingAmountSoFar","estGetVesting","getVesting","_sideStaking$methods$14","estSetPoolSwapFee","swapFee","setPoolSwapFee","_sideStaking$methods$17","Router","routerAddress","RouterAbi","defaultRouter","estGasBuyDTBatch","operations","buyDTBatch","_this3$router$methods","isApprovedToken","isSideStaking","isSSContract","isFixedPrice","isFixedRateContract","getOwner","routerOwner","getNFTFactory","factory","isPoolTemplate","estGasAddApprovedToken","routerContract","addApprovedToken","_this19$getOwner","_this19$router$method","estGasRemoveApprovedToken","removeApprovedToken","_this23$getOwner","_this23$router$method","estGasAddSSContract","addSSContract","_this27$getOwner","_this27$router$method","estGasRemoveSSContract","removeSSContract","_this31$getOwner","_this31$router$method","estGasAddFixedRateContract","addFixedRateContract","_this35$getOwner","_this35$router$method","estGasRemoveFixedRateContract","removeFixedRateContract","_this39$getOwner","_this39$router$method","estGasAddDispenserContract","addDispenserContract","_this43$getOwner","_this43$router$method","estGasRemoveDispenserContract","removeDispenserContract","_this47$getOwner","_this47$router$method","getOPCFee","getCurrentOPCFee","swapOceanFee","estGasUpdateOPCFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","_this55$getOwner","_this55$router$method","estGasAddPoolTemplate","templateAddress","addPoolTemplate","_this59$getOwner","_this59$router$method","estGasRemovePoolTemplate","removePoolTemplate","_this63$getOwner","_this63$router$method","Nft","nftAbi","factory721Address","factory721Abi","defaultNftAbi","estGasCreateErc20","nftAddress","nftContract","createERC20","createErc20","getNftPermissions","_this3$getNftPermissi","deployERC20","_nftContract$methods$2","events","TokenCreated","returnValues","estGasAddManager","manager","addManager","getNftOwner","_this7$getNftOwner","_nftContract$methods$4","estGasRemoveManager","removeManager","_this11$getNftOwner","_nftContract$methods$6","estGasAddErc20Deployer","erc20Deployer","addToCreateERC20List","addErc20Deployer","_this15$getNftPermiss","_nftContract$methods$8","estGasRemoveErc20Deployer","removeFromCreateErc20List","removeErc20Deployer","_temp11","_this19$getNftPermiss2","removeFromCreateERC20List","_nftContract$methods$10","_this19$getNftPermiss","estGasAddMetadataUpdater","metadataUpdater","addToMetadataList","addMetadataUpdater","_this23$getNftPermiss","_nftContract$methods$12","esGasRemoveMetadataUpdater","removeFromMetadataList","removeMetadataUpdater","_temp17","_this27$getNftPermiss2","updateMetadata","_nftContract$methods$14","_this27$getNftPermiss","estGasAddStoreUpdater","storeUpdater","addTo725StoreList","addStoreUpdater","_this31$getNftPermiss","_nftContract$methods$16","estGasRemoveStoreUpdater","removeFrom725StoreList","removeStoreUpdater","_temp23","_this35$getNftPermiss2","store","_nftContract$methods$18","_this35$getNftPermiss","estGasCleanPermissions","cleanPermissions","_this39$getNftOwner","_nftContract$methods$20","estGasTransferNft","nftOwner","nftReceiver","tokenId","transferFrom","transferNft","_this43$getNftOwner","tokenIdentifier","_nftContract$methods$22","estGasSafeTransferNft","safeTransferFrom","safeTransferNft","_this47$getNftOwner","_nftContract$methods$24","estGasSetMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","data","metadataHash","metadataProofs","setMetaData","setMetadata","_this51$getNftPermiss","_nftContract$methods$26","estGasSetMetadataAndTokenURI","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataAndTokenURI","_this55$getNftPermiss","_nftContract$methods$28","estGasSetMetadataState","setMetaDataState","setMetadataState","_this59$getNftPermiss","_nftContract$methods$30","estSetTokenURI","setTokenURI","_nftContract$methods$32","ownerOf","getPermissions","getMetadata","getMetaData","isErc20Deployer","isERC20Deployer","key","getTokenURI","id","tokenURI","Datatoken","datatokensAbi","datatokensEnterpriseAbi","factoryAddress","factoryABI","nft","defaultDatatokensAbi","defaultDatatokensEnterpriseAbi","estGasApprove","dtContract","_dtContract$methods$a2","estGasMint","toAddress","mint","estGasCreateFixedRate","fixedRateParams","createFixedRate","_dtContract$methods$c2","estGasCreateDispenser","dispenserParams","createDispenser","_dtContract$methods$c4","getDTPermissions","_this15$getDTPermissi","getCap","capAvailble","gte","_dtContract$methods$m2","estGasAddMinter","addMinter","_this19$isERC20Deploy","_dtContract$methods$a4","estGasRemoveMinter","removeMinter","_this23$isERC20Deploy","_dtContract$methods$r2","estGasAddPaymentManager","paymentManager","addPaymentManager","_this27$isERC20Deploy","_dtContract$methods$a6","estGasRemovePaymentManager","removePaymentManager","_this31$isERC20Deploy","_dtContract$methods$r4","estGasSetPaymentCollector","setPaymentCollector","nftPermissions","isPaymentManager","isNftOwner","_dtContract$methods$s2","_this35$nft$getNftOwn","_this35$getDTPermissi","getNFTAddress","getPaymentCollector","transfer","weiAmount","transferWei","estGasTransfer","_dtContract$methods$t2","estGasStartOrder","consumer","serviceIndex","providerFees","startOrder","consumeMarketFeeAddress","consumeMarketFeeToken","getPublishingMarketFee","publishMarketFee","_dtContract$methods$s4","tokens","providerFeeToken","providerFeeAmount","parseFloat","uniqueTokens","map","uAddress","push","getCurrentAllownceTokens","currentAllowance","all","estGasReuseOrder","orderTxId","reuseOrder","_dtContract$methods$r6","estGasBuyFromFreAndOrder","orderParams","buyFromFreAndOrder","freContractParams","_dtContract$methods$b2","estGasBuyFromDispenserAndOrder","buyFromDispenserAndOrder","_dtContract$methods$b4","estGasSetData","value","setData","_dtContract$methods$s6","_this67$nft2","_this67$nft$getNftOwn","_dtContract$methods$c6","permissions","getDecimals","getERC721Address","NftFactory","factory721","defaultFactory721Abi","estGasCreateNFT","nftData","deployERC721Contract","transferable","createNFT","getCurrentNFTTemplateCount","_nftData$templateInde2","getNFTTemplate","_this3$getNFTTemplate","_this3$factory721$met","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTokenTemplateCount","getCurrentTemplateCount","index","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","estGasAddNFTTemplate","add721TokenTemplate","addNFTTemplate","_this25$getOwner","_this25$factory721$me","estGasDisableNFTTemplate","disable721TokenTemplate","disableNFTTemplate","_this29$getOwner","_this29$factory721$me","estGasReactivateNFTTemplate","reactivate721TokenTemplate","reactivateNFTTemplate","_this33$getOwner","_this33$factory721$me","estGasAddTokenTemplate","addTokenTemplate","_this37$getOwner","_this37$factory721$me","estGasDisableTokenTemplate","disableTokenTemplate","_this41$getOwner","_this41$getTokenTempl","_this41$factory721$me","estGasReactivateTokenTemplate","reactivateTokenTemplate","_this45$getOwner","_this45$getTokenTempl","_this45$factory721$me","estGasStartMultipleTokenOrder","orders","startMultipleTokenOrder","_this49$factory721$me","estGasCreateNftWithErc20","nftCreateData","ercCreateData","createNftWithErc20","_this53$factory721$me","estGasCreateNftErc20WithPool","poolData","createNftWithErc20WithPool","createNftErc20WithPool","_this57$factory721$me","estGasCreateNftErc20WithFixedRate","fixedData","createNftWithErc20WithFixedRate","createNftErc20WithFixedRate","_this61$factory721$me","estGasCreateNftErc20WithDispenser","createNftWithErc20WithDispenser","createNftErc20WithDispenser","_this65$factory721$me","ContractConfig","Config","providerAddress","web3Provider","erc721FFactoryABI","datatokensABI","poolFactoryABI","poolABI","fixedRateExchangeAddressABI","dispenserABI","verbose","authMessage","authTokenExpiration","parityUri","threshold","noZeroX","input","zeroOutput","regexp","conversorName","match","output","inputMatch","zeroXTransformer","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","i","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","signProviderRequest","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","sign","encrypt","text","checkDidFiles","serviceId","args","files","results","checkFileUrl","getComputeEnvironments","_this10$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","algorithm","additionalDatasets","computeStartUrl","signatureMessage","documentId","payload","Object","environment","statusText","params","computeStop","jobId","computeStopUrl","computeStatus","computeStatusUrl","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","isValidProvider","ProviderInstance","force","_tokenContract$method3","filename","get","split","pop","arrayBuffer","anchor","document","createElement","download","href","click","opts","_error2","erc721Address","toChecksumAddress","sha256","postWithHeaders","signedMessage","substr","slice"],"mappings":"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"}