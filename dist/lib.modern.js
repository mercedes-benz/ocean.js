import t from"web3";import e from"bignumber.js";import a from"cross-fetch";import s from"@oceanprotocol/contracts/addresses/address.json";import i from"crypto-js/sha256";import n from"decimal.js";import o from"@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json";import r from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json";import c from"@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json";import h from"@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json";import l from"@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json";import d from"@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json";import w from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json";import u from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json";import m from"@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json";var g;!function(t){t[t.None=-1]="None",t[t.Error=0]="Error",t[t.Warn=1]="Warn",t[t.Log=2]="Log",t[t.Verbose=3]="Verbose"}(g||(g={}));class p{constructor(t=g.Error){this.logLevel=void 0,this.logLevel=t}setLevel(t){this.logLevel=t}bypass(...t){this.dispatch("log",-Infinity,...t)}debug(...t){this.dispatch("debug",g.Verbose,...t)}log(...t){this.dispatch("log",g.Log,...t)}warn(...t){this.dispatch("warn",g.Warn,...t)}error(...t){this.dispatch("error",g.Error,...t)}dispatch(t,e,...a){this.logLevel>=e&&console[t](...a)}}const f=new p;var y={nouns:["Crab","Fish","Seal","Octopus","Shark","Seahorse","Walrus","Starfish","Whale","Orca","Penguin","Jellyfish","Squid","Lobster","Pelican","Shrimp","Oyster","Clam","Seagull","Dolphin","Shell","Cormorant","Otter","Anemone","Turtle","Coral","Ray","Barracuda","Krill","Anchovy","Angelfish","Barnacle","Clownfish","Cod","Cuttlefish","Eel","Fugu","Herring","Haddock","Ling","Mackerel","Manatee","Narwhal","Nautilus","Plankton","Porpoise","Prawn","Pufferfish","Swordfish","Tuna"],adjectives:["adamant","adroit","amatory","ambitious","amused","animistic","antic","arcadian","artistic","astonishing","astounding","baleful","bellicose","bilious","blissful","boorish","brave","breathtaking","brilliant","calamitous","caustic","cerulean","clever","charming","comely","competent","concomitant","confident","contumacious","corpulent","crapulous","creative","dazzling","dedicated","defamatory","delighted","delightful","determined","didactic","dilatory","dowdy","efficacious","effulgent","egregious","empowered","endemic","enthusiastic","equanimous","exceptional","execrable","fabulous","fantastic","fastidious","feckless","fecund","friable","fulsome","garrulous","generous","gentle","guileless","gustatory","heuristic","histrionic","hubristic","incendiary","incredible","insidious","insolent","inspired","intransigent","inveterate","invidious","invigorated","irksome","jejune","juicy","jocular","joyful","judicious","kind","lachrymose","limpid","loquacious","lovely","luminous","mannered","marvelous","mendacious","meretricious","minatory","mordant","motivated","munificent","nefarious","noxious","obtuse","optimistic","parsimonious","pendulous","pernicious","pervasive","petulant","passionate","phenomenal","platitudinous","pleasant","powerful","precipitate","propitious","puckish","querulous","quiescent","rebarbative","recalcitant","redolent","rhadamanthine","risible","ruminative","sagacious","salubrious","sartorial","sclerotic","serpentine","smart","spasmodic","strident","stunning","stupendous","taciturn","tactful","tasty","tenacious","tremendous","tremulous","trenchant","turbulent","turgid","ubiquitous","uxorious","verdant","vibrant","voluble","voracious","wheedling","withering","wonderful","zealous"]};function b(t){const e=t||y,a=Math.floor(Math.random()*e.adjectives.length),s=Math.floor(Math.random()*e.nouns.length),i=Math.floor(100*Math.random()),n=e.adjectives[a].replace(/^\w/,t=>t.toUpperCase()),o=e.nouns[s].replace(/^\w/,t=>t.toUpperCase());return{name:`${n} ${o} Token`,symbol:`${(n.substring(0,3)+o.substring(0,3)).toUpperCase()}-${i}`}}const A=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}],T="0x0000000000000000000000000000000000000000",E=1e6;function C(t,e){return e&&(e.transactionBlockTimeout&&(t.transactionBlockTimeout=e.transactionBlockTimeout),e.transactionConfirmationBlocks&&(t.transactionConfirmationBlocks=e.transactionConfirmationBlocks),e.transactionPollingTimeout&&(t.transactionPollingTimeout=e.transactionPollingTimeout)),t}async function R(t,a){const s=new e(await t.eth.getGasPrice());return a&&a.gasFeeMultiplier?s.multipliedBy(a.gasFeeMultiplier).integerValue(e.ROUND_DOWN).toString(10):s.toString(10)}function F(e){let a,s;return e.name&&e.symbol||({name:a,symbol:s}=b()),{templateIndex:e.templateIndex,strings:[e.name||a,e.symbol||s],addresses:[e.minter,e.paymentCollector,e.mpFeeAddress,e.feeToken],uints:[t.utils.toWei(e.cap),t.utils.toWei(e.feeAmount)],bytess:[]}}function k(e){return{exchangeContract:e.exchangeContract,exchangeId:e.exchangeId,maxBaseTokenAmount:t.utils.toWei(e.maxBaseTokenAmount),swapMarketFee:t.utils.toWei(e.swapMarketFee),marketFeeAddress:e.marketFeeAddress}}function v(e){e.allowedConsumer||(e.allowedConsumer=T);const a=e.withMint?1:0;return{fixedPriceAddress:e.fixedRateAddress,addresses:[e.baseTokenAddress,e.owner,e.marketFeeCollector,e.allowedConsumer],uints:[e.baseTokenDecimals,e.datatokenDecimals,t.utils.toWei(e.fixedRate),t.utils.toWei(e.marketFee),a]}}async function S(e,a){return{addresses:[a.ssContract,a.baseTokenAddress,a.baseTokenSender,a.publisherAddress,a.marketFeeCollector,a.poolTemplateAddress],ssParams:[t.utils.toWei(a.rate),a.baseTokenDecimals,t.utils.toWei(a.vestingAmount),a.vestedBlocks,await G(e,a.baseTokenAddress,a.initialBaseTokenLiquidity)],swapFees:[t.utils.toWei(a.swapFeeLiquidityProvider),t.utils.toWei(a.swapFeeMarketRunner)]}}async function I(t,a,s){try{const i=new t.eth.Contract(A,a);let n=await i.methods.decimals().call();"0"===n&&(n=18);const o=new e(s).div(new e(10).exponentiatedBy(n));return e.config({EXPONENTIAL_AT:50}),o.toString()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${t.message}`)}}async function G(t,a,s){try{const i=new t.eth.Contract(A,a);let n=await i.methods.decimals().call();return"0"===n&&(n=18),e.config({EXPONENTIAL_AT:50}),new e(s).times(new e(10).exponentiatedBy(n)).toString()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${t.message}`)}}async function P(t,e){const s=await a(t,e);if(!s.ok)throw f.error(`Error requesting [${e.method}] ${t}`),f.error(`Response message: \n${await s.text()}`),s;return s}async function M(t){const e=document.createElement("a");e.download="",e.href=t,e.click()}async function O(t,e){const s=await a(t);if(!s.ok)throw new Error("Response error.");let i;try{i=s.headers.get("content-disposition").match(/attachment;filename=(.+)/)[1]}catch(a){try{i=t.split("/").pop()}catch(t){i=`file${e}`}}return{data:await s.arrayBuffer(),filename:i}}async function L(t){return a(t,{method:"GET",headers:{"Content-type":"application/json"}})}async function D(t,e){return async function(t,e,s){return a(t,null!=e?{method:"POST",body:e,headers:{"Content-type":"application/json"}}:{method:"POST"})}(t,e)}function U(){return U=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&(t[s]=a[s])}return t},U.apply(this,arguments)}const x={chainId:null,network:"unknown",metadataCacheUri:"https://v4.aquarius.oceanprotocol.com",nodeUri:"http://127.0.0.1:8545",providerUri:"http://127.0.0.1:8030",subgraphUri:null,explorerUri:null,oceanTokenAddress:null,oceanTokenSymbol:"OCEAN",poolTemplateAddress:null,fixedRateExchangeAddress:null,dispenserAddress:null,startBlock:0,transactionBlockTimeout:50,transactionConfirmationBlocks:1,transactionPollingTimeout:750,gasFeeMultiplier:1},N=[U({},x),U({},x,{chainId:8996,network:"development",metadataCacheUri:"http://127.0.0.1:5000",providerUri:"http://172.15.0.4:8030"}),U({},x,{chainId:3,network:"ropsten",nodeUri:"https://ropsten.infura.io/v3",providerUri:"https://v4.provider.ropsten.oceanprotocol.com",subgraphUri:"https://v4.subgraph.ropsten.oceanprotocol.com",explorerUri:"https://ropsten.etherscan.io",gasFeeMultiplier:1.1}),U({},x,{chainId:4,network:"rinkeby",nodeUri:"https://rinkeby.infura.io/v3",providerUri:"https://v4.provider.rinkeby.oceanprotocol.com",subgraphUri:"https://v4.subgraph.rinkeby.oceanprotocol.com",explorerUri:"https://rinkeby.etherscan.io",gasFeeMultiplier:1.1}),U({},x,{chainId:1,network:"mainnet",nodeUri:"https://mainnet.infura.io/v3",providerUri:"https://v4.provider.mainnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mainnet.oceanprotocol.com",explorerUri:"https://etherscan.io",startBlock:11105459,transactionBlockTimeout:150,transactionConfirmationBlocks:5,transactionPollingTimeout:1750,gasFeeMultiplier:1.05}),U({},x,{chainId:137,network:"polygon",nodeUri:"https://polygon-mainnet.infura.io/v3",providerUri:"https://v4.provider.polygon.oceanprotocol.com",subgraphUri:"https://v4.subgraph.polygon.oceanprotocol.com",explorerUri:"https://polygonscan.com",oceanTokenSymbol:"mOCEAN"}),U({},x,{chainId:1287,network:"moonbase",nodeUri:"https://rpc.api.moonbase.moonbeam.network",providerUri:"https://v4.provider.moonbase.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonbase.oceanprotocol.com",explorerUri:"https://moonbase.moonscan.io/",gasFeeMultiplier:1.1}),U({},x,{chainId:2021e3,network:"gaiaxtestnet",nodeUri:"https://rpc.gaiaxtestnet.oceanprotocol.com",providerUri:"https://v4.provider.gaiaxtestnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.gaiaxtestnet.oceanprotocol.com",explorerUri:"https://blockscout.gaiaxtestnet.oceanprotocol.com"}),U({},x,{chainId:80001,network:"mumbai",nodeUri:"https://polygon-mumbai.infura.io/v3",providerUri:"https://v4.provider.mumbai.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mumbai.oceanprotocol.com",explorerUri:"https://mumbai.polygonscan.com",gasFeeMultiplier:1.1}),U({},x,{chainId:56,network:"bsc",nodeUri:"https://bsc-dataseed.binance.org",providerUri:"https://v4.provider.bsc.oceanprotocol.com",subgraphUri:"https://v4.subgraph.bsc.oceanprotocol.com",explorerUri:"https://bscscan.com/",gasFeeMultiplier:1.05}),U({},x,{chainId:246,network:"energyweb",nodeUri:"https://rpc.energyweb.org",providerUri:"https://v4.provider.energyweb.oceanprotocol.com",subgraphUri:"https://v4.subgraph.energyweb.oceanprotocol.com",explorerUri:"https://explorer.energyweb.org",gasFeeMultiplier:1.05}),U({},x,{chainId:1285,network:"moonriver",nodeUri:"https://moonriver.api.onfinality.io/public",providerUri:"https://v4.provider.moonriver.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonriver.oceanprotocol.com",explorerUri:"https://moonriver.moonscan.io/",gasFeeMultiplier:1.05})];class ${getAddressesFromEnv(t,e){let a;if(e)try{const{FixedPrice:s,Dispenser:i,Staking:n,poolTemplate:o,ERC721Factory:r,OPFCommunityFeeCollector:c,Ocean:h,chainId:l,startBlock:d}=e[t];a=U({erc721FactoryAddress:r,sideStakingAddress:n,opfCommunityFeeCollector:c,poolTemplateAddress:o,fixedRateExchangeAddress:s,dispenserAddress:i,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}catch(t){}else if(s[t]){const{FixedPrice:e,Dispenser:i,Staking:n,poolTemplate:o,OPFCommunityFeeCollector:r,ERC721Factory:c,Ocean:h,chainId:l,startBlock:d}=s[t];a=U({erc721FactoryAddress:c,sideStakingAddress:n,opfCommunityFeeCollector:r,poolTemplateAddress:o,fixedRateExchangeAddress:e,dispenserAddress:i,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}return a}getConfig(t,e){const a="string"==typeof t?"network":"chainId";let s=N.find(e=>e[a]===t);return s?(s=U({},s,this.getAddressesFromEnv(s.network)),U({},s,{nodeUri:e?`${s.nodeUri}/${e}`:s.nodeUri})):(f.error(`No config found for given network '${t}'`),null)}}function W(e,a){return e=t.utils.toChecksumAddress(e),`did:op:${i(e+a.toString(10)).toString()}`}function _(t){try{return i(t).toString()}catch(t){f.error("getHash error: ",t.message)}}async function B(t,e,a){let s=await t.eth.sign(e,a);s=s.substr(2);const i="0x"+s.slice(0,64),n="0x"+s.slice(64,128);let o="0x"+s.slice(128,130);return"0x00"===o&&(o="0x1b"),"0x01"===o&&(o="0x1c"),{v:o,r:i,s:n}}async function j(t,e,a,s,i,n){const o=n||new t.eth.Contract(A,a),r=1e6;let c;try{c=await o.methods.approve(s,i).estimateGas({from:e},(t,e)=>t?r:e)}catch(t){c=r,f.error("estimate gas failed for approve!",t)}return c}async function q(t,e,a,s,i,o=!1,r){const c=C(new t.eth.Contract(A,a),r);if(!o){const o=await z(t,a,e,s,r);if(new n(o).greaterThanOrEqualTo(new n(i)))return o}let h=null;const l=await G(t,a,i),d=await j(t,e,a,s,l,c);try{h=await c.methods.approve(s,l).send({from:e,gas:d+1,gasPrice:await R(t,r)})}catch(t){f.error(`ERRPR: Failed to approve spender to spend tokens : ${t.message}`)}return h}async function z(t,e,a,s,i){const n=C(new t.eth.Contract(A,e),i),o=await n.methods.allowance(a,s).call();return await I(t,e,o)}async function J(t,e,a,s){const i=C(new t.eth.Contract(A,e),s),n=await i.methods.balanceOf(a).call();return await I(t,e,n)}async function V(t){return new Promise(e=>{setTimeout(e,t)})}function H(t){return new n(t).div(3.01)}function Z(t){return new n(t).div(2.01)}async function X(t,e,a){return H(await t.getReserve(e,a))}async function Q(t,e,a){return Z(await t.getReserve(e,a))}async function K(t,e,a){return Z(await t.getReserve(e,a))}async function Y(t,e,a){return Z(await t.getReserve(e,a))}class tt{constructor(t){this.aquariusURL=void 0,this.aquariusURL=t}async resolve(t,e){const s=this.aquariusURL+"/api/aquarius/assets/ddo/"+t;try{const t=await a(s,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(t.ok)return await t.json();throw new Error("HTTP request failed with status "+t.status)}catch(t){throw f.error(t),new Error("HTTP request failed")}}async waitForAqua(t,e,s){let i=0;do{try{const i=this.aquariusURL+"/api/aquarius/assets/ddo/"+t,n=await a(i,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});if(n.ok){const t=await n.json();if(!e)return t;if(t.event&&t.event.txid===e)return t}}catch(t){}await V(1500),i++}while(i<100);return null}async validate(t,e){const s={valid:!1};let i;try{const n=this.aquariusURL+"/api/aquarius/assets/ddo/validate",o=await a(n,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:e});i=await o.json(),200===o.status?(s.valid=!0,s.hash=i.hash,s.proof={validatorAddress:i.publicKey,r:i.r[0],s:i.s[0],v:i.v}):(s.errors=i,f.error("validate Metadata failed:",o.status,s.errors))}catch(t){f.error("Error validating metadata: ",t)}return s}}const et="115792089237316195423570985008687907853269984665640564039457584007913129639934";class at{constructor(t,e=null,a){this.poolAbi=void 0,this.web3=void 0,this.GASLIMIT_DEFAULT=1e6,this.config=void 0,this.poolAbi=e||o.abi,this.web3=t,this.config=a||N[0]}async sharesBalance(t,e){let a=null;try{const s=C(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=await s.methods.balanceOf(t).call();a=this.web3.utils.fromWei(i)}catch(t){f.error(`ERROR: Failed to get shares of pool : ${t.message}`)}return a}async estSetSwapFee(t,e,a,s){const i=s||C(new this.web3.eth.Contract(r.abi,e),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setSwapFee(a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setSwapFee(t,e,a){const s=C(new this.web3.eth.Contract(this.poolAbi,e,{from:t}),this.config);let i=null;const n=await this.estSetSwapFee(t,e,a);try{i=await s.methods.setSwapFee(this.web3.utils.toWei(a)).send({from:t,gas:n,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to set pool swap fee: ${t.message}`)}return i}async getNumTokens(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getNumTokens().call()}catch(t){f.error(`ERROR: Failed to get number of tokens: ${t.message}`)}return a}async getPoolSharesTotalSupply(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.totalSupply().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get total supply of pool shares: ${t.message}`)}return a}async getCurrentTokens(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getCurrentTokens().call()}catch(t){f.error(`ERROR: Failed to get tokens composing this pool: ${t.message}`)}return a}async getFinalTokens(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getFinalTokens().call()}catch(t){f.error(`ERROR: Failed to get the final tokens composing this pool ${t.message}`)}return a}async getController(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getController().call()}catch(t){f.error(`ERROR: Failed to get pool controller address: ${t.message}`)}return a}async getBaseToken(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getBaseTokenAddress().call()}catch(t){f.error(`ERROR: Failed to get baseToken address: ${t.message}`)}return a}async getDatatoken(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getDatatokenAddress().call()}catch(t){f.error(`ERROR: Failed to get datatoken address: ${t.message}`)}return a}async getMarketFee(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getMarketFee().call()}catch(t){f.error(`ERROR: Failed to get getMarketFee: ${t.message}`)}return this.web3.utils.fromWei(a).toString()}async getMarketFeeCollector(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods._publishMarketCollector().call()}catch(t){f.error(`ERROR: Failed to get marketFeeCollector address: ${t.message}`)}return a}async getOPCCollector(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods._opcCollector().call()}catch(t){f.error(`ERROR: Failed to get OPF Collector address: ${t.message}`)}return a}async isBound(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{s=await a.methods.isBound(e).call()}catch(t){f.error(`ERROR: Failed to check whether a token       bounded to a pool. ${t.message}`)}return s}async getReserve(t,e){let a=null;try{const s=C(new this.web3.eth.Contract(this.poolAbi,t),this.config),i=await s.methods.getBalance(e).call();a=await I(this.web3,e,i)}catch(t){f.error(`ERROR: Failed to get how many tokens       are in the pool: ${t.message}`)}return a.toString()}async isFinalized(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.isFinalized().call()}catch(t){f.error(`ERROR: Failed to check whether pool is finalized: ${t.message}`)}return a}async getSwapFee(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getSwapFee().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get pool fee: ${t.message}`)}return a}async getNormalizedWeight(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getNormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get normalized weight of a token: ${t.message}`)}return s}async getDenormalizedWeight(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getDenormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get denormalized weight of a token in pool ${t.message}`)}return s}async getTotalDenormalizedWeight(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getTotalDenormalizedWeight().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get total denormalized weight in pool ${t.message}`)}return a}async getMarketFees(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.publishMarketFees(e).call();s=await I(this.web3,e,t)}catch(t){f.error(`ERROR: Failed to get market fees for a token: ${t.message}`)}return s}async getCurrentMarketFees(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCurrentOPCFees(t){const e=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCommunityFees(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.communityFees(e).call();s=await I(this.web3,e,t)}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}return s}async estCollectOPC(t,e,a){const s=a||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectOPC().estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectOPC(t,e){const a=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const i=await this.estCollectOPC(t,e);try{s=await a.methods.collectOPC().send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estCollectMarketFee(t,e,a){const s=a||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee().estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectMarketFee(t,e){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const a=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const i=await this.estCollectMarketFee(t,e);try{s=await a.methods.collectMarketFee().send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estUpdatePublishMarketFee(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.updatePublishMarketFee(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async updatePublishMarketFee(t,e,a,s){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let n=null;const o=await this.estUpdatePublishMarketFee(t,e,a,this.web3.utils.toWei(s));try{n=await i.methods.updatePublishMarketFee(a,this.web3.utils.toWei(s)).send({from:t,gas:o+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to updatePublishMarketFee : ${t.message}`)}return n}async estSwapExactAmountIn(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await G(this.web3,a.tokenIn,s.tokenAmountIn),r=await G(this.web3,a.tokenOut,s.minAmountOut),c=s.maxPrice?G(this.web3,await this.getBaseToken(e),s.maxPrice):et,h=this.GASLIMIT_DEFAULT;let l;try{l=await n.methods.swapExactAmountIn([a.tokenIn,a.tokenOut,a.marketFeeAddress],[o,r,c,this.web3.utils.toWei(s.swapMarketFee)]).estimateGas({from:t},(t,e)=>t?h:e)}catch(t){l=h}return l}async swapExactAmountIn(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await Q(this,e,a.tokenIn);if(new n(s.tokenAmountIn).greaterThan(o))throw new Error(`tokenAmountIn is greater than ${o.toString()}`);const r=await this.estSwapExactAmountIn(t,e,a,s),c=await G(this.web3,a.tokenIn,s.tokenAmountIn),h=await G(this.web3,a.tokenOut,s.minAmountOut);let l=null;const d=s.maxPrice?await G(this.web3,await this.getBaseToken(e),s.maxPrice):et;try{l=await i.methods.swapExactAmountIn([a.tokenIn,a.tokenOut,a.marketFeeAddress],[c,h,d,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:r+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return l}async estSwapExactAmountOut(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT,r=await G(this.web3,a.tokenIn,s.maxAmountIn),c=await G(this.web3,a.tokenOut,s.tokenAmountOut),h=s.maxPrice?await G(this.web3,await this.getBaseToken(e),s.maxPrice):et;let l;try{l=await n.methods.swapExactAmountOut([a.tokenIn,a.tokenOut,a.marketFeeAddress],[r,c,h,this.web3.utils.toWei(s.swapMarketFee)]).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){l=o}return l}async swapExactAmountOut(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await X(this,e,a.tokenIn);if(new n(s.tokenAmountOut).greaterThan(r))throw new Error(`tokenAmountOut is greater than ${r.toString()}`);const c=await this.estSwapExactAmountOut(t,e,a,s),h=await G(this.web3,a.tokenIn,s.maxAmountIn),l=await G(this.web3,a.tokenOut,s.tokenAmountOut),d=s.maxPrice?G(this.web3,await this.getBaseToken(e),s.maxPrice):et;try{o=await i.methods.swapExactAmountOut([a.tokenIn,a.tokenOut,a.marketFeeAddress],[h,l,d,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:c+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount out: ${t.message}`)}return o}async estJoinPool(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.joinPool(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async joinPool(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config),n=[],o=await this.getFinalTokens(e);for(let t=0;t<2;t++){const e=await G(this.web3,o[t],s[t]);n.push(e)}let r=null;const c=await this.estJoinPool(t,e,this.web3.utils.toWei(a),n);try{r=await i.methods.joinPool(this.web3.utils.toWei(a),n).send({from:t,gas:c+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to join pool: ${t.message}`)}return r}async estExitPool(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.exitPool(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async exitPool(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config),n=[],o=await this.getFinalTokens(e);for(let t=0;t<2;t++){const e=await G(this.web3,o[t],s[t]);n.push(e)}let r=null;const c=await this.estExitPool(t,e,this.web3.utils.toWei(a),n);try{r=await i.methods.exitPool(this.web3.utils.toWei(a),n).send({from:t,gas:c,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to exit pool: ${t.message}`)}return r}async estJoinswapExternAmountIn(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.joinswapExternAmountIn(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async joinswapExternAmountIn(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await this.getBaseToken(e),c=await K(this,e,r);if(new n(a).greaterThan(c))throw new Error(`tokenAmountOut is greater than ${c.toString()}`);const h=await G(this.web3,r,a),l=await this.estJoinswapExternAmountIn(t,e,h,this.web3.utils.toWei(s));try{o=await i.methods.joinswapExternAmountIn(h,this.web3.utils.toWei(s)).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to pay tokens in order to       join the pool: ${t.message}`)}return o}async estExitswapPoolAmountIn(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.exitswapPoolAmountIn(a,s).estimateGas({from:t},(t,e)=>t?o:e)}catch(t){r=o}return r}async exitswapPoolAmountIn(t,e,a,s){const i=C(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await this.getBaseToken(e),c=await this.calcSingleOutGivenPoolIn(e,r,a),h=await Y(this,e,r);if(new n(c).greaterThan(h))throw new Error(`tokenAmountOut is greater than ${h.toString()}`);const l=await G(this.web3,await this.getBaseToken(e),s),d=await this.estExitswapPoolAmountIn(t,e,this.web3.utils.toWei(a),l);try{o=await i.methods.exitswapPoolAmountIn(this.web3.utils.toWei(a),l).send({from:t,gas:d+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to pay pool shares into the pool: ${t.message}`)}return o}async getSpotPrice(t,a,s,i){const n=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=18,c=18;const h=C(new this.web3.eth.Contract(r.abi,a),this.config),l=C(new this.web3.eth.Contract(r.abi,s),this.config);try{o=await h.methods.decimals().call()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}try{c=await l.methods.decimals().call()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}let d,w=null;try{w=await n.methods.getSpotPrice(a,s,this.web3.utils.toWei(i)).call(),w=new e(w.toString())}catch(t){f.error("ERROR: Failed to get spot price of swapping tokenIn to tokenOut")}return o>c?(d=o-c,w=new e(w/10**d),w/=10**c):(d=c-o,w=new e(w*10**(2*d)),w/=10**c),w.toString()}async getAmountInExactOut(t,e,a,s,i){const o=C(new this.web3.eth.Contract(this.poolAbi,t),this.config),r=await X(this,t,e);if(new n(s).greaterThan(r))throw new Error(`tokenAmountOut is greater than ${r.toString()}`);const c=await G(this.web3,a,s);let h=null;try{const t=await o.methods.getAmountInExactOut(e,a,c,this.web3.utils.toWei(i)).call();h={tokenAmount:await I(this.web3,a,t.tokenAmountIn),liquidityProviderSwapFeeAmount:await I(this.web3,e,t.lpFeeAmount),oceanFeeAmount:await I(this.web3,e,t.oceanFeeAmount),publishMarketSwapFeeAmount:await I(this.web3,e,t.publishMarketSwapFeeAmount),consumeMarketSwapFeeAmount:await I(this.web3,e,t.consumeMarketSwapFeeAmount)}}catch(t){f.error(`ERROR: Failed to calcInGivenOut ${t.message}`)}return h}async getAmountOutExactIn(t,e,a,s,i){const o=C(new this.web3.eth.Contract(this.poolAbi,t),this.config),r=await Q(this,t,e);if(new n(s).greaterThan(r))throw new Error(`tokenAmountIn is greater than ${r.toString()}`);const c=await G(this.web3,e,s);let h=null;try{const t=await o.methods.getAmountOutExactIn(e,a,c,this.web3.utils.toWei(i)).call();h={tokenAmount:await I(this.web3,a,t.tokenAmountOut),liquidityProviderSwapFeeAmount:await I(this.web3,e,t.lpFeeAmount),oceanFeeAmount:await I(this.web3,e,t.oceanFeeAmount),publishMarketSwapFeeAmount:await I(this.web3,e,t.publishMarketSwapFeeAmount),consumeMarketSwapFeeAmount:await I(this.web3,e,t.consumeMarketSwapFeeAmount)}}catch(t){f.error(`ERROR: Failed to calcOutGivenIn ${t.message}`)}return h}async calcPoolOutGivenSingleIn(t,e,a){const s=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcPoolOutSingleIn(e,await G(this.web3,e,a)).call();i=await I(this.web3,t,n)}catch(t){f.error(`ERROR: Failed to calculate PoolOutGivenSingleIn : ${t.message}`)}return i}async calcSingleInGivenPoolOut(t,e,a){const s=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;const n=await G(this.web3,t,a);try{const t=await s.methods.calcSingleInPoolOut(e,n).call();i=await I(this.web3,e,t)}catch(t){f.error(`ERROR: Failed to calculate SingleInGivenPoolOut : ${t.message}`)}return i}async calcSingleOutGivenPoolIn(t,e,a){const s=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcSingleOutPoolIn(e,await G(this.web3,t,a)).call();i=await I(this.web3,e,n)}catch(t){f.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${t}`)}return i}async calcPoolInGivenSingleOut(t,e,a){const s=C(new this.web3.eth.Contract(this.poolAbi,t),this.config);let i=null;try{const n=await s.methods.calcPoolInSingleOut(e,await G(this.web3,e,a)).call();i=await I(this.web3,t,n)}catch(t){f.error(`ERROR: Failed to calculate PoolInGivenSingleOut : ${t.message}`)}return i}getSwapEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_SWAP"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getJoinEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_JOIN"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getExitEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_EXIT"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}}class st{constructor(t,e=null,a=null,s){this.GASLIMIT_DEFAULT=1e6,this.web3=null,this.dispenserAddress=void 0,this.config=void 0,this.dispenserAbi=void 0,this.dispenserContract=void 0,this.web3=t,this.dispenserAddress=e,this.dispenserAbi=a||c.abi,this.config=s||N[0],t&&(this.dispenserContract=C(new this.web3.eth.Contract(this.dispenserAbi,this.dispenserAddress),this.config))}async status(t){try{const e=await this.dispenserContract.methods.status(t).call();return e.maxTokens=this.web3.utils.fromWei(e.maxTokens),e.maxBalance=this.web3.utils.fromWei(e.maxBalance),e.balance=this.web3.utils.fromWei(e.balance),e}catch(e){f.warn(`No dispenser available for datatoken: ${t}`)}return null}async estGasCreate(t,e,a,s,i){const n=this.GASLIMIT_DEFAULT;let o;try{o=await this.dispenserContract.methods.create(t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,i).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async create(t,e,a,s,i){const n=await this.estGasCreate(t,e,a,s,i);return await this.dispenserContract.methods.create(t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,i).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasActivate(t,e,a,s){let i;const n=this.GASLIMIT_DEFAULT;try{i=await this.dispenserContract.methods.activate(t,this.web3.utils.toWei(e),this.web3.utils.toWei(a)).estimateGas({from:s},(t,e)=>t?n:e)}catch(t){i=n}return i}async activate(t,e,a,s){try{const i=await this.estGasActivate(t,e,a,s);return await this.dispenserContract.methods.activate(t,this.web3.utils.toWei(e),this.web3.utils.toWei(a)).send({from:s,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDeactivate(t,e){let a;const s=this.GASLIMIT_DEFAULT;try{a=await this.dispenserContract.methods.deactivate(t).estimateGas({from:e},(t,e)=>t?s:e)}catch(t){a=s}return a}async deactivate(t,e){try{const a=await this.estGasDeactivate(t,e);return await this.dispenserContract.methods.deactivate(t).send({from:e,gas:a+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasSetAllowedSwapper(t,e,a){let s;const i=this.GASLIMIT_DEFAULT;try{s=await this.dispenserContract.methods.setAllowedSwapper(t,a).estimateGas({from:e},(t,e)=>t?i:e)}catch(t){s=i}return s}async setAllowedSwapper(t,e,a){try{const s=await this.estGasSetAllowedSwapper(t,e,a);return await this.dispenserContract.methods.setAllowedSwapper(t,a).send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDispense(t,e,a="1",s){let i;const n=this.GASLIMIT_DEFAULT;try{i=await this.dispenserContract.methods.dispense(t,this.web3.utils.toWei(a),s).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){i=n}return i}async dispense(t,e,a="1",s){const i=await this.estGasDispense(t,e,a,s);try{return await this.dispenserContract.methods.dispense(t,this.web3.utils.toWei(a),s).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to dispense tokens: ${t.message}`)}return null}async estGasOwnerWithdraw(t,e){let a;const s=this.GASLIMIT_DEFAULT;try{a=await this.dispenserContract.methods.ownerWithdraw(t).estimateGas({from:e},(t,e)=>t?s:e)}catch(t){a=s}return a}async ownerWithdraw(t,e){const a=await this.estGasOwnerWithdraw(t,e);try{return await this.dispenserContract.methods.ownerWithdraw(t).send({from:e,gas:a+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to withdraw tokens: ${t.message}`)}return null}async isDispensable(t,e,a,s="1"){const i=await this.status(t);return!(!i||!1===i.active||new n(await e.balance(t,a)).greaterThanOrEqualTo(i.maxBalance)||new n(String(s)).greaterThan(i.maxTokens)||!new n(i.balance).greaterThanOrEqualTo(s)&&!0!==i.isMinter)}}var it;!function(t){t[t.CreatingExchange=0]="CreatingExchange",t[t.ApprovingDatatoken=1]="ApprovingDatatoken"}(it||(it={}));class nt{constructor(t,e,a=null,s=null,i){this.GASLIMIT_DEFAULT=1e6,this.oceanAddress=null,this.fixedRateAddress=void 0,this.fixedRateExchangeAbi=void 0,this.fixedRateContract=void 0,this.web3=void 0,this.contract=null,this.config=void 0,this.ssAbi=void 0,this.web3=t,this.config=i||N[0],this.fixedRateExchangeAbi=a||h.abi,this.oceanAddress=s,this.fixedRateAddress=e,this.contract=C(new this.web3.eth.Contract(this.fixedRateExchangeAbi,this.fixedRateAddress),this.config)}async amountToUnits(t,e){return G(this.web3,t,e)}async unitsToAmount(t,e){return I(this.web3,t,e)}async generateExchangeId(t,e){return await this.contract.methods.generateExchangeId(t,e).call()}async estBuyDT(t,e,a,s,i,n,o){const r=o||this.fixedRateContract,c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.buyDT(e,a,s,i,n).estimateGas({from:t},(t,e)=>t?c:e)}catch(t){h=c}return h}async buyDT(t,e,a,s,i=T,n="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(n),c=await this.amountToUnits(o.datatoken,a),h=await this.amountToUnits(o.baseToken,s),l=await this.estBuyDT(t,e,c,h,i,r);try{return await this.contract.methods.buyDT(e,c,h,i,r).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){return f.error(`ERROR: Failed to buy datatokens: ${t.message}`),null}}async estSellDT(t,e,a,s,i,n,o){const r=o||this.fixedRateContract,c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.sellDT(e,a,s,i,n).estimateGas({from:t},(t,e)=>t?c:e)}catch(t){h=c}return h}async sellDT(t,e,a,s,i=T,n="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(n),c=await this.amountToUnits(o.datatoken,a),h=await this.amountToUnits(o.baseToken,s),l=await this.estBuyDT(t,e,c,h,i,r);try{return await this.contract.methods.sellDT(e,c,h,i,r).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){return f.error(`ERROR: Failed to sell datatokens: ${t.message}`),null}}async getNumberOfExchanges(){return await this.contract.methods.getNumberOfExchanges().call()}async estSetRate(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setRate(e,await this.web3.utils.toWei(a)).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setRate(t,e,a){const s=await this.estSetRate(t,e,a);return await this.contract.methods.setRate(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estSetAllowedSwapper(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setRate(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async setAllowedSwapper(t,e,a){const s=await this.estSetAllowedSwapper(t,e,a);return await this.contract.methods.setAllowedSwapper(e,a).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estActivate(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleExchangeState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async activate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.active)return null;const s=await this.estActivate(t,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estDeactivate(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleExchangeState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async deactivate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.active)return null;const s=await this.estDeactivate(t,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async getRate(t){const e=await this.contract.methods.getRate(t).call();return await this.web3.utils.fromWei(e)}async getDTSupply(t){const e=await this.contract.methods.getDTSupply(t).call();return await this.unitsToAmount((await this.getExchange(t)).datatoken,e)}async getBTSupply(t){const e=await this.contract.methods.getBTSupply(t).call();return await this.unitsToAmount((await this.getExchange(t)).baseToken,e)}async getAllowedSwapper(t){return await this.contract.methods.getAllowedSwapper(t).call()}async calcBaseInGivenOutDT(t,e,a="0"){const s=await this.getExchange(t),i=await this.contract.methods.calcBaseInGivenOutDT(t,await this.amountToUnits(s.datatoken,e),this.web3.utils.toWei(a)).call();return{baseTokenAmount:await this.unitsToAmount(s.baseToken,i.baseTokenAmount),marketFeeAmount:await this.unitsToAmount(s.baseToken,i.marketFeeAmount),oceanFeeAmount:await this.unitsToAmount(s.baseToken,i.oceanFeeAmount),consumeMarketFeeAmount:await this.unitsToAmount(s.baseToken,i.consumeMarketFeeAmount)}}async getAmountBTOut(t,e,a="0"){const s=await this.getExchange(t),i=await this.contract.methods.calcBaseOutGivenInDT(t,await this.amountToUnits(s.datatoken,e),this.web3.utils.toWei(a)).call();return await this.unitsToAmount((await this.getExchange(t)).baseToken,i[0])}async getExchange(t){const e=await this.contract.methods.getExchange(t).call();return e.dtDecimals=e.dtDecimals.toString(),e.btDecimals=e.btDecimals.toString(),e.dtBalance=await this.unitsToAmount(e.datatoken,e.dtBalance),e.btBalance=await this.unitsToAmount(e.baseToken,e.btBalance),e.dtSupply=await this.unitsToAmount(e.datatoken,e.dtSupply),e.btSupply=await this.unitsToAmount(e.baseToken,e.btSupply),e.fixedRate=this.web3.utils.fromWei(e.fixedRate),e.exchangeId=t,e}async getFeesInfo(t){const e=await this.contract.methods.getFeesInfo(t).call();return e.opcFee=this.web3.utils.fromWei(e.opcFee.toString()),e.marketFee=this.web3.utils.fromWei(e.marketFee.toString()),e.marketFeeAvailable=await this.unitsToAmount((await this.getExchange(t)).baseToken,e.marketFeeAvailable),e.oceanFeeAvailable=await this.unitsToAmount((await this.getExchange(t)).baseToken,e.oceanFeeAvailable),e.exchangeId=t,e}async getExchanges(){return await this.contract.methods.getExchanges().call()}async isActive(t){return await this.contract.methods.isActive(t).call()}async estActivateMint(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleMintState(e,!0).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async activateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.withMint)return null;const s=await this.estActivateMint(t,e);return await this.contract.methods.toggleMintState(e,!0).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estDeactivateMint(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.toggleMintState(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async deactivateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.withMint)return null;const s=await this.estDeactivate(t,e);return await this.contract.methods.toggleMintState(e,!1).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estCollectBT(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;const r=await this.contract.methods.getExchange(e).call(),c=await this.amountToUnits(r.baseToken,a);try{o=await i.methods.collectBT(e,c).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async collectBT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.estCollectBT(t,e,a),i=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(i.baseToken,a);return await this.contract.methods.collectBT(e,n).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estCollectDT(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;const r=await this.contract.methods.getExchange(e).call(),c=await this.amountToUnits(r.datatoken,a);try{o=await i.methods.collectDT(e,c).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async collectDT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.estCollectDT(t,e,a),i=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(i.datatoken,a);return await this.contract.methods.collectDT(e,n).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estCollectMarketFee(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectMarketFee(t,e){if(!await this.getExchange(e))return null;const a=await this.estCollectMarketFee(t,e);return await this.contract.methods.collectMarketFee(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estCollectOceanFee(t,e,a){const s=a||this.fixedRateContract,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.collectMarketFee(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async collectOceanFee(t,e){if(!await this.getExchange(e))return null;const a=await this.estCollectOceanFee(t,e);return await this.contract.methods.collectOceanFee(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async getOPCCollector(){let t=null;try{t=await this.contract.methods.opcCollector().call()}catch(t){f.error(`ERROR: Failed to get OPC Collector address: ${t.message}`)}return t}async getRouter(){let t=null;try{t=await this.contract.methods.router().call()}catch(t){f.error(`ERROR: Failed to get Router address: ${t.message}`)}return t}async getExchangeOwner(t){let e=null;try{e=await(await this.getExchange(t)).exchangeOwner}catch(t){f.error(`ERROR: Failed to get OPF Collector address: ${t.message}`)}return e}async estUpdateMarketFee(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.updateMarketFee(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async updateMarketFee(t,e,a){const s=await this.estSetRate(t,e,this.web3.utils.toWei(a));return await this.contract.methods.updateMarketFee(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estUpdateMarketFeeCollector(t,e,a,s){const i=s||this.fixedRateContract,n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.updateMarketFeeCollector(e,a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async updateMarketFeeCollector(t,e,a){const s=await this.estUpdateMarketFeeCollector(t,e,a);return await this.contract.methods.updateMarketFeeCollector(e,a).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}}class ot{constructor(t,e=null,a){this.ssAbi=void 0,this.web3=void 0,this.GASLIMIT_DEFAULT=1e6,this.config=void 0,this.ssAbi=e||l.abi,this.web3=t,this.config=a||N[0]}async amountToUnits(t,a){let s=18;const i=C(new this.web3.eth.Contract(r.abi,t),this.config);try{s=await i.methods.decimals().call()}catch(t){f.error("ERROR: FAILED TO CALL DECIMALS(), USING 18")}return new e(parseInt(a)*10**s).toString()}async unitsToAmount(t,a){let s=18;const i=C(new this.web3.eth.Contract(r.abi,t),this.config);try{s=await i.methods.decimals().call()}catch(t){f.error("ERROR: FAILED TO CALL DECIMALS(), USING 18")}return new e(parseInt(a)/10**s).toString()}async getDatatokenCirculatingSupply(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getDatatokenCirculatingSupply(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s.toString()}async getDatatokenCurrentCirculatingSupply(t,e){try{const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;return s=await a.methods.getDatatokenCurrentCirculatingSupply(e).call(),s.toString()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}}async getPublisherAddress(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getPublisherAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getBaseToken(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getBaseTokenAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getPoolAddress(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getPoolAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getBaseTokenBalance(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getBaseTokenBalance(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getDatatokenBalance(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getDatatokenBalance(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s=await this.unitsToAmount(e,s),s}async getvestingEndBlock(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getvestingEndBlock(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getvestingAmount(t,e){const a=new this.web3.eth.Contract(this.ssAbi,t);let s=null;try{s=await a.methods.getvestingAmount(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s=await this.unitsToAmount(e,s),s}async getvestingLastBlock(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getvestingLastBlock(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getvestingAmountSoFar(t,e){const a=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;try{s=await a.methods.getvestingAmountSoFar(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s=await this.unitsToAmount(e,s),s}async estGetVesting(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.ssAbi,e),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.getVesting(a).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async getVesting(t,e,a){const s=C(new this.web3.eth.Contract(this.ssAbi,e),this.config);let i=null;const n=await this.estGetVesting(t,e,a,s);try{i=await s.methods.getVesting(a).send({from:t,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error("ERROR: Failed to join swap pool amount out")}return i}async estSetPoolSwapFee(t,e,a,s,i,n){const o=n||C(new this.web3.eth.Contract(this.ssAbi,e),this.config),r=this.GASLIMIT_DEFAULT;let c;try{c=await o.methods.setPoolSwapFee(a,s,i).estimateGas({from:t},(t,e)=>t?r:e)}catch(t){c=r}return c}async setPoolSwapFee(t,e,a,s,i){const n=C(new this.web3.eth.Contract(this.ssAbi,e),this.config);let o=null;const r=await this.estSetPoolSwapFee(t,e,a,s,i,n);try{o=await n.methods.setPoolSwapFee(a,s,i).send({from:t,gas:r+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error("ERROR: Failed to join swap pool amount out")}return o}async getRouter(t){const e=C(new this.web3.eth.Contract(this.ssAbi,t),this.config);let a=null;try{a=await e.methods.router().call()}catch(t){f.error(`ERROR: Failed to get Router address: ${t.message}`)}return a}}class rt{constructor(t,e,a,s){this.GASLIMIT_DEFAULT=1e6,this.routerAddress=void 0,this.RouterAbi=void 0,this.web3=void 0,this.config=void 0,this.router=void 0,this.routerAddress=t,this.RouterAbi=a||d.abi,this.web3=e,this.config=s||N[0],this.router=C(new this.web3.eth.Contract(this.RouterAbi,this.routerAddress),this.config)}async estGasBuyDTBatch(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.buyDTBatch(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async buyDTBatch(t,e){const a=await this.estGasBuyDTBatch(t,e);return await this.router.methods.buyDTBatch(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async isApprovedToken(t){return await this.router.methods.isApprovedToken(t).call()}async isSideStaking(t){return await this.router.methods.isSSContract(t).call()}async isFixedPrice(t){return await this.router.methods.isFixedRateContract(t).call()}async getOwner(){return await this.router.methods.routerOwner().call()}async getNFTFactory(){return await this.router.methods.factory().call()}async isPoolTemplate(t){return await this.router.methods.isPoolTemplate(t).call()}async estGasAddApprovedToken(t,e,a){const s=a||this.router,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.addApprovedToken(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async addApprovedToken(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasAddApprovedToken(t,e);return await this.router.methods.addApprovedToken(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveApprovedToken(t,e,a){const s=a||this.router,i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.removeApprovedToken(e).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async removeApprovedToken(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasRemoveApprovedToken(t,e);return await this.router.methods.removeApprovedToken(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddSSContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.addSSContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addSSContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasAddSSContract(t,e);return await this.router.methods.addSSContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveSSContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.removeSSContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async removeSSContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasRemoveSSContract(t,e);return await this.router.methods.removeSSContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddFixedRateContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.addFixedRateContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addFixedRateContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasAddFixedRateContract(t,e);return await this.router.methods.addFixedRateContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveFixedRateContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.removeFixedRateContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async removeFixedRateContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasRemoveFixedRateContract(t,e);return await this.router.methods.removeFixedRateContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddDispenserContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.addDispenserContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addDispenserContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasAddDispenserContract(t,e);return await this.router.methods.addDispenserContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveDispenserContract(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.removeDispenserContract(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async removeDispenserContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasRemoveDispenserContract(t,e);return await this.router.methods.removeDispenserContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async getOPCFee(t){return await this.router.methods.getOPCFee(t).call()}async getCurrentOPCFee(){return await this.router.methods.swapOceanFee().call()}async estGasUpdateOPCFee(t,e,a,s,i){const n=this.GASLIMIT_DEFAULT;let o;try{o=await this.router.methods.updateOPCFee(e,a,s,i).estimateGas({from:t},(t,e)=>t?n:e)}catch(t){o=n}return o}async updateOPCFee(t,e,a,s,i){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const n=await this.estGasUpdateOPCFee(t,e,a,s,i);return await this.router.methods.updateOPCFee(e,a,s,i).send({from:t,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasAddPoolTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.addPoolTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addPoolTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasAddPoolTemplate(t,e);return await this.router.methods.addPoolTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemovePoolTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.router.methods.removePoolTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async removePoolTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await this.estGasRemovePoolTemplate(t,e);return await this.router.methods.removePoolTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}}class ct{constructor(t,e,a){this.GASLIMIT_DEFAULT=1e6,this.factory721Address=void 0,this.factory721Abi=void 0,this.nftAbi=void 0,this.web3=void 0,this.startBlock=void 0,this.config=void 0,this.nftAbi=e||u.abi,this.web3=t,this.config=a||N[0]}async estGasCreateErc20(t,e,a,s,i,n,o,r,c,h,l,d){const w=d||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),u=this.GASLIMIT_DEFAULT;let m;try{m=await w.methods.createERC20(l,[c,h],[a,s,i,n],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]).estimateGas({from:e},(t,e)=>t?u:e)}catch(t){m=u}return m}async createErc20(t,e,a,s,i,n,o,r,c,h,l){if(!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not ERC20Deployer");l||(l=1),c&&h||({name:c,symbol:h}=b());const d=C(new this.web3.eth.Contract(this.nftAbi,t),this.config),w=await this.estGasCreateErc20(t,e,a,s,i,n,o,r,c,h,l,d),u=await d.methods.createERC20(l,[c,h],[a,s,i,n],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]).send({from:e,gas:w+1,gasPrice:await R(this.web3,this.config)});let m=null;try{m=u.events.TokenCreated.returnValues[0]}catch(t){f.error(`ERROR: Failed to create datatoken : ${t.message}`)}return m}async estGasAddManager(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addManager(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=await this.estGasAddManager(t,e,a,s);return await s.methods.addManager(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveManager(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeManager(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=await this.estGasRemoveManager(t,e,a,s);return await s.methods.removeManager(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasAddErc20Deployer(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addToCreateERC20List(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addErc20Deployer(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddErc20Deployer(t,e,a,s);return await s.methods.addToCreateERC20List(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveErc20Deployer(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFromCreateErc20List(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeErc20Deployer(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e===a&&!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not Manager nor ERC20Deployer");const i=await this.estGasRemoveErc20Deployer(t,e,a,s);return await s.methods.removeFromCreateERC20List(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasAddMetadataUpdater(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addToMetadataList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addMetadataUpdater(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddMetadataUpdater(t,e,a,s);return await s.methods.addToMetadataList(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async esGasRemoveMetadataUpdater(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFromMetadataList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeMetadataUpdater(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Manager nor Metadata Updater");const i=await this.esGasRemoveMetadataUpdater(t,e,a,s);return await s.methods.removeFromMetadataList(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasAddStoreUpdater(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addTo725StoreList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addStoreUpdater(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const i=await this.estGasAddStoreUpdater(t,e,a,s);return await s.methods.addTo725StoreList(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveStoreUpdater(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeFrom725StoreList(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeStoreUpdater(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).store)throw new Error("Caller is not Manager nor storeUpdater");const i=await this.estGasRemoveStoreUpdater(t,e,a,s);return await s.methods.removeFrom725StoreList(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){const s=a||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.cleanPermissions().estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async cleanPermissions(t,e){const a=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const s=await this.estGasCleanPermissions(t,e,a);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estGasTransferNft(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.transferFrom(e,a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async transferNft(t,e,a,s){const i=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=s||1,o=await this.estGasTransferNft(t,e,a,n,i);return await i.methods.transferFrom(e,a,n).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasSafeTransferNft(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.safeTransferFrom(e,a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async safeTransferNft(t,e,a,s){const i=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=s||1,o=await this.estGasSafeTransferNft(t,e,a,n,i);return await i.methods.safeTransferFrom(e,a,n).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadata(t,e,a,s,i,n,o,r,c,h){const l=h||C(new this.web3.eth.Contract(this.nftAbi,t),this.config);c||(c=[]);const d=this.GASLIMIT_DEFAULT;let w;try{w=await l.methods.setMetaData(a,s,i,n,o,r,c).estimateGas({from:e},(t,e)=>t?d:e)}catch(t){f.error("estGasSetMetadata error: ",t.message),w=d}return w}async setMetadata(t,e,a,s,i,n,o,r,c){const h=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(c||(c=[]),!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const l=await this.estGasSetMetadata(t,e,a,s,i,n,o,r,c,h);return await h.methods.setMetaData(a,s,i,n,o,r,c).send({from:e,gas:l+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadataAndTokenURI(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;const r=U({},a,{metadataProofs:a.metadataProofs||[]});try{o=await i.methods.setMetaDataAndTokenURI(r).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setMetadataAndTokenURI(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const i=await this.estGasSetMetadataAndTokenURI(t,e,a,s),n=U({},a,{metadataProofs:a.metadataProofs||[]});return await s.methods.setMetaDataAndTokenURI(n).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadataState(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setMetaDataState(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setMetadataState(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const i=await this.estGasSetMetadataState(t,e,a);return await s.methods.setMetaDataState(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estSetTokenURI(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.setTokenURI("1",a).estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async setTokenURI(t,e,a){const s=C(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=await this.estSetTokenURI(t,e,a);return await s.methods.setTokenURI("1",a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async getNftOwner(t){const e=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.ownerOf(1).call()}async getNftPermissions(t,e){const a=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getPermissions(e).call()}async getMetadata(t){const e=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.getMetaData().call()}async isErc20Deployer(t,e){const a=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async getData(t,e){const a=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getData(e).call()}async getTokenURI(t,e){const a=C(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.tokenURI(e).call()}}class ht{constructor(t,e,a,s){this.GASLIMIT_DEFAULT=1e6,this.factoryAddress=void 0,this.factoryABI=void 0,this.datatokensAbi=void 0,this.datatokensEnterpriseAbi=void 0,this.web3=void 0,this.config=void 0,this.nft=void 0,this.web3=t,this.datatokensAbi=e||r.abi,this.datatokensEnterpriseAbi=a||w.abi,this.config=s||N[0],this.nft=new ct(this.web3)}async estGasApprove(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.approve(e,this.web3.utils.toWei(a)).estimateGas({from:s},(t,e)=>t?o:e)}catch(t){r=o}return r}async approve(t,e,a,s){const i=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=await this.estGasApprove(t,e,a,s,i);return await i.methods.approve(e,this.web3.utils.toWei(a)).send({from:s,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasMint(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.mint(s||e,this.web3.utils.toWei(a)).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async estGasCreateFixedRate(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;a.allowedConsumer||(a.allowedConsumer=T);const o=a.withMint?1:0;let r;try{r=await i.methods.createFixedRate(a.fixedRateAddress,[a.baseTokenAddress,e,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,o]).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){r=n}return r}async createFixedRate(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");a.allowedConsumer||(a.allowedConsumer=T);const i=a.withMint?1:0,n=await this.estGasCreateFixedRate(t,e,a,s);return await s.methods.createFixedRate(a.fixedRateAddress,[a.baseTokenAddress,a.owner,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,i]).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateDispenser(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);s.allowedSwapper||(s.allowedSwapper=T),s.withMint||(s.withMint=!1);const o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.createDispenser(a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async createDispenser(t,e,a,s){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const i=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);s.allowedSwapper||(s.allowedSwapper=T),s.withMint||(s.withMint=!1);const n=await this.estGasCreateDispenser(t,e,a,s,i);return await i.methods.createDispenser(a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async mint(t,e,a,s){const i=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==(await this.getDTPermissions(t,e)).minter)throw new Error("Caller is not Minter");const o=await this.getCap(t);if(new n(o).gte(a)){const n=await this.estGasMint(t,e,a,s,i);return await i.methods.mint(s||e,this.web3.utils.toWei(a)).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}throw new Error("Mint amount exceeds cap available")}async estGasAddMinter(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addMinter(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addMinter(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasAddMinter(t,e,a,s);return await s.methods.addMinter(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveMinter(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removeMinter(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removeMinter(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasRemoveMinter(t,e,a,s);return await s.methods.removeMinter(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasAddPaymentManager(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.addPaymentManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async addPaymentManager(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasAddPaymentManager(t,e,a,s);return await s.methods.addPaymentManager(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasRemovePaymentManager(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.removePaymentManager(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async removePaymentManager(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const i=await this.estGasRemovePaymentManager(t,e,a,s);return await s.methods.removePaymentManager(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasSetPaymentCollector(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setPaymentCollector(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setPaymentCollector(t,e,a){const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=(await this.getDTPermissions(t,e)).paymentManager,n=!i&&await this.getNFTAddress(t),o=n&&await this.nft.getNftOwner(n)===e,r=n&&!o&&await this.nft.getNftPermissions(n,e);if(!i&&!o&&!(null==r?void 0:r.deployERC20))throw new Error("Caller is not Fee Manager, owner or erc20 Deployer");const c=await this.estGasSetPaymentCollector(t,e,a,s);return await s.methods.setPaymentCollector(a).send({from:e,gas:c+1,gasPrice:await R(this.web3,this.config)})}async getPaymentCollector(t){const e=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getPaymentCollector().call()}async transfer(t,e,a,s){const i=this.web3.utils.toWei(a);return this.transferWei(t,e,i,s)}async estGasTransfer(t,e,a,s,i){const n=i||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.transfer(e,a).estimateGas({from:s},(t,e)=>t?o:e)}catch(t){r=o}return r}async transferWei(t,e,a,s){const i=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);try{const n=await this.estGasTransfer(t,e,a,s,i);return await i.methods.transfer(e,a).send({from:s,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to transfer tokens: ${t.message}`),new Error(`Failed Failed to transfer tokens: ${t.message}`)}}async estGasStartOrder(t,e,a,s,i,n,o){const r=o||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),c=this.GASLIMIT_DEFAULT;let h;try{h=await r.methods.startOrder(a,s,i,n).estimateGas({from:e},(t,e)=>t?c:e)}catch(t){h=c}return h}async startOrder(t,e,a,s,i,o){var r=this;const c=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);o||(o={consumeMarketFeeAddress:T,consumeMarketFeeToken:T,consumeMarketFeeAmount:"0"});const h=await c.methods.getPublishingMarketFee().call(),l=[{token:i.providerFeeToken,feeAmount:i.providerFeeAmount},{token:o.consumeMarketFeeToken,feeAmount:parseFloat(o.consumeMarketFeeAmount)},{token:h[1],feeAmount:parseFloat(h[2])}],d=[];l.map(t=>{d.length>0?d.map(e=>{e.token===t.token?e.feeAmount+=t.feeAmount:d.push({token:t.token,feeAmount:t.feeAmount})}):d.push({token:t.token,feeAmount:t.feeAmount})});const w=d.map(async function(t){if(t.token===T||0===t.feeAmount)return t;const s=await z(r.web3,t.token,e,a);if(new n(s).greaterThanOrEqualTo(new n(t.feeAmount)))throw f.error(`ERROR: Failed checking allowance: ${t.token}`),new Error(`allowance (${s}) is too low`);return t.currentAllowance=s,t});try{await Promise.all(w)}catch(t){throw f.error(`ERROR: Failed checking allowance : ${t}`),new Error(`Failed checking allowance: ${t}`)}try{const n=await this.estGasStartOrder(t,e,a,s,i,o,c);return await c.methods.startOrder(a,s,i,o).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to start order : ${t.message}`),new Error(`Failed to start order: ${t.message}`)}}async estGasBuyFromFreAndOrder(t,e,a,s,i){const n=i||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.buyFromFreAndOrder(a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async buyFromFreAndOrder(t,e,a,s){const i=C(new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),this.config);try{const n=k(s),o=await this.estGasBuyFromFreAndOrder(t,e,a,n,i);return await i.methods.buyFromFreAndOrder(a,n).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasBuyFromDispenserAndOrder(t,e,a,s,i){const n=i||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),o=this.GASLIMIT_DEFAULT;let r;try{r=await n.methods.buyFromDispenserAndOrder(a,s).estimateGas({from:e},(t,e)=>t?o:e)}catch(t){r=o}return r}async buyFromDispenserAndOrder(t,e,a,s){const i=C(new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),this.config);try{const n=await this.estGasBuyFromDispenserAndOrder(t,e,a,s,i);return await i.methods.buyFromDispenserAndOrder(a,s).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasSetData(t,e,a,s){const i=s||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=this.GASLIMIT_DEFAULT;let o;try{o=await i.methods.setData(a).estimateGas({from:e},(t,e)=>t?n:e)}catch(t){o=n}return o}async setData(t,e,a){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const s=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=await this.estGasSetData(t,e,a,s);return await s.methods.setData(a).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){const s=a||C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=this.GASLIMIT_DEFAULT;let n;try{n=await s.methods.cleanPermissions().estimateGas({from:e},(t,e)=>t?i:e)}catch(t){n=i}return n}async cleanPermissions(t,e){if(await this.nft.getNftOwner(await this.getNFTAddress(t))!==e)throw new Error("Caller is NOT Nft Owner");const a=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),s=await this.estGasCleanPermissions(t,e,a);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}async getDTPermissions(t,e){const a=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.permissions(e).call()}async getCap(t){const e=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),a=await e.methods.cap().call();return this.web3.utils.fromWei(a)}async getDecimals(t){const e=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.decimals().call()}async getNFTAddress(t){const e=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getERC721Address().call()}async isERC20Deployer(t,e){const a=C(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async balance(t,e){const a=C(new this.web3.eth.Contract(this.datatokensAbi,t,{from:e}),this.config),s=await a.methods.balanceOf(e).call();return this.web3.utils.fromWei(s)}}class lt{constructor(t,e,a,s){this.GASLIMIT_DEFAULT=1e6,this.factory721Address=void 0,this.factory721Abi=void 0,this.web3=void 0,this.config=void 0,this.factory721=void 0,this.factory721Address=t,this.factory721Abi=a||m.abi,this.web3=e,this.config=s||N[0],this.factory721=C(new this.web3.eth.Contract(this.factory721Abi,this.factory721Address),this.config)}async estGasCreateNFT(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.deployERC721Contract(e.name,e.symbol,e.templateIndex,T,T,e.tokenURI,e.transferable,e.owner).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async createNFT(t,e){if(e.templateIndex||(e.templateIndex=1),!e.name||!e.symbol){const{name:t,symbol:a}=b();e.name=t,e.symbol=a}if(e.templateIndex>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e.templateIndex)throw new Error("Template index cannot be ZERO");if(!1===(await this.getNFTTemplate(e.templateIndex)).isActive)throw new Error("Template is not active");const a=await this.estGasCreateNFT(t,e),s=await this.factory721.methods.deployERC721Contract(e.name,e.symbol,e.templateIndex,T,T,e.tokenURI,e.transferable,e.owner).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)});let i=null;try{i=s.events.NFTCreated.returnValues[0]}catch(t){f.error(`ERROR: Failed to create datatoken : ${t.message}`)}return i}async getCurrentNFTCount(){return await this.factory721.methods.getCurrentNFTCount().call()}async getCurrentTokenCount(){return await this.factory721.methods.getCurrentTokenCount().call()}async getOwner(){return await this.factory721.methods.owner().call()}async getCurrentNFTTemplateCount(){return await this.factory721.methods.getCurrentNFTTemplateCount().call()}async getCurrentTokenTemplateCount(){return await this.factory721.methods.getCurrentTemplateCount().call()}async getNFTTemplate(t){if(t>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===t)throw new Error("Template index cannot be ZERO");return await this.factory721.methods.getNFTTemplate(t).call()}async getTokenTemplate(t){return await this.factory721.methods.getTokenTemplate(t).call()}async checkDatatoken(t){return await this.factory721.methods.erc20List(t).call()}async checkNFT(t){return await this.factory721.methods.erc721List(t).call()}async estGasAddNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.add721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===T)throw new Error("Template cannot be ZERO address");const a=await this.estGasAddNFTTemplate(t,e);return await this.factory721.methods.add721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasDisableNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.disable721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async disableNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await this.estGasDisableNFTTemplate(t,e);return await this.factory721.methods.disable721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasReactivateNFTTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.reactivate721TokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async reactivateNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await this.estGasReactivateNFTTemplate(t,e);return await this.factory721.methods.reactivate721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.addTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async addTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===T)throw new Error("Template cannot be address ZERO");const a=await this.estGasAddTokenTemplate(t,e);return await this.factory721.methods.addTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasDisableTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.disableTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async disableTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!1===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already disabled");const a=await this.estGasDisableTokenTemplate(t,e);return await this.factory721.methods.disableTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasReactivateTokenTemplate(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.reactivateTokenTemplate(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async reactivateTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!0===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already active");const a=await this.estGasReactivateTokenTemplate(t,e);return await this.factory721.methods.reactivateTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasStartMultipleTokenOrder(t,e){const a=this.GASLIMIT_DEFAULT;let s;try{s=await this.factory721.methods.startMultipleTokenOrder(e).estimateGas({from:t},(t,e)=>t?a:e)}catch(t){s=a}return s}async startMultipleTokenOrder(t,e){if(e.length>50)throw new Error("Too many orders");const a=await this.estGasStartMultipleTokenOrder(t,e);return await this.factory721.methods.startMultipleTokenOrder(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftWithErc20(t,e,a){const s=this.GASLIMIT_DEFAULT;let i;try{const n=F(a);i=await this.factory721.methods.createNftWithErc20(e,n).estimateGas({from:t},(t,e)=>t?s:e)}catch(t){i=s}return i}async createNftWithErc20(t,e,a){const s=F(a),i=await this.estGasCreateNftWithErc20(t,e,a);return await this.factory721.methods.createNftWithErc20(e,s).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithPool(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;try{const o=F(a),r=await S(this.web3,s);n=await this.factory721.methods.createNftWithErc20WithPool(e,o,r).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async createNftErc20WithPool(t,e,a,s){const i=await this.estGasCreateNftErc20WithPool(t,e,a,s),n=F(a),o=await S(this.web3,s);return await this.factory721.methods.createNftWithErc20WithPool(e,n,o).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithFixedRate(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;const o=F(a),r=await v(s);try{n=await this.factory721.methods.createNftWithErc20WithFixedRate(e,o,r).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i}return n}async createNftErc20WithFixedRate(t,e,a,s){const i=F(a),n=v(s),o=await this.estGasCreateNftErc20WithFixedRate(t,e,a,s);return await this.factory721.methods.createNftWithErc20WithFixedRate(e,i,n).send({from:t,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithDispenser(t,e,a,s){const i=this.GASLIMIT_DEFAULT;let n;const o=F(a);try{n=await this.factory721.methods.createNftWithErc20WithDispenser(e,o,s).estimateGas({from:t},(t,e)=>t?i:e)}catch(t){n=i,f.error("Failed to estimate gas for createNftErc20WithDispenser",t)}return n}async createNftErc20WithDispenser(e,a,s,i){const n=F(s);i.maxBalance=t.utils.toWei(i.maxBalance),i.maxTokens=t.utils.toWei(i.maxTokens);const o=await this.estGasCreateNftErc20WithDispenser(e,a,s,i);return await this.factory721.methods.createNftWithErc20WithDispenser(a,n,i).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}}class dt{constructor(){this.nodeUri=void 0,this.providerAddress=void 0,this.metadataCacheUri=void 0,this.providerUri=void 0,this.web3Provider=void 0,this.oceanTokenAddress=void 0,this.erc721FactoryAddress=void 0,this.erc721FFactoryABI=void 0,this.datatokensABI=void 0,this.poolTemplateAddress=void 0,this.poolFactoryABI=void 0,this.poolABI=void 0,this.fixedRateExchangeAddress=void 0,this.fixedRateExchangeAddressABI=void 0,this.dispenserAddress=void 0,this.dispenserABI=void 0,this.opfCommunityFeeCollector=void 0,this.sideStakingAddress=void 0,this.startBlock=void 0,this.verbose=void 0,this.authMessage=void 0,this.authTokenExpiration=void 0,this.parityUri=void 0,this.threshold=void 0,this.chainId=void 0,this.network=void 0,this.subgraphUri=void 0,this.explorerUri=void 0,this.oceanTokenSymbol=void 0,this.transactionBlockTimeout=void 0,this.transactionConfirmationBlocks=void 0,this.transactionPollingTimeout=void 0,this.gasFeeMultiplier=void 0}}const wt=t=>function(t="",e){const{valid:a,output:s}=function(t,e,a){if("string"!=typeof t)throw f.debug("Not input string:"),f.debug(t),new Error("[zeroXTransformer] Expected string, input type: "+typeof t);const s=t.match(/^(?:0x)*([a-f0-9]+)$/i);return s?{valid:!0,output:s[1]}:(f.warn("[zeroXTransformer] Input transformation failed."),{valid:!1,output:t})}(t);return(e&&a?"0x":"")+s}(t,!1);class ut{async getEndpoints(t){try{const e=await L(t);return await e.json()}catch(t){return f.error("Finding the service endpoints failed:",t),null}}getEndpointURL(t,e){return t?t.find(t=>t.serviceName===e):null}async getServiceEndpoints(t,e){const a=[];for(const s in e.serviceEndpoints)a.push({serviceName:s,method:e.serviceEndpoints[s][0],urlPath:t+e.serviceEndpoints[s][1]});return a}async getNonce(t,e,s,i,n){i||(i=await this.getEndpoints(t)),n||(n=await this.getServiceEndpoints(t,i));const o=this.getEndpointURL(n,"nonce")?this.getEndpointURL(n,"nonce").urlPath:null;if(!o)return null;try{const t=await a(o+`?userAddress=${e}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});return(await t.json()).nonce.toString()}catch(t){throw f.error(t),new Error("HTTP request failed")}}async signProviderRequest(t,e,a,s){const i=t.utils.soliditySha3({t:"bytes",v:t.utils.utf8ToHex(a)});return t&&t.currentProvider&&t.currentProvider.isMetaMask?await t.eth.personal.sign(i,e,s):await t.eth.sign(i,e)}async encrypt(t,e,s){const i=await this.getEndpoints(e),n=await this.getServiceEndpoints(e,i),o=this.getEndpointURL(n,"encrypt")?this.getEndpointURL(n,"encrypt").urlPath:null;if(!o)return null;try{const e=await a(o,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:s});return await e.text()}catch(t){throw f.error(t),new Error("HTTP request failed")}}async checkDidFiles(t,e,s,i){const n=await this.getEndpoints(s),o=await this.getServiceEndpoints(s,n),r={did:t,serviceId:e},c=[],h=this.getEndpointURL(o,"fileinfo")?this.getEndpointURL(o,"fileinfo").urlPath:null;if(!h)return null;try{const t=await a(h,{method:"POST",body:JSON.stringify(r),headers:{"Content-Type":"application/json"},signal:i}),e=await t.json();for(const t of e)c.push(t);return c}catch(t){return null}}async checkFileUrl(t,e,s){const i=await this.getEndpoints(e),n=await this.getServiceEndpoints(e,i),o={url:t,type:"url"},r=[],c=this.getEndpointURL(n,"fileinfo")?this.getEndpointURL(n,"fileinfo").urlPath:null;if(!c)return null;try{const t=await a(c,{method:"POST",body:JSON.stringify(o),headers:{"Content-Type":"application/json"},signal:s}),e=await t.json();for(const t of e)r.push(t);return r}catch(t){return null}}async getComputeEnvironments(t,e){var s;const i=await this.getEndpoints(t),n=await this.getServiceEndpoints(t,i),o=null==(s=this.getEndpointURL(n,"computeEnvironments"))?void 0:s.urlPath;if(!o)return null;try{const t=await a(o,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});return await t.json()}catch(t){return f.error(t.message),null}}async initialize(t,e,s,i,n,o,r,c,h){const l=await this.getEndpoints(n),d=await this.getServiceEndpoints(n,l);let w=this.getEndpointURL(d,"initialize")?this.getEndpointURL(d,"initialize").urlPath:null;if(!w)return null;w+=`?documentId=${t}`,w+=`&serviceId=${e}`,w+=`&fileIndex=${s}`,w+=`&consumerAddress=${i}`,r&&(w+="&userdata="+encodeURI(JSON.stringify(r))),c&&(w+="&environment="+encodeURI(c)),h&&(w+="&validUntil="+h);try{const t=await a(w,{method:"GET",headers:{"Content-Type":"application/json"},signal:o});return await t.json()}catch(t){throw f.error(t),new Error("Asset URL not found or not available.")}}async getDownloadUrl(t,e,a,s,i,n,o,r){const c=await this.getEndpoints(n),h=await this.getServiceEndpoints(n,c),l=this.getEndpointURL(h,"download")?this.getEndpointURL(h,"download").urlPath:null;if(!l)return null;const d=Date.now();let w=l;return w+=`?fileIndex=${s}`,w+=`&documentId=${t}`,w+=`&transferTxId=${i}`,w+=`&serviceId=${a}`,w+=`&consumerAddress=${e}`,w+=`&nonce=${d}`,w+=`&signature=${await this.signProviderRequest(o,e,t+d)}`,r&&(w+="&userdata="+encodeURI(JSON.stringify(r))),w}async computeStart(t,e,s,i,n,o,r,c,h){const l=await this.getEndpoints(t),d=await this.getServiceEndpoints(t,l),w=this.getEndpointURL(d,"computeStart")?this.getEndpointURL(d,"computeStart").urlPath:null,u=Date.now();let m=s;m+=n.documentId,m+=u;const g=await this.signProviderRequest(e,s,m),p=Object();if(p.consumerAddress=s,p.signature=g,p.nonce=u,p.environment=i,p.dataset=n,p.algorithm=o,p.additionalDatasets&&(p.additionalDatasets=c),h&&(p.output=h),!w)return null;try{const t=await a(w,{method:"POST",body:JSON.stringify(p),headers:{"Content-Type":"application/json"},signal:r});return null!=t&&t.ok?await t.json():(f.error("Compute start failed: ",t.status,t.statusText),f.error("Payload was:",p),null)}catch(t){return f.error("Compute start failed:"),f.error(t),f.error("Payload was:",p),null}}async computeStop(t,e,s,i,n,o){const r=await this.getEndpoints(i),c=await this.getServiceEndpoints(i,r),h=this.getEndpointURL(c,"computeStop")?this.getEndpointURL(c,"computeStop").urlPath:null,l=await this.getNonce(i,e,o,r,c);let d=e;d+=s||"",d+=t&&`${wt(t)}`||"",d+=l;const w=await this.signProviderRequest(n,e,d),u=Object();if(u.signature=w,u.documentId=wt(t),u.consumerAddress=e,s&&(u.jobId=s),!h)return null;try{const t=await a(h,{method:"PUT",body:JSON.stringify(u),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(f.error("Compute stop failed:",t.status,t.statusText),f.error("Payload was:",u),null)}catch(t){return f.error("Compute stop failed:"),f.error(t),f.error("Payload was:",u),null}}async computeStatus(t,e,s,i,n){const o=await this.getEndpoints(t),r=await this.getServiceEndpoints(t,o),c=this.getEndpointURL(r,"computeStatus")?this.getEndpointURL(r,"computeStatus").urlPath:null;let h=`?consumerAddress=${e}`;if(h+=i&&`&documentId=${wt(i)}`||"",h+=s&&`&jobId=${s}`||"",!c)return null;try{const t=await a(c+h,{method:"GET",headers:{"Content-Type":"application/json"},signal:n});return null!=t&&t.ok?await t.json():(f.error("Get compute status failed:",t.status,t.statusText),null)}catch(t){return f.error("Get compute status failed"),f.error(t),null}}async getComputeResultUrl(t,e,a,s,i){const n=await this.getEndpoints(t);console.log("computeResult providerEndpoints: ",n);const o=await this.getServiceEndpoints(t,n);console.log("computeResult serviceEndpoints: ",o);const r=this.getEndpointURL(o,"computeResult")?this.getEndpointURL(o,"computeResult").urlPath:null,c=Date.now();let h=a;h+=s,h+=i.toString(),h+=c;const l=await this.signProviderRequest(e,a,h);if(!r)return null;let d=r;return d+=`?consumerAddress=${a}`,d+=`&jobId=${s}`,d+=`&index=${i.toString()}`,d+=`&nonce=${c}`,d+=l&&`&signature=${l}`||"",d}async computeDelete(t,e,s,i,n,o){const r=await this.getEndpoints(i),c=await this.getServiceEndpoints(i,r),h=this.getEndpointURL(c,"computeDelete")?this.getEndpointURL(c,"computeDelete").urlPath:null,l=await this.getNonce(i,e,o,r,c);let d=e;d+=s||"",d+=t&&`${wt(t)}`||"",d+=l;const w=await this.signProviderRequest(n,e,d),u=Object();if(u.documentId=wt(t),u.consumerAddress=e,u.jobId=s,w&&(u.signature=w),!h)return null;try{const t=await a(h,{method:"DELETE",body:JSON.stringify(u),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(f.error("Delete compute job failed:",t.status,t.statusText),f.error("Payload was:",u),null)}catch(t){return f.error("Delete compute job failed:"),f.error(t),f.error("Payload was:",u),null}}async isValidProvider(t,e){try{const s=await a(t,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(null!=s&&s.ok){const t=await s.json();if(t&&t.providerAddress)return!0}return!1}catch(t){return f.error(`Error validating provider: ${t.message}`),!1}}}const mt=new ut;export{tt as Aquarius,dt as Config,$ as ConfigHelper,ht as Datatoken,st as Dispenser,it as FixedRateCreateProgressStep,nt as FixedRateExchange,E as GASLIMIT_DEFAULT,g as LogLevel,p as Logger,f as LoggerInstance,ct as Nft,lt as NftFactory,at as Pool,ut as Provider,mt as ProviderInstance,rt as Router,ot as SideStaking,T as ZERO_ADDRESS,z as allowance,G as amountToUnits,q as approve,J as balance,Z as calcMaxExactIn,H as calcMaxExactOut,N as configHelperNetworks,O as downloadFile,M as downloadFileBrowser,j as estApprove,P as fetchData,W as generateDid,b as generateDtName,L as getData,F as getErcCreationParams,R as getFairGasPrice,v as getFreCreationParams,k as getFreOrderParams,_ as getHash,K as getMaxAddLiquidity,Y as getMaxRemoveLiquidity,Q as getMaxSwapExactIn,X as getMaxSwapExactOut,S as getPoolCreationParams,D as postData,C as setContractDefaults,B as signHash,V as sleep,I as unitsToAmount};
//# sourceMappingURL=lib.modern.js.map
