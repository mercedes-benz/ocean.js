import t from"web3";import e from"bignumber.js";import a from"cross-fetch";import s from"@oceanprotocol/contracts/addresses/address.json";import n from"crypto-js/sha256";import i from"decimal.js";import o from"@oceanprotocol/contracts/artifacts/contracts/pools/balancer/BPool.sol/BPool.json";import r from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json";import c from"@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json";import h from"@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json";import l from"@oceanprotocol/contracts/artifacts/contracts/pools/ssContracts/SideStaking.sol/SideStaking.json";import d from"@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json";import u from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json";import w from"@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json";import m from"@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json";var g;!function(t){t[t.None=-1]="None",t[t.Error=0]="Error",t[t.Warn=1]="Warn",t[t.Log=2]="Log",t[t.Verbose=3]="Verbose"}(g||(g={}));class p{constructor(t=g.Error){this.logLevel=void 0,this.logLevel=t}setLevel(t){this.logLevel=t}bypass(...t){this.dispatch("log",-Infinity,...t)}debug(...t){this.dispatch("debug",g.Verbose,...t)}log(...t){this.dispatch("log",g.Log,...t)}warn(...t){this.dispatch("warn",g.Warn,...t)}error(...t){this.dispatch("error",g.Error,...t)}dispatch(t,e,...a){this.logLevel>=e&&console[t](...a)}}const f=new p;var b={nouns:["Crab","Fish","Seal","Octopus","Shark","Seahorse","Walrus","Starfish","Whale","Orca","Penguin","Jellyfish","Squid","Lobster","Pelican","Shrimp","Oyster","Clam","Seagull","Dolphin","Shell","Cormorant","Otter","Anemone","Turtle","Coral","Ray","Barracuda","Krill","Anchovy","Angelfish","Barnacle","Clownfish","Cod","Cuttlefish","Eel","Fugu","Herring","Haddock","Ling","Mackerel","Manatee","Narwhal","Nautilus","Plankton","Porpoise","Prawn","Pufferfish","Swordfish","Tuna"],adjectives:["adamant","adroit","amatory","ambitious","amused","animistic","antic","arcadian","artistic","astonishing","astounding","baleful","bellicose","bilious","blissful","boorish","brave","breathtaking","brilliant","calamitous","caustic","cerulean","clever","charming","comely","competent","concomitant","confident","contumacious","corpulent","crapulous","creative","dazzling","dedicated","defamatory","delighted","delightful","determined","didactic","dilatory","dowdy","efficacious","effulgent","egregious","empowered","endemic","enthusiastic","equanimous","exceptional","execrable","fabulous","fantastic","fastidious","feckless","fecund","friable","fulsome","garrulous","generous","gentle","guileless","gustatory","heuristic","histrionic","hubristic","incendiary","incredible","insidious","insolent","inspired","intransigent","inveterate","invidious","invigorated","irksome","jejune","juicy","jocular","joyful","judicious","kind","lachrymose","limpid","loquacious","lovely","luminous","mannered","marvelous","mendacious","meretricious","minatory","mordant","motivated","munificent","nefarious","noxious","obtuse","optimistic","parsimonious","pendulous","pernicious","pervasive","petulant","passionate","phenomenal","platitudinous","pleasant","powerful","precipitate","propitious","puckish","querulous","quiescent","rebarbative","recalcitant","redolent","rhadamanthine","risible","ruminative","sagacious","salubrious","sartorial","sclerotic","serpentine","smart","spasmodic","strident","stunning","stupendous","taciturn","tactful","tasty","tenacious","tremendous","tremulous","trenchant","turbulent","turgid","ubiquitous","uxorious","verdant","vibrant","voluble","voracious","wheedling","withering","wonderful","zealous"]};function y(t){const e=t||b,a=Math.floor(Math.random()*e.adjectives.length),s=Math.floor(Math.random()*e.nouns.length),n=Math.floor(100*Math.random()),i=e.adjectives[a].replace(/^\w/,t=>t.toUpperCase()),o=e.nouns[s].replace(/^\w/,t=>t.toUpperCase());return{name:`${i} ${o} Token`,symbol:`${(i.substring(0,3)+o.substring(0,3)).toUpperCase()}-${n}`}}const C=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}],k="0x0000000000000000000000000000000000000000",A=1e6;function T(t,e){return e&&(e.transactionBlockTimeout&&(t.transactionBlockTimeout=e.transactionBlockTimeout),e.transactionConfirmationBlocks&&(t.transactionConfirmationBlocks=e.transactionConfirmationBlocks),e.transactionPollingTimeout&&(t.transactionPollingTimeout=e.transactionPollingTimeout)),t}async function R(t,a){const s=new e(await t.eth.getGasPrice());return a&&a.gasFeeMultiplier?s.multipliedBy(a.gasFeeMultiplier).integerValue(e.ROUND_DOWN).toString(10):s.toString(10)}function E(e){let a,s;return e.name&&e.symbol||({name:a,symbol:s}=y()),{templateIndex:e.templateIndex,strings:[e.name||a,e.symbol||s],addresses:[e.minter,e.paymentCollector,e.mpFeeAddress,e.feeToken],uints:[t.utils.toWei(e.cap),t.utils.toWei(e.feeAmount)],bytess:[]}}function v(e){return{exchangeContract:e.exchangeContract,exchangeId:e.exchangeId,maxBaseTokenAmount:t.utils.toWei(e.maxBaseTokenAmount),swapMarketFee:t.utils.toWei(e.swapMarketFee),marketFeeAddress:e.marketFeeAddress}}function F(e){e.allowedConsumer||(e.allowedConsumer=k);const a=e.withMint?1:0;return{fixedPriceAddress:e.fixedRateAddress,addresses:[e.baseTokenAddress,e.owner,e.marketFeeCollector,e.allowedConsumer],uints:[e.baseTokenDecimals,e.datatokenDecimals,t.utils.toWei(e.fixedRate),t.utils.toWei(e.marketFee),a]}}async function P(e,a){return{addresses:[a.ssContract,a.baseTokenAddress,a.baseTokenSender,a.publisherAddress,a.marketFeeCollector,a.poolTemplateAddress],ssParams:[t.utils.toWei(a.rate),a.baseTokenDecimals,t.utils.toWei(a.vestingAmount),a.vestedBlocks,await S(e,a.baseTokenAddress,a.initialBaseTokenLiquidity)],swapFees:[t.utils.toWei(a.swapFeeLiquidityProvider),t.utils.toWei(a.swapFeeMarketRunner)]}}async function O(t,a,s,n){try{const i=new t.eth.Contract(C,a);let o=n||await i.methods.decimals().call();"0"===o&&(o=18);const r=new e(s).div(new e(10).exponentiatedBy(o));return e.config({EXPONENTIAL_AT:50}),r.toString()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18' : ${t.message}`)}}async function S(t,a,s,n){try{const i=new t.eth.Contract(C,a);let o=n||await i.methods.decimals().call();return"0"===o&&(o=18),e.config({EXPONENTIAL_AT:50}),new e(s).times(new e(10).exponentiatedBy(o)).toString()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18', ${t.message}`)}}async function x(t,e,...a){let s=1e6;try{s=await e.apply(null,a).estimateGas({from:t},(t,e)=>t?1e6:e)}catch(t){f.error("ERROR: Estimate gas failed!",t)}return s}async function M(t,e){const s=await a(t,e);if(!s.ok)throw f.error(`Error requesting [${e.method}] ${t}`),f.error(`Response message: \n${await s.text()}`),s;return s}async function D(t){const e=document.createElement("a");e.download="",e.href=t,e.click()}async function U(t,e){const s=await a(t);if(!s.ok)throw new Error("Response error.");let n;try{n=s.headers.get("content-disposition").match(/attachment;filename=(.+)/)[1]}catch(a){try{n=t.split("/").pop()}catch(t){n=`file${e}`}}return{data:await s.arrayBuffer(),filename:n}}async function I(t){return a(t,{method:"GET",headers:{"Content-type":"application/json"}})}async function W(t,e){return async function(t,e,s){return a(t,null!=e?{method:"POST",body:e,headers:{"Content-type":"application/json"}}:{method:"POST"})}(t,e)}function N(){return N=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&(t[s]=a[s])}return t},N.apply(this,arguments)}const $={chainId:null,network:"unknown",metadataCacheUri:"https://v4.aquarius.oceanprotocol.com",nodeUri:"http://127.0.0.1:8545",providerUri:"http://127.0.0.1:8030",subgraphUri:null,explorerUri:null,oceanTokenAddress:null,oceanTokenSymbol:"OCEAN",poolTemplateAddress:null,fixedRateExchangeAddress:null,dispenserAddress:null,startBlock:0,transactionBlockTimeout:50,transactionConfirmationBlocks:1,transactionPollingTimeout:750,gasFeeMultiplier:1},G=[N({},$),N({},$,{chainId:8996,network:"development",metadataCacheUri:"http://127.0.0.1:5000",providerUri:"http://172.15.0.4:8030"}),N({},$,{chainId:3,network:"ropsten",nodeUri:"https://ropsten.infura.io/v3",providerUri:"https://v4.provider.ropsten.oceanprotocol.com",subgraphUri:"https://v4.subgraph.ropsten.oceanprotocol.com",explorerUri:"https://ropsten.etherscan.io",gasFeeMultiplier:1.1}),N({},$,{chainId:4,network:"rinkeby",nodeUri:"https://rinkeby.infura.io/v3",providerUri:"https://v4.provider.rinkeby.oceanprotocol.com",subgraphUri:"https://v4.subgraph.rinkeby.oceanprotocol.com",explorerUri:"https://rinkeby.etherscan.io",gasFeeMultiplier:1.1}),N({},$,{chainId:1,network:"mainnet",nodeUri:"https://mainnet.infura.io/v3",providerUri:"https://v4.provider.mainnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mainnet.oceanprotocol.com",explorerUri:"https://etherscan.io",startBlock:11105459,transactionBlockTimeout:150,transactionConfirmationBlocks:5,transactionPollingTimeout:1750,gasFeeMultiplier:1.05}),N({},$,{chainId:137,network:"polygon",nodeUri:"https://polygon-mainnet.infura.io/v3",providerUri:"https://v4.provider.polygon.oceanprotocol.com",subgraphUri:"https://v4.subgraph.polygon.oceanprotocol.com",explorerUri:"https://polygonscan.com",oceanTokenSymbol:"mOCEAN"}),N({},$,{chainId:1287,network:"moonbase",nodeUri:"https://rpc.api.moonbase.moonbeam.network",providerUri:"https://v4.provider.moonbase.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonbase.oceanprotocol.com",explorerUri:"https://moonbase.moonscan.io/",gasFeeMultiplier:1.1}),N({},$,{chainId:2021e3,network:"gaiaxtestnet",nodeUri:"https://rpc.gaiaxtestnet.oceanprotocol.com",providerUri:"https://v4.provider.gaiaxtestnet.oceanprotocol.com",subgraphUri:"https://v4.subgraph.gaiaxtestnet.oceanprotocol.com",explorerUri:"https://blockscout.gaiaxtestnet.oceanprotocol.com"}),N({},$,{chainId:80001,network:"mumbai",nodeUri:"https://polygon-mumbai.infura.io/v3",providerUri:"https://v4.provider.mumbai.oceanprotocol.com",subgraphUri:"https://v4.subgraph.mumbai.oceanprotocol.com",explorerUri:"https://mumbai.polygonscan.com",gasFeeMultiplier:1.1}),N({},$,{chainId:56,network:"bsc",nodeUri:"https://bsc-dataseed.binance.org",providerUri:"https://v4.provider.bsc.oceanprotocol.com",subgraphUri:"https://v4.subgraph.bsc.oceanprotocol.com",explorerUri:"https://bscscan.com/",gasFeeMultiplier:1.05}),N({},$,{chainId:246,network:"energyweb",nodeUri:"https://rpc.energyweb.org",providerUri:"https://v4.provider.energyweb.oceanprotocol.com",subgraphUri:"https://v4.subgraph.energyweb.oceanprotocol.com",explorerUri:"https://explorer.energyweb.org",gasFeeMultiplier:1.05}),N({},$,{chainId:1285,network:"moonriver",nodeUri:"https://moonriver.api.onfinality.io/public",providerUri:"https://v4.provider.moonriver.oceanprotocol.com",subgraphUri:"https://v4.subgraph.moonriver.oceanprotocol.com",explorerUri:"https://moonriver.moonscan.io/",gasFeeMultiplier:1.05})];class B{getAddressesFromEnv(t,e){let a;if(e)try{const{FixedPrice:s,Dispenser:n,Staking:i,poolTemplate:o,ERC721Factory:r,OPFCommunityFeeCollector:c,Ocean:h,chainId:l,startBlock:d}=e[t];a=N({erc721FactoryAddress:r,sideStakingAddress:i,opfCommunityFeeCollector:c,poolTemplateAddress:o,fixedRateExchangeAddress:s,dispenserAddress:n,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}catch(t){}else if(s[t]){const{FixedPrice:e,Dispenser:n,Staking:i,poolTemplate:o,OPFCommunityFeeCollector:r,ERC721Factory:c,Ocean:h,chainId:l,startBlock:d}=s[t];a=N({erc721FactoryAddress:c,sideStakingAddress:i,opfCommunityFeeCollector:r,poolTemplateAddress:o,fixedRateExchangeAddress:e,dispenserAddress:n,oceanTokenAddress:h,chainId:l,startBlock:d},process.env.AQUARIUS_URI&&{metadataCacheUri:process.env.AQUARIUS_URI})}return a}getConfig(t,e){const a="string"==typeof t?"network":"chainId";let s=G.find(e=>e[a]===t);return s?(s=N({},s,this.getAddressesFromEnv(s.network)),N({},s,{nodeUri:e?`${s.nodeUri}/${e}`:s.nodeUri})):(f.error(`No config found for given network '${t}'`),null)}}function L(e,a){return e=t.utils.toChecksumAddress(e),`did:op:${n(e+a.toString(10)).toString()}`}function j(t){try{return n(t).toString()}catch(t){f.error("getHash error: ",t.message)}}async function q(t,e,a){let s=await t.eth.sign(e,a);s=s.substr(2);const n="0x"+s.slice(0,64),i="0x"+s.slice(64,128);let o="0x"+s.slice(128,130);return"0x00"===o&&(o="0x1b"),"0x01"===o&&(o="0x1c"),{v:o,r:n,s:i}}async function z(t,e,a,s,n,i){return x(e,(i||new t.eth.Contract(C,a)).methods.approve,s,n)}async function _(t,e,a,s,n,o=!1,r,c){const h=T(new t.eth.Contract(C,a),c);if(!o){const o=await H(t,a,e,s,r,c);if(new i(o).greaterThanOrEqualTo(new i(n)))return o}let l=null;const d=await S(t,a,n,r),u=await x(e,h.methods.approve,s,d);try{l=await h.methods.approve(s,d).send({from:e,gas:u+1,gasPrice:await R(t,c)})}catch(t){f.error(`ERROR: Failed to approve spender to spend tokens : ${t.message}`)}return l}async function J(t,e,a,s,n,i){return x(e,(i||new t.eth.Contract(C,a)).methods.transfer,s,n)}async function V(t,e,a,s,n){const i=new t.eth.Contract(C,a);let o=null;const r=await S(t,a,n),c=await x(e,i.methods.transfer,s,r);try{o=await i.methods.transfer(s,r).send({from:e,gas:c+1,gasPrice:await R(t,null)})}catch(t){f.error(`ERROR: Failed to transfer tokens : ${t.message}`)}return o}async function H(t,e,a,s,n,i){const o=T(new t.eth.Contract(C,e),i),r=await o.methods.allowance(a,s).call();return await O(t,e,r,n)}async function Z(t,e,a,s,n){const i=T(new t.eth.Contract(C,e),n),o=await i.methods.balanceOf(a).call();return await O(t,e,o,s)}async function X(t){return new Promise(e=>{setTimeout(e,t)})}function Q(t){return new i(t).div(2)}function K(t){return new i(t).div(2)}async function Y(t,e,a){return Q(await t.getReserve(e,a))}async function tt(t,e,a){return K(await t.getReserve(e,a))}async function et(t,e,a){return K(await t.getReserve(e,a))}async function at(t,e,a){return K(await t.getReserve(e,a))}class st{constructor(t){this.aquariusURL=void 0,this.aquariusURL=t}async resolve(t,e){const s=this.aquariusURL+"/api/aquarius/assets/ddo/"+t;try{const t=await a(s,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(t.ok)return await t.json();throw new Error("HTTP request failed with status "+t.status)}catch(t){throw f.error(t),new Error("HTTP request failed")}}async waitForAqua(t,e,s){let n=0;do{try{const n=this.aquariusURL+"/api/aquarius/assets/ddo/"+t,i=await a(n,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});if(i.ok){const t=await i.json();if(!e)return t;if(t.event&&t.event.txid===e)return t}}catch(t){}await X(1500),n++}while(n<100);return null}async validate(t,e){const s={valid:!1};let n;try{const i=this.aquariusURL+"/api/aquarius/assets/ddo/validate",o=await a(i,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:e});n=await o.json(),200===o.status?(s.valid=!0,s.hash=n.hash,s.proof={validatorAddress:n.publicKey,r:n.r[0],s:n.s[0],v:n.v}):(s.errors=n,f.error("validate Metadata failed:",o.status,s.errors))}catch(t){f.error("Error validating metadata: ",t)}return s}}const nt="115792089237316195423570985008687907853269984665640564039457584007913129639934";class it{constructor(t,e,a=null,s){this.poolAbi=void 0,this.web3=void 0,this.config=void 0,this.poolAbi=a||o.abi,this.web3=t,this.config=s||(new B).getConfig(e||"unknown")}async amountToUnits(t,e,a){return S(this.web3,t,e,a)}async unitsToAmount(t,e,a){return O(this.web3,t,e,a)}async sharesBalance(t,e){let a=null;try{const s=T(new this.web3.eth.Contract(this.poolAbi,e),this.config),n=await s.methods.balanceOf(t).call();a=this.web3.utils.fromWei(n)}catch(t){f.error(`ERROR: Failed to get shares of pool : ${t.message}`)}return a}async estSetSwapFee(t,e,a,s){return x(t,(s||T(new this.web3.eth.Contract(r.abi,e),this.config)).methods.setSwapFee,a)}async setSwapFee(t,e,a){const s=T(new this.web3.eth.Contract(this.poolAbi,e,{from:t}),this.config);let n=null;const i=await x(t,s.methods.setSwapFee,a);try{n=await s.methods.setSwapFee(this.web3.utils.toWei(a)).send({from:t,gas:i,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to set pool swap fee: ${t.message}`)}return n}async getNumTokens(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getNumTokens().call()}catch(t){f.error(`ERROR: Failed to get number of tokens: ${t.message}`)}return a}async getPoolSharesTotalSupply(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.totalSupply().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get total supply of pool shares: ${t.message}`)}return a}async getCurrentTokens(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getCurrentTokens().call()}catch(t){f.error(`ERROR: Failed to get tokens composing this pool: ${t.message}`)}return a}async getFinalTokens(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getFinalTokens().call()}catch(t){f.error(`ERROR: Failed to get the final tokens composing this pool ${t.message}`)}return a}async getController(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getController().call()}catch(t){f.error(`ERROR: Failed to get pool controller address: ${t.message}`)}return a}async getBaseToken(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getBaseTokenAddress().call()}catch(t){f.error(`ERROR: Failed to get baseToken address: ${t.message}`)}return a}async getDatatoken(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getDatatokenAddress().call()}catch(t){f.error(`ERROR: Failed to get datatoken address: ${t.message}`)}return a}async getMarketFee(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.getMarketFee().call()}catch(t){f.error(`ERROR: Failed to get getMarketFee: ${t.message}`)}return this.web3.utils.fromWei(a).toString()}async getMarketFeeCollector(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods._publishMarketCollector().call()}catch(t){f.error(`ERROR: Failed to get marketFeeCollector address: ${t.message}`)}return a}async isBound(t,e){const a=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{s=await a.methods.isBound(e).call()}catch(t){f.error(`ERROR: Failed to check whether a token       bounded to a pool. ${t.message}`)}return s}async getReserve(t,e,a){let s=null;try{const n=T(new this.web3.eth.Contract(this.poolAbi,t),this.config),i=await n.methods.getBalance(e).call();s=await this.unitsToAmount(e,i,a)}catch(t){f.error(`ERROR: Failed to get how many tokens       are in the pool: ${t.message}`)}return s.toString()}async isFinalized(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{a=await e.methods.isFinalized().call()}catch(t){f.error(`ERROR: Failed to check whether pool is finalized: ${t.message}`)}return a}async getSwapFee(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getSwapFee().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get pool fee: ${t.message}`)}return a}async getNormalizedWeight(t,e){const a=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getNormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get normalized weight of a token: ${t.message}`)}return s}async getDenormalizedWeight(t,e){const a=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let s=null;try{const t=await a.methods.getDenormalizedWeight(e).call();s=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get denormalized weight of a token in pool ${t.message}`)}return s}async getTotalDenormalizedWeight(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let a=null;try{const t=await e.methods.getTotalDenormalizedWeight().call();a=this.web3.utils.fromWei(t)}catch(t){f.error(`ERROR: Failed to get total denormalized weight in pool ${t.message}`)}return a}async getMarketFees(t,e,a){const s=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let n=null;try{const t=await s.methods.publishMarketFees(e).call();n=await this.unitsToAmount(e,t,a)}catch(t){f.error(`ERROR: Failed to get market fees for a token: ${t.message}`)}return n}async getCurrentMarketFees(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCurrentOPCFees(t){const e=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);try{return await e.methods.getCurrentOPCFees().call()}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}}async getCommunityFees(t,e,a){const s=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let n=null;try{const t=await s.methods.communityFees(e).call();n=await this.unitsToAmount(e,t,a)}catch(t){f.error(`ERROR: Failed to get community fees for a token: ${t.message}`)}return n}async estCollectOPC(t,e,a){return x(t,(a||T(new this.web3.eth.Contract(this.poolAbi,e),this.config)).methods.collectOPC)}async collectOPC(t,e){const a=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const n=await x(t,a.methods.collectOPC);try{s=await a.methods.collectOPC().send({from:t,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estCollectMarketFee(t,e,a){return x(t,(a||T(new this.web3.eth.Contract(this.poolAbi,e),this.config)).methods.collectMarketFee)}async collectMarketFee(t,e){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const a=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let s=null;const n=await x(t,a.methods.collectMarketFee);try{s=await a.methods.collectMarketFee().send({from:t,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return s}async estUpdatePublishMarketFee(t,e,a,s,n){return x(t,(n||T(new this.web3.eth.Contract(this.poolAbi,e),this.config)).methods.updatePublishMarketFee,a,this.web3.utils.toWei(s))}async updatePublishMarketFee(t,e,a,s){if(await this.getMarketFeeCollector(e)!==t)throw new Error("Caller is not MarketFeeCollector");const n=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let i=null;const o=await x(t,n.methods.updatePublishMarketFee,a,this.web3.utils.toWei(s));try{i=await n.methods.updatePublishMarketFee(a,this.web3.utils.toWei(s)).send({from:t,gas:o+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to updatePublishMarketFee : ${t.message}`)}return i}async estSwapExactAmountIn(t,e,a,s,n){const i=n||T(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await this.amountToUnits(a.tokenIn,s.tokenAmountIn,a.tokenInDecimals),r=await this.amountToUnits(a.tokenOut,s.minAmountOut,a.tokenOutDecimals),c=s.maxPrice?this.amountToUnits(await this.getBaseToken(e),s.maxPrice):nt;return x(t,i.methods.swapExactAmountIn,[a.tokenIn,a.tokenOut,a.marketFeeAddress],[o,r,c,this.web3.utils.toWei(s.swapMarketFee)])}async swapExactAmountIn(t,e,a,s){const n=T(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await tt(this,e,a.tokenIn);if(new i(s.tokenAmountIn).greaterThan(o))throw new Error(`tokenAmountIn is greater than ${o.toString()}`);const r=await this.amountToUnits(a.tokenIn,s.tokenAmountIn,a.tokenInDecimals),c=await this.amountToUnits(a.tokenOut,s.minAmountOut,a.tokenOutDecimals),h=s.maxPrice?await this.amountToUnits(await this.getBaseToken(e),s.maxPrice):nt,l=await x(t,n.methods.swapExactAmountIn,[a.tokenIn,a.tokenOut,a.marketFeeAddress],[r,c,h,this.web3.utils.toWei(s.swapMarketFee)]);let d=null;try{d=await n.methods.swapExactAmountIn([a.tokenIn,a.tokenOut,a.marketFeeAddress],[r,c,h,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount in : ${t.message}`)}return d}async estSwapExactAmountOut(t,e,a,s,n){const i=n||T(new this.web3.eth.Contract(this.poolAbi,e),this.config),o=await this.amountToUnits(a.tokenIn,s.maxAmountIn,a.tokenInDecimals),r=await this.amountToUnits(a.tokenOut,s.tokenAmountOut,a.tokenOutDecimals),c=s.maxPrice?await this.amountToUnits(await this.getBaseToken(e),s.maxPrice):nt;return x(t,i.methods.swapExactAmountOut,[a.tokenIn,a.tokenOut,a.marketFeeAddress],[o,r,c,this.web3.utils.toWei(s.swapMarketFee)])}async swapExactAmountOut(t,e,a,s){const n=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let o=null;const r=await Y(this,e,a.tokenOut);if(new i(s.tokenAmountOut).greaterThan(r))throw new Error(`tokenAmountOut is greater than ${r.toString()}`);const c=await this.amountToUnits(a.tokenIn,s.maxAmountIn,a.tokenInDecimals),h=await this.amountToUnits(a.tokenOut,s.tokenAmountOut,a.tokenOutDecimals),l=s.maxPrice?this.amountToUnits(await this.getBaseToken(e),s.maxPrice):nt,d=await x(t,n.methods.swapExactAmountOut,[a.tokenIn,a.tokenOut,a.marketFeeAddress],[c,h,l,this.web3.utils.toWei(s.swapMarketFee)]);try{o=await n.methods.swapExactAmountOut([a.tokenIn,a.tokenOut,a.marketFeeAddress],[c,h,l,this.web3.utils.toWei(s.swapMarketFee)]).send({from:t,gas:d+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to swap exact amount out: ${t.message}`)}return o}async estJoinswapExternAmountIn(t,e,a,s,n){return x(t,(n||T(new this.web3.eth.Contract(this.poolAbi,e),this.config)).methods.joinswapExternAmountIn,a,s)}async joinswapExternAmountIn(t,e,a,s,n){const o=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let r=null;const c=await this.getBaseToken(e),h=await et(this,e,c);if(new i(a).greaterThan(h))throw new Error(`tokenAmountOut is greater than ${h.toString()}`);const l=await this.amountToUnits(c,a,n),d=await x(t,o.methods.joinswapExternAmountIn,l,this.web3.utils.toWei(s));try{r=await o.methods.joinswapExternAmountIn(l,this.web3.utils.toWei(s)).send({from:t,gas:d+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to pay tokens in order to       join the pool: ${t.message}`)}return r}async estExitswapPoolAmountIn(t,e,a,s,n){return x(t,(n||T(new this.web3.eth.Contract(this.poolAbi,e),this.config)).methods.exitswapPoolAmountIn,a,s)}async exitswapPoolAmountIn(t,e,a,s,n){const o=T(new this.web3.eth.Contract(this.poolAbi,e),this.config);let r=null;const c=await this.getBaseToken(e),h=await this.calcSingleOutGivenPoolIn(e,c,a),l=await at(this,e,c);if(new i(h).greaterThan(l))throw new Error(`tokenAmountOut is greater than ${l.toString()}`);const d=await this.amountToUnits(await this.getBaseToken(e),s,n),u=await x(t,o.methods.exitswapPoolAmountIn,this.web3.utils.toWei(a),d);try{r=await o.methods.exitswapPoolAmountIn(this.web3.utils.toWei(a),d).send({from:t,gas:u+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to pay pool shares into the pool: ${t.message}`)}return r}async getSpotPrice(t,a,s,n){const i=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=18,c=18;const h=T(new this.web3.eth.Contract(r.abi,a),this.config),l=T(new this.web3.eth.Contract(r.abi,s),this.config);try{o=await h.methods.decimals().call()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}try{c=await l.methods.decimals().call()}catch(t){f.error(`ERROR: FAILED TO CALL DECIMALS(), USING 18 ${t.message}`)}let d,u=null;try{u=await i.methods.getSpotPrice(a,s,this.web3.utils.toWei(n)).call(),u=new e(u.toString())}catch(t){f.error("ERROR: Failed to get spot price of swapping tokenIn to tokenOut")}return o>c?(d=o-c,u=new e(u/10**d),u/=10**c):(d=c-o,u=new e(u*10**(2*d)),u/=10**c),u.toString()}async getAmountInExactOut(t,e,a,s,n,o,r){const c=T(new this.web3.eth.Contract(this.poolAbi,t),this.config),h=await Y(this,t,a);if(new i(s).greaterThan(h))throw new Error(`tokenAmountOut is greater than ${h.toString()}`);const l=await this.amountToUnits(a,s,r);let d=null;try{const t=await c.methods.getAmountInExactOut(e,a,l,this.web3.utils.toWei(n)).call();d={tokenAmount:await this.unitsToAmount(a,t.tokenAmountIn,r),liquidityProviderSwapFeeAmount:await this.unitsToAmount(e,t.lpFeeAmount,o),oceanFeeAmount:await this.unitsToAmount(e,t.oceanFeeAmount,o),publishMarketSwapFeeAmount:await this.unitsToAmount(e,t.publishMarketSwapFeeAmount,o),consumeMarketSwapFeeAmount:await this.unitsToAmount(e,t.consumeMarketSwapFeeAmount,o)}}catch(t){f.error(`ERROR: Failed to calcInGivenOut ${t.message}`)}return d}async getAmountOutExactIn(t,e,a,s,n,o,r){const c=T(new this.web3.eth.Contract(this.poolAbi,t),this.config),h=await tt(this,t,e);if(new i(s).greaterThan(h))throw new Error(`tokenAmountIn is greater than ${h.toString()}`);const l=await this.amountToUnits(e,s,o);let d=null;try{const t=await c.methods.getAmountOutExactIn(e,a,l,this.web3.utils.toWei(n)).call();d={tokenAmount:await this.unitsToAmount(a,t.tokenAmountOut,r),liquidityProviderSwapFeeAmount:await this.unitsToAmount(e,t.lpFeeAmount,o),oceanFeeAmount:await this.unitsToAmount(e,t.oceanFeeAmount,o),publishMarketSwapFeeAmount:await this.unitsToAmount(e,t.publishMarketSwapFeeAmount,o),consumeMarketSwapFeeAmount:await this.unitsToAmount(e,t.consumeMarketSwapFeeAmount,o)}}catch(t){f.error(`ERROR: Failed to calcOutGivenIn ${t.message}`)}return d}async calcPoolOutGivenSingleIn(t,e,a,s,n){const i=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=null;try{const r=await i.methods.calcPoolOutSingleIn(e,await this.amountToUnits(e,a,n)).call();o=await this.unitsToAmount(t,r,s)}catch(t){f.error(`ERROR: Failed to calculate PoolOutGivenSingleIn : ${t.message}`)}return o}async calcSingleInGivenPoolOut(t,e,a,s,n){const i=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=null;const r=await this.amountToUnits(t,a,s);try{const t=await i.methods.calcSingleInPoolOut(e,r).call();o=await this.unitsToAmount(e,t,n)}catch(t){f.error(`ERROR: Failed to calculate SingleInGivenPoolOut : ${t.message}`)}return o}async calcSingleOutGivenPoolIn(t,e,a,s,n){const i=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=null;try{const r=await i.methods.calcSingleOutPoolIn(e,await this.amountToUnits(t,a,s)).call();o=await this.unitsToAmount(e,r,n)}catch(t){f.error(`ERROR: Failed to calculate SingleOutGivenPoolIn : ${t}`)}return o}async calcPoolInGivenSingleOut(t,e,a,s,n){const i=T(new this.web3.eth.Contract(this.poolAbi,t),this.config);let o=null;try{const r=await i.methods.calcPoolInSingleOut(e,await this.amountToUnits(e,a,n)).call();o=await this.unitsToAmount(t,r,s)}catch(t){f.error(`ERROR: Failed to calculate PoolInGivenSingleOut : ${t.message}`)}return o}getSwapEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_SWAP"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getJoinEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_JOIN"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}getExitEventSignature(){const t=this.poolAbi.find(function(t){if("LOG_EXIT"===t.name&&"event"===t.type)return t});return this.web3.eth.abi.encodeEventSignature(t)}}class ot{constructor(t,e,a=null,s=null,n){this.web3=null,this.dispenserAddress=void 0,this.config=void 0,this.dispenserAbi=void 0,this.dispenserContract=void 0,this.web3=t,this.dispenserAddress=a,this.dispenserAbi=s||c.abi,this.config=n||(new B).getConfig(e||"unknown"),t&&(this.dispenserContract=T(new this.web3.eth.Contract(this.dispenserAbi,this.dispenserAddress),this.config))}async status(t){try{const e=await this.dispenserContract.methods.status(t).call();return e.maxTokens=this.web3.utils.fromWei(e.maxTokens),e.maxBalance=this.web3.utils.fromWei(e.maxBalance),e.balance=this.web3.utils.fromWei(e.balance),e}catch(e){f.warn(`No dispenser available for datatoken: ${t}`)}return null}async estGasCreate(t,e,a,s,n){return x(e,this.dispenserContract.methods.create,t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,n)}async create(t,e,a,s,n){const i=await x(e,this.dispenserContract.methods.create,t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,n);return await this.dispenserContract.methods.create(t,this.web3.utils.toWei(a),this.web3.utils.toWei(s),e,n).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasActivate(t,e,a,s){return x(s,this.dispenserContract.methods.activate,t,this.web3.utils.toWei(e),this.web3.utils.toWei(a))}async activate(t,e,a,s){try{const n=await x(s,this.dispenserContract.methods.activate,t,this.web3.utils.toWei(e),this.web3.utils.toWei(a));return await this.dispenserContract.methods.activate(t,this.web3.utils.toWei(e),this.web3.utils.toWei(a)).send({from:s,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDeactivate(t,e){return x(e,this.dispenserContract.methods.deactivate,t)}async deactivate(t,e){try{const a=await x(e,this.dispenserContract.methods.deactivate,t);return await this.dispenserContract.methods.deactivate(t).send({from:e,gas:a+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasSetAllowedSwapper(t,e,a){return x(e,this.dispenserContract.methods.setAllowedSwapper,t,a)}async setAllowedSwapper(t,e,a){try{const s=await x(e,this.dispenserContract.methods.setAllowedSwapper,t,a);return await this.dispenserContract.methods.setAllowedSwapper(t,a).send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to activate dispenser: ${t.message}`)}return null}async estGasDispense(t,e,a="1",s){return x(e,this.dispenserContract.methods.dispense,t,this.web3.utils.toWei(a),s)}async dispense(t,e,a="1",s){const n=await x(e,this.dispenserContract.methods.dispense,t,this.web3.utils.toWei(a),s);try{return await this.dispenserContract.methods.dispense(t,this.web3.utils.toWei(a),s).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to dispense tokens: ${t.message}`)}return null}async estGasOwnerWithdraw(t,e){return x(e,this.dispenserContract.methods.ownerWithdraw,t)}async ownerWithdraw(t,e){const a=await x(e,this.dispenserContract.methods.ownerWithdraw,t);try{return await this.dispenserContract.methods.ownerWithdraw(t).send({from:e,gas:a+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error(`ERROR: Failed to withdraw tokens: ${t.message}`)}return null}async isDispensable(t,e,a,s="1"){const n=await this.status(t);return!(!n||!1===n.active||new i(await e.balance(t,a)).greaterThanOrEqualTo(n.maxBalance)||new i(String(s)).greaterThan(n.maxTokens)||!new i(n.balance).greaterThanOrEqualTo(s)&&!0!==n.isMinter)}}var rt;!function(t){t[t.CreatingExchange=0]="CreatingExchange",t[t.ApprovingDatatoken=1]="ApprovingDatatoken"}(rt||(rt={}));class ct{constructor(t,e,a,s=null,n=null,i){this.oceanAddress=null,this.fixedRateAddress=void 0,this.fixedRateExchangeAbi=void 0,this.fixedRateContract=void 0,this.web3=void 0,this.contract=null,this.config=void 0,this.ssAbi=void 0,this.web3=t,this.config=i||(new B).getConfig(a||"unknown"),this.fixedRateExchangeAbi=s||h.abi,this.oceanAddress=n,this.fixedRateAddress=e,this.contract=T(new this.web3.eth.Contract(this.fixedRateExchangeAbi,this.fixedRateAddress),this.config)}async amountToUnits(t,e,a){return S(this.web3,t,e,a)}async unitsToAmount(t,e,a){return O(this.web3,t,e,a)}async generateExchangeId(t,e){return await this.contract.methods.generateExchangeId(t,e).call()}async estBuyDT(t,e,a,s,n,i,o){return x(t,(o||this.fixedRateContract).methods.buyDT,e,a,s,n,i)}async buyDT(t,e,a,s,n=k,i="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(i),c=await S(this.web3,o.datatoken,a,+o.dtDecimals),h=await S(this.web3,o.baseToken,s,+o.btDecimals),l=await x(t,this.contract.methods.buyDT,e,c,h,n,r);try{return await this.contract.methods.buyDT(e,c,h,n,r).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){return f.error(`ERROR: Failed to buy datatokens: ${t.message}`),null}}async estSellDT(t,e,a,s,n,i,o){return x(t,(o||this.fixedRateContract).methods.sellDT,e,a,s,n,i)}async sellDT(t,e,a,s,n=k,i="0"){const o=await this.getExchange(e),r=this.web3.utils.toWei(i),c=await S(this.web3,o.datatoken,a,+o.dtDecimals),h=await S(this.web3,o.baseToken,s,+o.btDecimals),l=await x(t,this.contract.methods.sellDT,e,c,h,n,r);try{return await this.contract.methods.sellDT(e,c,h,n,r).send({from:t,gas:l+1,gasPrice:await R(this.web3,this.config)})}catch(t){return f.error(`ERROR: Failed to sell datatokens: ${t.message}`),null}}async getNumberOfExchanges(){return await this.contract.methods.getNumberOfExchanges().call()}async estSetRate(t,e,a,s){return x(t,(s||this.fixedRateContract).methods.setRate,e,await this.web3.utils.toWei(a))}async setRate(t,e,a){const s=await x(t,this.contract.methods.setRate,e,this.web3.utils.toWei(a));return await this.contract.methods.setRate(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estSetAllowedSwapper(t,e,a,s){return x(t,(s||this.fixedRateContract).methods.setRate,e,a)}async setAllowedSwapper(t,e,a){const s=await x(t,this.contract.methods.setAllowedSwapper,e,a);return await this.contract.methods.setAllowedSwapper(e,a).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estActivate(t,e,a){return x(t,(a||this.fixedRateContract).methods.toggleExchangeState,e)}async activate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.active)return null;const s=await x(t,this.contract.methods.toggleExchangeState,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estDeactivate(t,e,a){return x(t,(a||this.fixedRateContract).methods.toggleExchangeState,e)}async deactivate(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.active)return null;const s=await x(t,this.contract.methods.toggleExchangeState,e);return await this.contract.methods.toggleExchangeState(e).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async getRate(t){const e=await this.contract.methods.getRate(t).call();return await this.web3.utils.fromWei(e)}async getDTSupply(t){const e=await this.contract.methods.getDTSupply(t).call(),a=await this.getExchange(t);return await this.unitsToAmount(a.datatoken,e,+a.dtDecimals)}async getBTSupply(t){const e=await this.contract.methods.getBTSupply(t).call(),a=await this.getExchange(t);return await this.unitsToAmount(a.baseToken,e,+a.btDecimals)}async getAllowedSwapper(t){return await this.contract.methods.getAllowedSwapper(t).call()}async calcBaseInGivenOutDT(t,e,a="0"){const s=await this.getExchange(t),n=await this.contract.methods.calcBaseInGivenOutDT(t,await this.amountToUnits(s.datatoken,e,+s.dtDecimals),this.web3.utils.toWei(a)).call();return{baseTokenAmount:await O(this.web3,s.baseToken,n.baseTokenAmount,+s.btDecimals),marketFeeAmount:await O(this.web3,s.baseToken,n.marketFeeAmount,+s.btDecimals),oceanFeeAmount:await O(this.web3,s.baseToken,n.oceanFeeAmount,+s.btDecimals),consumeMarketFeeAmount:await O(this.web3,s.baseToken,n.consumeMarketFeeAmount,+s.btDecimals)}}async getAmountBTOut(t,e,a="0"){const s=await this.getExchange(t),n=await this.contract.methods.calcBaseOutGivenInDT(t,await this.amountToUnits(s.datatoken,e,+s.dtDecimals),this.web3.utils.toWei(a)).call();return await this.unitsToAmount(s.baseToken,n[0],+s.btDecimals)}async getExchange(t){const e=await this.contract.methods.getExchange(t).call();return e.dtDecimals=e.dtDecimals.toString(),e.btDecimals=e.btDecimals.toString(),e.dtBalance=await this.unitsToAmount(e.datatoken,e.dtBalance,+e.dtDecimals),e.btBalance=await this.unitsToAmount(e.baseToken,e.btBalance,+e.btDecimals),e.dtSupply=await this.unitsToAmount(e.datatoken,e.dtSupply,+e.dtDecimals),e.btSupply=await this.unitsToAmount(e.baseToken,e.btSupply,+e.btDecimals),e.fixedRate=this.web3.utils.fromWei(e.fixedRate),e.exchangeId=t,e}async getFeesInfo(t){const e=await this.contract.methods.getFeesInfo(t).call();e.opcFee=this.web3.utils.fromWei(e.opcFee.toString()),e.marketFee=this.web3.utils.fromWei(e.marketFee.toString());const a=await this.getExchange(t);return e.marketFeeAvailable=await this.unitsToAmount(a.baseToken,e.marketFeeAvailable,+a.btDecimals),e.oceanFeeAvailable=await this.unitsToAmount(a.baseToken,e.oceanFeeAvailable,+a.btDecimals),e.exchangeId=t,e}async getExchanges(){return await this.contract.methods.getExchanges().call()}async isActive(t){return await this.contract.methods.isActive(t).call()}async estActivateMint(t,e,a){return x(t,(a||this.fixedRateContract).methods.toggleMintState,e,!0)}async activateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!0===a.withMint)return null;const s=await x(t,this.contract.methods.toggleMintState,e,!0);return await this.contract.methods.toggleMintState(e,!0).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estDeactivateMint(t,e,a){return x(t,(a||this.fixedRateContract).methods.toggleMintState,e)}async deactivateMint(t,e){const a=await this.getExchange(e);if(!a)return null;if(!1===a.withMint)return null;const s=await x(t,this.contract.methods.toggleMintState,e,!1);return await this.contract.methods.toggleMintState(e,!1).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estCollectBT(t,e,a,s){const n=s||this.fixedRateContract,i=await this.contract.methods.getExchange(e).call(),o=await this.amountToUnits(i.baseToken,a,+i.btDecimals);return x(t,n.methods.collectBT,e,o)}async collectBT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(s.baseToken,a,+s.btDecimals),i=await x(t,this.contract.methods.collectBT,e,n);return await this.contract.methods.collectBT(e,n).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estCollectDT(t,e,a,s){const n=s||this.fixedRateContract,i=await this.contract.methods.getExchange(e).call(),o=await this.amountToUnits(i.datatoken,a,+i.dtDecimals);return x(t,n.methods.collectDT,e,o)}async collectDT(t,e,a){if(!await this.getExchange(e))return null;const s=await this.contract.methods.getExchange(e).call(),n=await this.amountToUnits(s.datatoken,a,+s.dtDecimals),i=await x(t,this.contract.methods.collectDT,e,n);return await this.contract.methods.collectDT(e,n).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estCollectMarketFee(t,e,a){return x(t,(a||this.fixedRateContract).methods.collectMarketFee,e)}async collectMarketFee(t,e){if(!await this.getExchange(e))return null;const a=await x(t,this.contract.methods.collectMarketFee,e);return await this.contract.methods.collectMarketFee(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estCollectOceanFee(t,e,a){return x(t,(a||this.fixedRateContract).methods.collectMarketFee,e)}async collectOceanFee(t,e){if(!await this.getExchange(e))return null;const a=await x(t,this.contract.methods.collectOceanFee,e);return await this.contract.methods.collectOceanFee(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async getRouter(){let t=null;try{t=await this.contract.methods.router().call()}catch(t){f.error(`ERROR: Failed to get Router address: ${t.message}`)}return t}async getExchangeOwner(t){let e=null;try{e=await(await this.getExchange(t)).exchangeOwner}catch(t){f.error(`ERROR: Failed to get OPF Collector address: ${t.message}`)}return e}async estUpdateMarketFee(t,e,a,s){return x(t,(s||this.fixedRateContract).methods.updateMarketFee,e,a)}async updateMarketFee(t,e,a){const s=await x(t,this.contract.methods.updateMarketFee,e,this.web3.utils.toWei(a));return await this.contract.methods.updateMarketFee(e,this.web3.utils.toWei(a)).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estUpdateMarketFeeCollector(t,e,a,s){return x(t,(s||this.fixedRateContract).methods.updateMarketFeeCollector,e,a)}async updateMarketFeeCollector(t,e,a){const s=await x(t,this.contract.methods.updateMarketFeeCollector,e,a);return await this.contract.methods.updateMarketFeeCollector(e,a).send({from:t,gas:s+1,gasPrice:await R(this.web3,this.config)})}}class ht{constructor(t,e,a=null,s){this.ssAbi=void 0,this.web3=void 0,this.config=void 0,this.ssAbi=a||l.abi,this.web3=t,this.config=s||(new B).getConfig(e||"unknown")}sideStakingContract(t){return T(new this.web3.eth.Contract(this.ssAbi,t),this.config)}async unitsToAmount(t,e,a){return O(this.web3,t,e,a)}async getDatatokenCirculatingSupply(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getDatatokenCirculatingSupply(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s.toString()}async getDatatokenCurrentCirculatingSupply(t,e){try{const a=T(new this.web3.eth.Contract(this.ssAbi,t),this.config);let s=null;return s=await a.methods.getDatatokenCurrentCirculatingSupply(e).call(),s.toString()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}}async getPublisherAddress(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getPublisherAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getBaseToken(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getBaseTokenAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getPoolAddress(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getPoolAddress(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getBaseTokenBalance(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getBaseTokenBalance(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getDatatokenBalance(t,e,a){const s=this.sideStakingContract(t);let n=null;try{n=await s.methods.getDatatokenBalance(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return n=await this.unitsToAmount(e,n,a),n}async getvestingEndBlock(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getvestingEndBlock(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getvestingAmount(t,e,a){const s=new this.web3.eth.Contract(this.ssAbi,t);let n=null;try{n=await s.methods.getvestingAmount(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return n=await this.unitsToAmount(e,n,a),n}async getvestingLastBlock(t,e){const a=this.sideStakingContract(t);let s=null;try{s=await a.methods.getvestingLastBlock(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return s}async getvestingAmountSoFar(t,e,a){const s=this.sideStakingContract(t);let n=null;try{n=await s.methods.getvestingAmountSoFar(e).call()}catch(t){f.error(`ERROR: Failed to get: ${t.message}`)}return n=await this.unitsToAmount(e,n,a),n}async estGetVesting(t,e,a,s){return x(t,(s||this.sideStakingContract(e)).methods.getVesting,a)}async getVesting(t,e,a){const s=this.sideStakingContract(e);let n=null;const i=await x(t,s.methods.getVesting,a);try{n=await s.methods.getVesting(a).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error("ERROR: Failed to join swap pool amount out")}return n}async estSetPoolSwapFee(t,e,a,s,n,i){return x(t,(i||this.sideStakingContract(e)).methods.setPoolSwapFee,a,s,n)}async setPoolSwapFee(t,e,a,s,n){const i=this.sideStakingContract(e);let o=null;const r=await x(t,i.methods.setPoolSwapFee,a,s,n);try{o=await i.methods.setPoolSwapFee(a,s,n).send({from:t,gas:r+1,gasPrice:await R(this.web3,this.config)})}catch(t){f.error("ERROR: Failed to join swap pool amount out")}return o}async getRouter(t){const e=this.sideStakingContract(t);let a=null;try{a=await e.methods.router().call()}catch(t){f.error(`ERROR: Failed to get Router address: ${t.message}`)}return a}}class lt{constructor(t,e,a,s,n){this.routerAddress=void 0,this.RouterAbi=void 0,this.web3=void 0,this.config=void 0,this.router=void 0,this.routerAddress=t,this.RouterAbi=s||d.abi,this.web3=e,this.config=n||(new B).getConfig(a||"unknown"),this.router=T(new this.web3.eth.Contract(this.RouterAbi,this.routerAddress),this.config)}async estGasBuyDTBatch(t,e){return x(t,this.router.methods.buyDTBatch,e)}async buyDTBatch(t,e){const a=await x(t,this.router.methods.buyDTBatch,e);return await this.router.methods.buyDTBatch(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async isApprovedToken(t){return await this.router.methods.isApprovedToken(t).call()}async isSideStaking(t){return await this.router.methods.isSSContract(t).call()}async isFixedPrice(t){return await this.router.methods.isFixedRateContract(t).call()}async getOwner(){return await this.router.methods.routerOwner().call()}async getNFTFactory(){return await this.router.methods.factory().call()}async isPoolTemplate(t){return await this.router.methods.isPoolTemplate(t).call()}async estGasAddApprovedToken(t,e,a){return x(t,this.router.methods.addApprovedToken,e)}async addApprovedToken(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.addApprovedToken,e);return await this.router.methods.addApprovedToken(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveApprovedToken(t,e,a){return x(t,this.router.methods.removeApprovedToken,e)}async removeApprovedToken(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.removeApprovedToken,e);return await this.router.methods.removeApprovedToken(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddSSContract(t,e){return x(t,this.router.methods.addSSContract,e)}async addSSContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.addSSContract,e);return await this.router.methods.addSSContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveSSContract(t,e){return x(t,this.router.methods.removeSSContract,e)}async removeSSContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.removeSSContract,e);return await this.router.methods.removeSSContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddFixedRateContract(t,e){return x(t,this.router.methods.addFixedRateContract,e)}async addFixedRateContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.addFixedRateContract,e);return await this.router.methods.addFixedRateContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveFixedRateContract(t,e){return x(t,this.router.methods.removeFixedRateContract,e)}async removeFixedRateContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.removeFixedRateContract,e);return await this.router.methods.removeFixedRateContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddDispenserContract(t,e){return x(t,this.router.methods.addDispenserContract,e)}async addDispenserContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.addDispenserContract,e);return await this.router.methods.addDispenserContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveDispenserContract(t,e){return x(t,this.router.methods.removeDispenserContract,e)}async removeDispenserContract(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.removeDispenserContract,e);return await this.router.methods.removeDispenserContract(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async getOPCFee(t){return await this.router.methods.getOPCFee(t).call()}async getCurrentOPCFee(){return await this.router.methods.swapOceanFee().call()}async estGasUpdateOPCFee(t,e,a,s,n){return x(t,this.router.methods.updateOPCFee,e,a,s,n)}async updateOPCFee(t,e,a,s,n){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const i=await x(t,this.router.methods.updateOPCFee,e,a,s,n);return await this.router.methods.updateOPCFee(e,a,s,n).send({from:t,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasAddPoolTemplate(t,e){return x(t,this.router.methods.addPoolTemplate,e)}async addPoolTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.addPoolTemplate,e);return await this.router.methods.addPoolTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasRemovePoolTemplate(t,e){return x(t,this.router.methods.removePoolTemplate,e)}async removePoolTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Router Owner");const a=await x(t,this.router.methods.removePoolTemplate,e);return await this.router.methods.removePoolTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}}class dt{constructor(t,e,a,s){this.factory721Address=void 0,this.factory721Abi=void 0,this.nftAbi=void 0,this.web3=void 0,this.startBlock=void 0,this.config=void 0,this.nftAbi=a||w.abi,this.web3=t,this.config=s||(new B).getConfig(e||"unknown")}async estGasCreateErc20(t,e,a,s,n,i,o,r,c,h,l,d){return x(e,(d||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.createERC20,l,[c,h],[a,s,n,i],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[])}async createErc20(t,e,a,s,n,i,o,r,c,h,l){if(!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not ERC20Deployer");l||(l=1),c&&h||({name:c,symbol:h}=y());const d=T(new this.web3.eth.Contract(this.nftAbi,t),this.config),u=await x(e,d.methods.createERC20,l,[c,h],[a,s,n,i],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]),w=await d.methods.createERC20(l,[c,h],[a,s,n,i],[this.web3.utils.toWei(r),this.web3.utils.toWei(o)],[]).send({from:e,gas:u+1,gasPrice:await R(this.web3,this.config)});let m=null;try{m=w.events.TokenCreated.returnValues[0]}catch(t){f.error(`ERROR: Failed to create datatoken : ${t.message}`)}return m}async estGasAddManager(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.addManager,a)}async addManager(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=await x(e,s.methods.addManager,a);return await s.methods.addManager(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveManager(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.removeManager,a)}async removeManager(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const n=await x(e,s.methods.removeManager,a);return await s.methods.removeManager(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasAddErc20Deployer(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.addToCreateERC20List,a)}async addErc20Deployer(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const n=await x(e,s.methods.addToCreateERC20List,a);return await s.methods.addToCreateERC20List(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveErc20Deployer(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.removeFromCreateERC20List,a)}async removeErc20Deployer(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e===a&&!0!==(await this.getNftPermissions(t,e)).deployERC20)throw new Error("Caller is not Manager nor ERC20Deployer");const n=await x(e,s.methods.removeFromCreateERC20List,a);return await s.methods.removeFromCreateERC20List(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasAddMetadataUpdater(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.addToMetadataList,a)}async addMetadataUpdater(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const n=await x(e,s.methods.addToMetadataList,a);return await s.methods.addToMetadataList(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async esGasRemoveMetadataUpdater(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.removeFromMetadataList,a)}async removeMetadataUpdater(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Manager nor Metadata Updater");const n=await this.esGasRemoveMetadataUpdater(t,e,a,s);return await s.methods.removeFromMetadataList(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasAddStoreUpdater(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.addTo725StoreList,a)}async addStoreUpdater(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager)throw new Error("Caller is not Manager");const n=await x(e,s.methods.addTo725StoreList,a);return await s.methods.addTo725StoreList(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveStoreUpdater(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.removeFrom725StoreList,a)}async removeStoreUpdater(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!0!==(await this.getNftPermissions(t,e)).manager||e!==a&&!0!==(await this.getNftPermissions(t,e)).store)throw new Error("Caller is not Manager nor storeUpdater");const n=await x(e,s.methods.removeFrom725StoreList,a);return await s.methods.removeFrom725StoreList(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){return x(e,(a||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.cleanPermissions)}async cleanPermissions(t,e){const a=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const s=await x(e,a.methods.cleanPermissions);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}async estGasTransferNft(t,e,a,s,n){return x(e,(n||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.transferFrom,e,a,s)}async transferNft(t,e,a,s){const n=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=s||1,o=await x(e,n.methods.transferFrom,e,a,i);return await n.methods.transferFrom(e,a,i).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasSafeTransferNft(t,e,a,s,n){return x(e,(n||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.safeTransferFrom,e,a,s)}async safeTransferNft(t,e,a,s){const n=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(await this.getNftOwner(t)!==e)throw new Error("Caller is not NFT Owner");const i=s||1,o=await x(e,n.methods.safeTransferFrom,e,a,i);return await n.methods.safeTransferFrom(e,a,i).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadata(t,e,a,s,n,i,o,r,c,h){return c||(c=[]),x(e,(h||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.setMetaData,a,s,n,i,o,r,c)}async setMetadata(t,e,a,s,n,i,o,r,c){const h=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(c||(c=[]),!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const l=await x(e,h.methods.setMetaData,a,s,n,i,o,r,c);return await h.methods.setMetaData(a,s,n,i,o,r,c).send({from:e,gas:l+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadataAndTokenURI(t,e,a,s){const n=s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config),i=N({},a,{metadataProofs:a.metadataProofs||[]});return x(e,n.methods.setMetaDataAndTokenURI,i)}async setMetadataAndTokenURI(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const n=N({},a,{metadataProofs:a.metadataProofs||[]}),i=await x(e,s.methods.setMetaDataAndTokenURI,n);return await s.methods.setMetaDataAndTokenURI(n).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasSetMetadataState(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.nftAbi,t),this.config)).methods.setMetaDataState,a)}async setMetadataState(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);if(!(await this.getNftPermissions(t,e)).updateMetadata)throw new Error("Caller is not Metadata updater");const n=await x(e,s.methods.setMetaDataState,a);return await s.methods.setMetaDataState(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estSetTokenURI(t,e,a){return x(e,T(new this.web3.eth.Contract(this.nftAbi,t),this.config).methods.setTokenURI,"1",a)}async setTokenURI(t,e,a){const s=T(new this.web3.eth.Contract(this.nftAbi,t),this.config),n=await x(e,s.methods.setTokenURI,"1",a);return await s.methods.setTokenURI("1",a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async getNftOwner(t){const e=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.ownerOf(1).call()}async getNftPermissions(t,e){const a=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getPermissions(e).call()}async getMetadata(t){const e=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await e.methods.getMetaData().call()}async isErc20Deployer(t,e){const a=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async getData(t,e){const a=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.getData(e).call()}async getTokenURI(t,e){const a=T(new this.web3.eth.Contract(this.nftAbi,t),this.config);return await a.methods.tokenURI(e).call()}}class ut{constructor(t,e,a,s,n){this.factoryAddress=void 0,this.factoryABI=void 0,this.datatokensAbi=void 0,this.datatokensEnterpriseAbi=void 0,this.web3=void 0,this.config=void 0,this.nft=void 0,this.web3=t,this.datatokensAbi=a||r.abi,this.datatokensEnterpriseAbi=s||u.abi,this.config=n||(new B).getConfig(e||"unknown"),this.nft=new dt(this.web3)}async estGasApprove(t,e,a,s,n){return x(s,(n||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.approve,e,this.web3.utils.toWei(a))}async approve(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),i=await x(s,n.methods.approve,e,this.web3.utils.toWei(a));return await n.methods.approve(e,this.web3.utils.toWei(a)).send({from:s,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasMint(t,e,a,s,n){return x(e,(n||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.mint,s||e,this.web3.utils.toWei(a))}async estGasCreateFixedRate(t,e,a,s){const n=s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return a.allowedConsumer||(a.allowedConsumer=k),x(e,n.methods.createFixedRate,a.fixedRateAddress,[a.baseTokenAddress,e,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,a.withMint?1:0])}async createFixedRate(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");a.allowedConsumer||(a.allowedConsumer=k);const n=a.withMint?1:0,i=await x(e,s.methods.createFixedRate,a.fixedRateAddress,[a.baseTokenAddress,a.owner,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,n]);return await s.methods.createFixedRate(a.fixedRateAddress,[a.baseTokenAddress,a.owner,a.marketFeeCollector,a.allowedConsumer],[a.baseTokenDecimals,a.datatokenDecimals,a.fixedRate,a.marketFee,n]).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateDispenser(t,e,a,s,n){const i=n||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return s.allowedSwapper||(s.allowedSwapper=k),s.withMint||(s.withMint=!1),x(e,i.methods.createDispenser,a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper)}async createDispenser(t,e,a,s){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const n=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);s.allowedSwapper||(s.allowedSwapper=k),s.withMint||(s.withMint=!1);const i=await x(e,n.methods.createDispenser,a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper);return await n.methods.createDispenser(a,s.maxTokens,s.maxBalance,s.withMint,s.allowedSwapper).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}async mint(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==(await this.getDTPermissions(t,e)).minter)throw new Error("Caller is not Minter");const o=await this.getCap(t);if(new i(o).gte(a)){const t=await x(e,n.methods.mint,s||e,this.web3.utils.toWei(a));return await n.methods.mint(s||e,this.web3.utils.toWei(a)).send({from:e,gas:t+1,gasPrice:await R(this.web3,this.config)})}throw new Error("Mint amount exceeds cap available")}async estGasAddMinter(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.addMinter,a)}async addMinter(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const n=await x(e,s.methods.addMinter,a);return await s.methods.addMinter(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasRemoveMinter(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.removeMinter,a)}async removeMinter(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const n=await x(e,s.methods.removeMinter,a);return await s.methods.removeMinter(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasAddPaymentManager(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.addPaymentManager,a)}async addPaymentManager(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const n=await x(e,s.methods.addPaymentManager,a);return await s.methods.addPaymentManager(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasRemovePaymentManager(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.removePaymentManager,a)}async removePaymentManager(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);if(!0!==await this.isERC20Deployer(t,e))throw new Error("Caller is not ERC20Deployer");const n=await x(e,s.methods.removePaymentManager,a);return await s.methods.removePaymentManager(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasSetPaymentCollector(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.setPaymentCollector,a)}async setPaymentCollector(t,e,a){const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=(await this.getDTPermissions(t,e)).paymentManager,i=!n&&await this.getNFTAddress(t),o=i&&await this.nft.getNftOwner(i)===e,r=i&&!o&&await this.nft.getNftPermissions(i,e);if(!n&&!o&&!(null==r?void 0:r.deployERC20))throw new Error("Caller is not Fee Manager, owner or erc20 Deployer");const c=await x(e,s.methods.setPaymentCollector,a);return await s.methods.setPaymentCollector(a).send({from:e,gas:c+1,gasPrice:await R(this.web3,this.config)})}async getPaymentCollector(t){const e=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getPaymentCollector().call()}async transfer(t,e,a,s){const n=this.web3.utils.toWei(a);return this.transferWei(t,e,n,s)}async estGasTransfer(t,e,a,s,n){return x(s,(n||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.transfer,e,a)}async transferWei(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);try{const t=await x(s,n.methods.transfer,e,a);return await n.methods.transfer(e,a).send({from:s,gas:t+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to transfer tokens: ${t.message}`),new Error(`Failed Failed to transfer tokens: ${t.message}`)}}async estGasStartOrder(t,e,a,s,n,i,o){return x(e,(o||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.startOrder,a,s,n,i)}async startOrder(t,e,a,s,n,o){var r=this;const c=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);o||(o={consumeMarketFeeAddress:k,consumeMarketFeeToken:k,consumeMarketFeeAmount:"0"});const h=await c.methods.getPublishingMarketFee().call(),l=[{token:n.providerFeeToken,feeAmount:n.providerFeeAmount},{token:o.consumeMarketFeeToken,feeAmount:parseFloat(o.consumeMarketFeeAmount)},{token:h[1],feeAmount:parseFloat(h[2])}],d=[];l.map(t=>{d.length>0?d.map(e=>{e.token===t.token?e.feeAmount+=t.feeAmount:d.push({token:t.token,feeAmount:t.feeAmount})}):d.push({token:t.token,feeAmount:t.feeAmount})});const u=d.map(async function(t){if(t.token===k||0===t.feeAmount)return t;const s=await H(r.web3,t.token,e,a);if(new i(s).greaterThanOrEqualTo(new i(t.feeAmount)))throw f.error(`ERROR: Failed checking allowance: ${t.token}`),new Error(`allowance (${s}) is too low`);return t.currentAllowance=s,t});try{await Promise.all(u)}catch(t){throw f.error(`ERROR: Failed checking allowance : ${t}`),new Error(`Failed checking allowance: ${t}`)}try{const t=await x(e,c.methods.startOrder,a,s,n,o);return await c.methods.startOrder(a,s,n,o).send({from:e,gas:t+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to start order : ${t.message}`),new Error(`Failed to start order: ${t.message}`)}}async estGasReuseOrder(t,e,a,s,n){return x(e,(n||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.reuseOrder,a,s)}async reuseOrder(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);try{const t=await x(e,n.methods.reuseOrder,a,s);return await n.methods.reuseOrder(a,s).send({from:e,gas:t+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to call reuse order order : ${t.message}`),new Error(`Failed to start order: ${t.message}`)}}async estGasBuyFromFreAndOrder(t,e,a,s,n){return x(e,(n||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t)).methods.buyFromFreAndOrder,a,s)}async buyFromFreAndOrder(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),this.config);try{const t=v(s),i=await x(e,n.methods.buyFromFreAndOrder,a,t);return await n.methods.buyFromFreAndOrder(a,t).send({from:e,gas:i+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasBuyFromDispenserAndOrder(t,e,a,s,n){return x(e,(n||new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t)).methods.buyFromDispenserAndOrder,a,s)}async buyFromDispenserAndOrder(t,e,a,s){const n=T(new this.web3.eth.Contract(this.datatokensEnterpriseAbi,t),this.config);try{const t=await x(e,n.methods.buyFromDispenserAndOrder,a,s);return await n.methods.buyFromDispenserAndOrder(a,s).send({from:e,gas:t+1,gasPrice:await R(this.web3,this.config)})}catch(t){throw f.error(`ERROR: Failed to buy DT From Fre And Order : ${t.message}`),new Error(`Failed to buy DT From Fre And Order: ${t.message}`)}}async estGasSetData(t,e,a,s){return x(e,(s||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.setData,a)}async setData(t,e,a){if(!await this.isERC20Deployer(t,e))throw new Error("User is not ERC20 Deployer");const s=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),n=await x(e,s.methods.setData,a);return await s.methods.setData(a).send({from:e,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasCleanPermissions(t,e,a){return x(e,(a||T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config)).methods.cleanPermissions)}async cleanPermissions(t,e){if(await this.nft.getNftOwner(await this.getNFTAddress(t))!==e)throw new Error("Caller is NOT Nft Owner");const a=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),s=await x(e,a.methods.cleanPermissions);return await a.methods.cleanPermissions().send({from:e,gas:s+1,gasPrice:await R(this.web3,this.config)})}async getDTPermissions(t,e){const a=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.permissions(e).call()}async getCap(t){const e=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config),a=await e.methods.cap().call();return this.web3.utils.fromWei(a)}async getDecimals(t){const e=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.decimals().call()}async getNFTAddress(t){const e=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await e.methods.getERC721Address().call()}async isERC20Deployer(t,e){const a=T(new this.web3.eth.Contract(this.datatokensAbi,t),this.config);return await a.methods.isERC20Deployer(e).call()}async balance(t,e){const a=T(new this.web3.eth.Contract(this.datatokensAbi,t,{from:e}),this.config),s=await a.methods.balanceOf(e).call();return this.web3.utils.fromWei(s)}async estGasSetPublishingMarketFee(t,e,a,s,n){return x(n,new this.web3.eth.Contract(this.datatokensAbi,t,{from:n}).methods.setPublishingMarketFee,e,a,s)}async setPublishingMarketFee(t,e,a,s,n){const i=new this.web3.eth.Contract(this.datatokensAbi,t,{from:n});if((await i.methods.getPublishingMarketFee().call())[0]!==n)throw new Error("Caller is not the Publishing Market Fee Address");const o=await this.estGasSetPublishingMarketFee(t,e,a,s,n);await i.methods.setPublishingMarketFee(e,a,s).send({from:n,gas:o+1,gasPrice:await R(this.web3,this.config)})}async getPublishingMarketFee(t,e){const a=new this.web3.eth.Contract(this.datatokensAbi,t,{from:e}),s=await a.methods.getPublishingMarketFee().call();return{publishMarketFeeAddress:s[0],publishMarketFeeToken:s[1],publishMarketFeeAmount:s[2]}}}class wt{constructor(t,e,a,s,n){this.factory721Address=void 0,this.factory721Abi=void 0,this.web3=void 0,this.config=void 0,this.factory721=void 0,this.factory721Address=t,this.factory721Abi=s||m.abi,this.web3=e,this.config=n||(new B).getConfig(a||"unknown"),this.factory721=T(new this.web3.eth.Contract(this.factory721Abi,this.factory721Address),this.config)}async estGasCreateNFT(t,e){return x(t,this.factory721.methods.deployERC721Contract,e.name,e.symbol,e.templateIndex,k,k,e.tokenURI,e.transferable,e.owner)}async createNFT(t,e){if(e.templateIndex||(e.templateIndex=1),!e.name||!e.symbol){const{name:t,symbol:a}=y();e.name=t,e.symbol=a}if(e.templateIndex>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e.templateIndex)throw new Error("Template index cannot be ZERO");if(!1===(await this.getNFTTemplate(e.templateIndex)).isActive)throw new Error("Template is not active");const a=await x(t,this.factory721.methods.deployERC721Contract,e.name,e.symbol,e.templateIndex,k,k,e.tokenURI,e.transferable,e.owner),s=await this.factory721.methods.deployERC721Contract(e.name,e.symbol,e.templateIndex,k,k,e.tokenURI,e.transferable,e.owner).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)});let n=null;try{n=s.events.NFTCreated.returnValues[0]}catch(t){f.error(`ERROR: Failed to create datatoken : ${t.message}`)}return n}async getCurrentNFTCount(){return await this.factory721.methods.getCurrentNFTCount().call()}async getCurrentTokenCount(){return await this.factory721.methods.getCurrentTokenCount().call()}async getOwner(){return await this.factory721.methods.owner().call()}async getCurrentNFTTemplateCount(){return await this.factory721.methods.getCurrentNFTTemplateCount().call()}async getCurrentTokenTemplateCount(){return await this.factory721.methods.getCurrentTemplateCount().call()}async getNFTTemplate(t){if(t>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===t)throw new Error("Template index cannot be ZERO");return await this.factory721.methods.getNFTTemplate(t).call()}async getTokenTemplate(t){return await this.factory721.methods.getTokenTemplate(t).call()}async checkDatatoken(t){return await this.factory721.methods.erc20List(t).call()}async checkNFT(t){return await this.factory721.methods.erc721List(t).call()}async estGasAddNFTTemplate(t,e){return x(t,this.factory721.methods.add721TokenTemplate,e)}async addNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===k)throw new Error("Template cannot be ZERO address");const a=await x(t,this.factory721.methods.add721TokenTemplate,e);return await this.factory721.methods.add721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasDisableNFTTemplate(t,e){return x(t,this.factory721.methods.disable721TokenTemplate,e)}async disableNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await x(t,this.factory721.methods.disable721TokenTemplate,e);return await this.factory721.methods.disable721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasReactivateNFTTemplate(t,e){return x(t,this.factory721.methods.reactivate721TokenTemplate,e)}async reactivateNFTTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentNFTTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");const a=await x(t,this.factory721.methods.reactivate721TokenTemplate,e);return await this.factory721.methods.reactivate721TokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasAddTokenTemplate(t,e){return x(t,this.factory721.methods.addTokenTemplate,e)}async addTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e===k)throw new Error("Template cannot be address ZERO");const a=await x(t,this.factory721.methods.addTokenTemplate,e);return await this.factory721.methods.addTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasDisableTokenTemplate(t,e){return x(t,this.factory721.methods.disableTokenTemplate,e)}async disableTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!1===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already disabled");const a=await x(t,this.factory721.methods.disableTokenTemplate,e);return await this.factory721.methods.disableTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasReactivateTokenTemplate(t,e){return x(t,this.factory721.methods.reactivateTokenTemplate,e)}async reactivateTokenTemplate(t,e){if(await this.getOwner()!==t)throw new Error("Caller is not Factory Owner");if(e>await this.getCurrentTokenTemplateCount())throw new Error("Template index doesnt exist");if(0===e)throw new Error("Template index cannot be ZERO");if(!0===(await this.getTokenTemplate(e)).isActive)throw new Error("Template is already active");const a=await x(t,this.factory721.methods.reactivateTokenTemplate,e);return await this.factory721.methods.reactivateTokenTemplate(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasStartMultipleTokenOrder(t,e){return x(t,this.factory721.methods.startMultipleTokenOrder,e)}async startMultipleTokenOrder(t,e){if(e.length>50)throw new Error("Too many orders");const a=await x(t,this.factory721.methods.startMultipleTokenOrder,e);return await this.factory721.methods.startMultipleTokenOrder(e).send({from:t,gas:a+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftWithErc20(t,e,a){const s=E(a);return x(t,this.factory721.methods.createNftWithErc20,e,s)}async createNftWithErc20(t,e,a){const s=E(a),n=await x(t,this.factory721.methods.createNftWithErc20,e,s);return await this.factory721.methods.createNftWithErc20(e,s).send({from:t,gas:n+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithPool(t,e,a,s){const n=E(a),i=await P(this.web3,s);return x(t,this.factory721.methods.createNftWithErc20WithPool,e,n,i)}async createNftErc20WithPool(t,e,a,s){const n=E(a),i=await P(this.web3,s),o=await x(t,this.factory721.methods.createNftWithErc20WithPool,e,n,i);return await this.factory721.methods.createNftWithErc20WithPool(e,n,i).send({from:t,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithFixedRate(t,e,a,s){const n=E(a),i=await F(s);return x(t,this.factory721.methods.createNftWithErc20WithFixedRate,e,n,i)}async createNftErc20WithFixedRate(t,e,a,s){const n=E(a),i=F(s),o=await x(t,this.factory721.methods.createNftWithErc20WithFixedRate,e,n,i);return console.log("createNftErc20WithFixedRate estGas + 1",o+1),await this.factory721.methods.createNftWithErc20WithFixedRate(e,n,i).send({from:t,gas:o+1,gasPrice:await R(this.web3,this.config)})}async estGasCreateNftErc20WithDispenser(t,e,a,s){const n=E(a);return x(t,this.factory721.methods.createNftWithErc20WithDispenser,e,n,s)}async createNftErc20WithDispenser(e,a,s,n){const i=E(s);n.maxBalance=t.utils.toWei(n.maxBalance),n.maxTokens=t.utils.toWei(n.maxTokens);const o=await x(e,this.factory721.methods.createNftWithErc20WithDispenser,a,i,n);return await this.factory721.methods.createNftWithErc20WithDispenser(a,i,n).send({from:e,gas:o+1,gasPrice:await R(this.web3,this.config)})}}class mt{constructor(){this.transactionBlockTimeout=void 0,this.transactionConfirmationBlocks=void 0,this.transactionPollingTimeout=void 0,this.gasFeeMultiplier=void 0}}class gt extends mt{constructor(...t){super(...t),this.nodeUri=void 0,this.providerAddress=void 0,this.metadataCacheUri=void 0,this.providerUri=void 0,this.web3Provider=void 0,this.oceanTokenAddress=void 0,this.erc721FactoryAddress=void 0,this.erc721FFactoryABI=void 0,this.datatokensABI=void 0,this.poolTemplateAddress=void 0,this.poolFactoryABI=void 0,this.poolABI=void 0,this.fixedRateExchangeAddress=void 0,this.fixedRateExchangeAddressABI=void 0,this.dispenserAddress=void 0,this.dispenserABI=void 0,this.opfCommunityFeeCollector=void 0,this.sideStakingAddress=void 0,this.startBlock=void 0,this.verbose=void 0,this.authMessage=void 0,this.authTokenExpiration=void 0,this.parityUri=void 0,this.threshold=void 0,this.chainId=void 0,this.network=void 0,this.subgraphUri=void 0,this.explorerUri=void 0,this.oceanTokenSymbol=void 0}}const pt=t=>function(t="",e){const{valid:a,output:s}=function(t,e,a){if("string"!=typeof t)throw f.debug("Not input string:"),f.debug(t),new Error("[zeroXTransformer] Expected string, input type: "+typeof t);const s=t.match(/^(?:0x)*([a-f0-9]+)$/i);return s?{valid:!0,output:s[1]}:(f.warn("[zeroXTransformer] Input transformation failed."),{valid:!1,output:t})}(t);return(e&&a?"0x":"")+s}(t,!1);class ft{async getEndpoints(t){try{const e=await I(t);return await e.json()}catch(t){return f.error("Finding the service endpoints failed:",t),null}}getEndpointURL(t,e){return t?t.find(t=>t.serviceName===e):null}async getServiceEndpoints(t,e){const a=[];for(const s in e.serviceEndpoints)a.push({serviceName:s,method:e.serviceEndpoints[s][0],urlPath:t+e.serviceEndpoints[s][1]});return a}async getNonce(t,e,s,n,i){n||(n=await this.getEndpoints(t)),i||(i=await this.getServiceEndpoints(t,n));const o=this.getEndpointURL(i,"nonce")?this.getEndpointURL(i,"nonce").urlPath:null;if(!o)return null;try{const t=await a(o+`?userAddress=${e}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:s});return(await t.json()).nonce.toString()}catch(t){throw f.error(t),new Error("HTTP request failed")}}async signProviderRequest(t,e,a,s){const n=t.utils.soliditySha3({t:"bytes",v:t.utils.utf8ToHex(a)});return t&&t.currentProvider&&t.currentProvider.isMetaMask?await t.eth.personal.sign(n,e,s):await t.eth.sign(n,e)}async encrypt(t,e,s){const n=await this.getEndpoints(e),i=await this.getServiceEndpoints(e,n),o=this.getEndpointURL(i,"encrypt")?this.getEndpointURL(i,"encrypt").urlPath:null;if(!o)return null;try{const e=await a(o,{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/octet-stream"},signal:s});return await e.text()}catch(t){throw f.error(t),new Error("HTTP request failed")}}async checkDidFiles(t,e,s,n){const i=await this.getEndpoints(s),o=await this.getServiceEndpoints(s,i),r={did:t,serviceId:e},c=[],h=this.getEndpointURL(o,"fileinfo")?this.getEndpointURL(o,"fileinfo").urlPath:null;if(!h)return null;try{const t=await a(h,{method:"POST",body:JSON.stringify(r),headers:{"Content-Type":"application/json"},signal:n}),e=await t.json();for(const t of e)c.push(t);return c}catch(t){return null}}async checkFileUrl(t,e,s){const n=await this.getEndpoints(e),i=await this.getServiceEndpoints(e,n),o={url:t,type:"url"},r=[],c=this.getEndpointURL(i,"fileinfo")?this.getEndpointURL(i,"fileinfo").urlPath:null;if(!c)return null;try{const t=await a(c,{method:"POST",body:JSON.stringify(o),headers:{"Content-Type":"application/json"},signal:s}),e=await t.json();for(const t of e)r.push(t);return r}catch(t){return null}}async getComputeEnvironments(t,e){var s;const n=await this.getEndpoints(t),i=await this.getServiceEndpoints(t,n),o=null==(s=this.getEndpointURL(i,"computeEnvironments"))?void 0:s.urlPath;if(!o)return null;try{const t=await a(o,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});return await t.json()}catch(t){return f.error(t.message),null}}async initialize(t,e,s,n,i,o,r,c,h){const l=await this.getEndpoints(i),d=await this.getServiceEndpoints(i,l);let u=this.getEndpointURL(d,"initialize")?this.getEndpointURL(d,"initialize").urlPath:null;if(!u)return null;u+=`?documentId=${t}`,u+=`&serviceId=${e}`,u+=`&fileIndex=${s}`,u+=`&consumerAddress=${n}`,r&&(u+="&userdata="+encodeURI(JSON.stringify(r))),c&&(u+="&environment="+encodeURI(c)),h&&(u+="&validUntil="+h);try{const t=await a(u,{method:"GET",headers:{"Content-Type":"application/json"},signal:o});return await t.json()}catch(t){throw f.error(t),new Error("Asset URL not found or not available.")}}async initializeCompute(t,e,s,n,i,o,r){const c=await this.getEndpoints(i),h=await this.getServiceEndpoints(i,c),l={datasets:t,algorithm:e,compute:{env:s,validUntil:n},consumerAddress:o},d=this.getEndpointURL(h,"initializeCompute")?this.getEndpointURL(h,"initializeCompute").urlPath:null;if(!d)return null;try{const t=await a(d,{method:"POST",body:JSON.stringify(l),headers:{"Content-Type":"application/json"},signal:r});return await t.json()}catch(t){throw f.error(t),new Error("ComputeJob cannot be initialized")}}async getDownloadUrl(t,e,a,s,n,i,o,r){const c=await this.getEndpoints(i),h=await this.getServiceEndpoints(i,c),l=this.getEndpointURL(h,"download")?this.getEndpointURL(h,"download").urlPath:null;if(!l)return null;const d=Date.now();let u=l;return u+=`?fileIndex=${s}`,u+=`&documentId=${t}`,u+=`&transferTxId=${n}`,u+=`&serviceId=${a}`,u+=`&consumerAddress=${e}`,u+=`&nonce=${d}`,u+=`&signature=${await this.signProviderRequest(o,e,t+d)}`,r&&(u+="&userdata="+encodeURI(JSON.stringify(r))),u}async computeStart(t,e,s,n,i,o,r,c,h){const l=await this.getEndpoints(t),d=await this.getServiceEndpoints(t,l),u=this.getEndpointURL(d,"computeStart")?this.getEndpointURL(d,"computeStart").urlPath:null,w=Date.now();let m=s;m+=i.documentId,m+=w;const g=await this.signProviderRequest(e,s,m),p=Object();if(p.consumerAddress=s,p.signature=g,p.nonce=w,p.environment=n,p.dataset=i,p.algorithm=o,p.additionalDatasets&&(p.additionalDatasets=c),h&&(p.output=h),!u)return null;try{const t=await a(u,{method:"POST",body:JSON.stringify(p),headers:{"Content-Type":"application/json"},signal:r});return null!=t&&t.ok?await t.json():(f.error("Compute start failed: ",t.status,t.statusText),f.error("Payload was:",p),null)}catch(t){return f.error("Compute start failed:"),f.error(t),f.error("Payload was:",p),null}}async computeStop(t,e,s,n,i,o){const r=await this.getEndpoints(n),c=await this.getServiceEndpoints(n,r),h=this.getEndpointURL(c,"computeStop")?this.getEndpointURL(c,"computeStop").urlPath:null,l=await this.getNonce(n,e,o,r,c);let d=e;d+=s||"",d+=t&&`${pt(t)}`||"",d+=l;const u=await this.signProviderRequest(i,e,d),w=Object();if(w.signature=u,w.documentId=pt(t),w.consumerAddress=e,s&&(w.jobId=s),!h)return null;try{const t=await a(h,{method:"PUT",body:JSON.stringify(w),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(f.error("Compute stop failed:",t.status,t.statusText),f.error("Payload was:",w),null)}catch(t){return f.error("Compute stop failed:"),f.error(t),f.error("Payload was:",w),null}}async computeStatus(t,e,s,n,i){const o=await this.getEndpoints(t),r=await this.getServiceEndpoints(t,o),c=this.getEndpointURL(r,"computeStatus")?this.getEndpointURL(r,"computeStatus").urlPath:null;let h=`?consumerAddress=${e}`;if(h+=n&&`&documentId=${pt(n)}`||"",h+=s&&`&jobId=${s}`||"",!c)return null;try{const t=await a(c+h,{method:"GET",headers:{"Content-Type":"application/json"},signal:i});return null!=t&&t.ok?await t.json():(f.error("Get compute status failed:",t.status,t.statusText),null)}catch(t){return f.error("Get compute status failed"),f.error(t),null}}async getComputeResultUrl(t,e,a,s,n){const i=await this.getEndpoints(t);console.log("computeResult providerEndpoints: ",i);const o=await this.getServiceEndpoints(t,i);console.log("computeResult serviceEndpoints: ",o);const r=this.getEndpointURL(o,"computeResult")?this.getEndpointURL(o,"computeResult").urlPath:null,c=Date.now();let h=a;h+=s,h+=n.toString(),h+=c;const l=await this.signProviderRequest(e,a,h);if(!r)return null;let d=r;return d+=`?consumerAddress=${a}`,d+=`&jobId=${s}`,d+=`&index=${n.toString()}`,d+=`&nonce=${c}`,d+=l&&`&signature=${l}`||"",d}async computeDelete(t,e,s,n,i,o){const r=await this.getEndpoints(n),c=await this.getServiceEndpoints(n,r),h=this.getEndpointURL(c,"computeDelete")?this.getEndpointURL(c,"computeDelete").urlPath:null,l=await this.getNonce(n,e,o,r,c);let d=e;d+=s||"",d+=t&&`${pt(t)}`||"",d+=l;const u=await this.signProviderRequest(i,e,d),w=Object();if(w.documentId=pt(t),w.consumerAddress=e,w.jobId=s,u&&(w.signature=u),!h)return null;try{const t=await a(h,{method:"DELETE",body:JSON.stringify(w),headers:{"Content-Type":"application/json"},signal:o});return null!=t&&t.ok?await t.json():(f.error("Delete compute job failed:",t.status,t.statusText),f.error("Payload was:",w),null)}catch(t){return f.error("Delete compute job failed:"),f.error(t),f.error("Payload was:",w),null}}async isValidProvider(t,e){try{const s=await a(t,{method:"GET",headers:{"Content-Type":"application/json"},signal:e});if(null!=s&&s.ok){const t=await s.json();if(t&&t.providerAddress)return!0}return!1}catch(t){return f.error(`Error validating provider: ${t.message}`),!1}}}const bt=new ft;export{st as Aquarius,gt as Config,B as ConfigHelper,mt as ContractConfig,ut as Datatoken,ot as Dispenser,rt as FixedRateCreateProgressStep,ct as FixedRateExchange,A as GASLIMIT_DEFAULT,g as LogLevel,p as Logger,f as LoggerInstance,dt as Nft,wt as NftFactory,it as Pool,ft as Provider,bt as ProviderInstance,lt as Router,ht as SideStaking,k as ZERO_ADDRESS,H as allowance,S as amountToUnits,_ as approve,Z as balance,K as calcMaxExactIn,Q as calcMaxExactOut,G as configHelperNetworks,U as downloadFile,D as downloadFileBrowser,z as estApprove,J as estTransfer,x as estimateGas,M as fetchData,L as generateDid,y as generateDtName,I as getData,E as getErcCreationParams,R as getFairGasPrice,F as getFreCreationParams,v as getFreOrderParams,j as getHash,et as getMaxAddLiquidity,at as getMaxRemoveLiquidity,tt as getMaxSwapExactIn,Y as getMaxSwapExactOut,P as getPoolCreationParams,W as postData,T as setContractDefaults,q as signHash,X as sleep,V as transfer,O as unitsToAmount};
//# sourceMappingURL=lib.modern.js.map
